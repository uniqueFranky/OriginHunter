{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "PackWriter.java",
  "functionName": "findObjectsToPack",
  "functionId": "findObjectsToPack___countingMonitor-ProgressMonitor(annotations-@NonNull)__walker-ObjectWalk(annotations-@NonNull)__want-Set__? extends ObjectId__(annotations-@NonNull)__have-Set__? extends ObjectId__(annotations-@NonNull)__noBitmaps-Set__? extends ObjectId__(annotations-@NonNull)",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 1775,
  "functionEndLine": 1993,
  "numCommitsSeen": 444,
  "timeTaken": 5284,
  "changeHistory": [
    "32798dcfdb00662a640f0ff2915766591d21e287",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
    "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "d385a7a5e5cacd875da4301ddeb46a7c56a725fa",
    "7edf05530d83d7f8971db4262ea43e11124c6b63",
    "4e650c0d76b716c0e9cb3592d30def9e609066c1",
    "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092",
    "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
    "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
    "53e39094bf012a4f5b3fe5557219707cb7b0f010",
    "f32b8612433e499090c76ded014dd5e94322b786",
    "3760e4319b02ce79ff1eeae021fd88faebf739d5",
    "dafcb8f6db82b899c917832768f1c240d273190c",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "0f84b86e01da4680633c32bad101d021e0cb98ad",
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
    "9952223e0645fd7a8cddc6093a7f449c6390238d",
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
    "74333e63b60440be5ff9f591f2203b635e26e3a0",
    "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2",
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
    "f67e5602af72b7b2238eb6f6fcdc206a47edabd5",
    "8f865bfffed575c3a4db6d7db92dc5f752f97237",
    "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
    "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
    "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
    "733780e8a158b7bc45b8b687ac353ecadc905a63",
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
    "5664fb3bfb63e4db49dc07d13ace419e810186c2",
    "461b012e9565af8174e5b9d2b2c3a582011ce77e",
    "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
    "2fbcba41e365752681f635c706d577e605d3336a",
    "065a0a8122be356d1f898321763d3518b504b075",
    "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
    "21f76c2a69836ec618c82eb9305656dcec70befb",
    "2f93a09dd10696b6388a0fcb4099341ccef05169",
    "6b62e53b607630b6c00411741972838ced552f4d",
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
    "1a6964c8274c50f0253db75f010d78ef0e739343"
  ],
  "changeHistoryShort": {
    "32798dcfdb00662a640f0ff2915766591d21e287": "Ybodychange",
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": "Ybodychange",
    "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07": "Ybodychange",
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": "Ymultichange(Yparameterchange,Ybodychange)",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "d385a7a5e5cacd875da4301ddeb46a7c56a725fa": "Ybodychange",
    "7edf05530d83d7f8971db4262ea43e11124c6b63": "Ybodychange",
    "4e650c0d76b716c0e9cb3592d30def9e609066c1": "Ymultichange(Yexceptionschange,Ybodychange,Yparametermetachange)",
    "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092": "Ybodychange",
    "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b": "Ybodychange",
    "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38": "Ybodychange",
    "53e39094bf012a4f5b3fe5557219707cb7b0f010": "Ybodychange",
    "f32b8612433e499090c76ded014dd5e94322b786": "Yfilerename",
    "3760e4319b02ce79ff1eeae021fd88faebf739d5": "Ybodychange",
    "dafcb8f6db82b899c917832768f1c240d273190c": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "0f84b86e01da4680633c32bad101d021e0cb98ad": "Ybodychange",
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": "Ybodychange",
    "9952223e0645fd7a8cddc6093a7f449c6390238d": "Ybodychange",
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": "Ybodychange",
    "74333e63b60440be5ff9f591f2203b635e26e3a0": "Yparameterchange",
    "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2": "Ybodychange",
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": "Ybodychange",
    "f67e5602af72b7b2238eb6f6fcdc206a47edabd5": "Ybodychange",
    "8f865bfffed575c3a4db6d7db92dc5f752f97237": "Ybodychange",
    "19037e8cfc2d9534f79e40c898fdaeacaf499e82": "Ybodychange",
    "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839": "Ybodychange",
    "4275c4c1cffeffae6b12eb6aa2df957c23107b48": "Ybodychange",
    "733780e8a158b7bc45b8b687ac353ecadc905a63": "Ybodychange",
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390": "Ybodychange",
    "5664fb3bfb63e4db49dc07d13ace419e810186c2": "Ymultichange(Yparameterchange,Ybodychange)",
    "461b012e9565af8174e5b9d2b2c3a582011ce77e": "Ybodychange",
    "13bcf05a9ea2d4943faef2c879aac65d37517eb6": "Ybodychange",
    "2fbcba41e365752681f635c706d577e605d3336a": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "065a0a8122be356d1f898321763d3518b504b075": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "21f76c2a69836ec618c82eb9305656dcec70befb": "Ybodychange",
    "2f93a09dd10696b6388a0fcb4099341ccef05169": "Ybodychange",
    "6b62e53b607630b6c00411741972838ced552f4d": "Ymultichange(Yparameterchange,Ybodychange)",
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": "Yfilerename",
    "1a6964c8274c50f0253db75f010d78ef0e739343": "Yintroduced"
  },
  "changeHistoryDetails": {
    "32798dcfdb00662a640f0ff2915766591d21e287": {
      "type": "Ybodychange",
      "commitMessage": "Always send refs\u0027 objects despite \"filter\" in pack\n\nIn a0c9016abd (\"upload-pack: send refs\u0027 objects despite \"filter\"\",\n2018-07-09), Git updated the \"filter\" option in the fetch-pack\nupload-pack protocol to not filter objects explicitly specified in\n\"want\" lines, even if they match the criterion of the filter. Update\nJGit to match that behavior.\n\nChange-Id: Ia4d74326edb89e61062e397e05483298c50f9232\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\n",
      "commitDate": "2018/7/21 上午8:09",
      "commitName": "32798dcfdb00662a640f0ff2915766591d21e287",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2018/5/18 下午11:59",
      "commitNameOld": "f3ec7cf3f0436a79e252251a31dbc62694555897",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 63.34,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    excludeFromBitmapSelection \u003d noBitmaps;\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            filterAndAddObject(o, o.getType(), pathHash, want);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            filterAndAddObject(o, o.getType(), walker.getPathHashCode(), want);\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1775,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,175 +1,175 @@\n private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     excludeFromBitmapSelection \u003d noBitmaps;\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-            filterAndAddObject(o, o.getType(), pathHash);\n+            filterAndAddObject(o, o.getType(), pathHash, want);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n-            filterAndAddObject(o, o.getType(), walker.getPathHashCode());\n+            filterAndAddObject(o, o.getType(), walker.getPathHashCode(), want);\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ac32e79b751944107470d5f4cb290eacd1b7cf9": {
      "type": "Ybodychange",
      "commitMessage": "Teach UploadPack to support filtering by blob size\n\nTeach UploadPack to advertise the filter capability and support a\n\"filter\" line in the request, accepting blob sizes only, if the\nconfiguration variable \"uploadpack.allowfilter\" is true. This feature is\ncurrently in the \"master\" branch of Git, and as of the time of writing,\nthis feature is to be released in Git 2.17.\n\nThis is incomplete in that the filter-by-sparse-specification feature\nalso supported by Git is not included in this patch.\n\nIf a JGit server were to be patched with this commit, and a repository\non that server configured with RequestPolicy.ANY or\nRequestPolicy.REACHABLE_COMMIT_TIP, a Git client built from the \"master\"\nbranch would be able to perform a partial clone.\n\nChange-Id: If72b4b422c06ab432137e9e5272d353b14b73259\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\n",
      "commitDate": "2018/3/16 上午4:46",
      "commitName": "4ac32e79b751944107470d5f4cb290eacd1b7cf9",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2018/3/11 上午2:38",
      "commitNameOld": "cc19f649666704e5bf0184d3839be0c0c17439fc",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 5.09,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    excludeFromBitmapSelection \u003d noBitmaps;\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            filterAndAddObject(o, o.getType(), pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            filterAndAddObject(o, o.getType(), walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1775,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,175 +1,175 @@\n private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     excludeFromBitmapSelection \u003d noBitmaps;\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-            addObject(o, pathHash);\n+            filterAndAddObject(o, o.getType(), pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n-            addObject(o, walker.getPathHashCode());\n+            filterAndAddObject(o, o.getType(), walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07": {
      "type": "Ybodychange",
      "commitMessage": "Make PackWriterBitmapWalker public\n\nMake PackWriterBitmapWriter class public and move it to a more central\nlocation, in preparation for its use by another class (in a subsequent\ncommit).\n\nOne of its inner static classes, AddUnseenToBitmapFilter, previously\npackage-private, is also used directly in its former package. Therefore,\nAddUnseenToBitmapFilter and its sibling class have been moved to an\ninternal package instead.\n\nChange-Id: I740bc4bfc4e4e3c857d1ee7d25fe45e90cd22a75\nSigned-off-by: Jonathan Tan \u003cjonathantanmy@google.com\u003e\n",
      "commitDate": "2017/11/11 上午7:41",
      "commitName": "ccf25f95411d7faae7b7aa5a75d74c62e6c47e07",
      "commitAuthor": "Jonathan Tan",
      "commitDateOld": "2017/5/19 上午6:25",
      "commitNameOld": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 176.05,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    excludeFromBitmapSelection \u003d noBitmaps;\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1700,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,175 +1,175 @@\n private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     excludeFromBitmapSelection \u003d noBitmaps;\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n-            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n+            BitmapWalker bitmapWalker \u003d new BitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2017/5/19 上午6:25",
      "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
      "commitAuthor": "Terry Parker",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2017/5/19 上午6:25",
          "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2017/5/4 上午6:02",
          "commitNameOld": "8f7d0a4fbe8862e71d900b0585c97407037ef9a5",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 15.02,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    excludeFromBitmapSelection \u003d noBitmaps;\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 1699,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,174 +1,175 @@\n-private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n+private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n+    excludeFromBitmapSelection \u003d noBitmaps;\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set\u003c? extends ObjectId\u003e(annotations-@NonNull), have-Set\u003c? extends ObjectId\u003e(annotations-@NonNull)]",
            "newValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set\u003c? extends ObjectId\u003e(annotations-@NonNull), have-Set\u003c? extends ObjectId\u003e(annotations-@NonNull), noBitmaps-Set\u003c? extends ObjectId\u003e(annotations-@NonNull)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Exclude refs/tags from bitmap commit selection\n\nCommit db77610 ensured that all refs/tags commits are added to the\nprimary GC pack. It did that by adding all of the refs/tags commits\nto the primary GC pack PackWriter\u0027s \"interesting\" object set.\n\nUnfortunately, all commit objects in the \"interesting\" set are\nselected as commits for which bitmap indices will be built. In a\nrepository like chromium with lots of tags, this changed the number of\nbitmaps created from \u003c700 to \u003e10000. That puts huge memory pressure on\nthe GC task.\n\nThis change restores the original behavior of ignoring tags when\nselecting commits for bitmaps.\n\nIn the \"uninteresting\" set, commits for refs/heads and refs/tags for\nunannotated tags can not be differentiated. We instead identify\nrefs/tags commits by passing their ObjectIds as a new \"noBitmaps\"\nparameter to the PackWriter.preparePack() methods.\nPackWriterBitmapPreparer.setupTipCommitBitmaps() can then use that\n\"noBitmaps\" parameter to exclude those commits.\n\nChange-Id: Icd287c6b04fc1e48de773033fe432a9b0e904ac5\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
          "commitDate": "2017/5/19 上午6:25",
          "commitName": "c46c720e99baa081bff0dd7bcc1ae8ca48b5e3d1",
          "commitAuthor": "Terry Parker",
          "commitDateOld": "2017/5/4 上午6:02",
          "commitNameOld": "8f7d0a4fbe8862e71d900b0585c97407037ef9a5",
          "commitAuthorOld": "Zhen Chen",
          "daysBetweenCommits": 15.02,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    excludeFromBitmapSelection \u003d noBitmaps;\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 1699,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,174 +1,175 @@\n-private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n+private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have, @NonNull Set\u003c? extends ObjectId\u003e noBitmaps) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n+    excludeFromBitmapSelection \u003d noBitmaps;\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/21 上午5:47",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1653,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,174 +1,174 @@\n private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n-    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003c\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n-    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n-    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n-    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n+    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003c\u003e(want.size());\n+    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003c\u003e(haveEst);\n+    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003c\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n-        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n+        all \u003d new ArrayList\u003c\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) {\n             depthWalk.markRoot(obj);\n         }\n         for (RevObject obj : haveObjs) {\n             if (obj instanceof RevCommit) {\n                 RevTree t \u003d ((RevCommit) obj).getTree();\n                 depthWalk.markUninteresting(t);\n             }\n         }\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) {\n                 depthWalk.markUnshallow(walker.parseAny(id));\n             }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n-    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n-    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n+    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003c\u003e();\n+    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003c\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d385a7a5e5cacd875da4301ddeb46a7c56a725fa": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: Respect \"shallow\" lines\n\nWhen fetching from a shallow clone, the client sends \"have\" lines\nto tell the server about objects it already has and \"shallow\" lines\nto tell where its local history terminates. In some circumstances,\nthe server fails to honor the shallow lines and fails to return\nobjects that the client needs.\n\nUploadPack passes the \"have\" lines to PackWriter so PackWriter can\nomit them from the generated pack. UploadPack processes \"shallow\"\nlines by calling RevWalk.assumeShallow() with the set of shallow\ncommits. RevWalk creates and caches RevCommits for these shallow\ncommits, clearing out their parents. That way, walks correctly\nterminate at the shallow commits instead of assuming the client has\nhistory going back behind them. UploadPack converts its RevWalk to an\nObjectWalk, maintaining the cached RevCommits, and passes it to\nPackWriter.\n\nUnfortunately, to support shallow fetches the PackWriter does the\nfollowing:\n\n  if (shallowPack \u0026\u0026 !(walk instanceof DepthWalk.ObjectWalk))\n    walk \u003d new DepthWalk.ObjectWalk(reader, depth);\n\nThat is, when the client sends a \"deepen\" line (fetch --depth\u003d\u003cn\u003e)\nand the caller has not passed in a DepthWalk.ObjectWalk, PackWriter\nthrows away the RevWalk that was passed in and makes a new one. The\ncleared parent lists prepared by RevWalk.assumeShallow() are lost.\nFortunately UploadPack intends to pass in a DepthWalk.ObjectWalk.\nIt tries to create it by calling toObjectWalkWithSameObjects() on\na DepthWalk.RevWalk. But it doesn\u0027t work: because DepthWalk.RevWalk\ndoes not override the standard RevWalk#toObjectWalkWithSameObjects\nimplementation, the result is a plain ObjectWalk instead of an\ninstance of DepthWalk.ObjectWalk.\n\nThe result is that the \"shallow\" information is thrown away and\nobjects reachable from the shallow commits can be omitted from the\npack sent when fetching with --depth from a shallow clone.\n\nMultiple factors collude to limit the circumstances under which this\nbug can be observed:\n\n1. Commits with depth !\u003d 0 don\u0027t enter DepthGenerator\u0027s pending queue.\n   That means a \"have\" cannot have any effect on DepthGenerator unless\n   it is also a \"want\".\n\n2. DepthGenerator#next() doesn\u0027t call carryFlagsImpl(), so the\n   uninteresting flag is not propagated to ancestors there even if a\n   \"have\" is also a \"want\".\n\n3. JGit treats a depth of 1 as \"1 past the wants\".\n\nBecause of (2), the only place the UNINTERESTING flag can leak to a\nshallow commit\u0027s parents is in the carryFlags() call from\nmarkUninteresting(). carryFlags() only traverses commits that have\nalready been parsed: commits yet to be parsed are supposed to inherit\ncorrect flags from their parent in PendingGenerator#next (which\ndoesn\u0027t happen here --- that is (2)). So the list of commits that have\nalready been parsed becomes relevant.\n\nWhen we hit the markUninteresting() call, all \"want\"s, \"have\"s, and\ncommits to be unshallowed have been parsed. carryFlags() only\naffects the parsed commits. If the \"want\" is a direct parent of a\n\"have\", then it carryFlags() marks it as uninteresting. If the \"have\"\nwas also a \"shallow\", then its parent pointer should have been null\nand the \"want\" shouldn\u0027t have been marked, so we see the bug. If the\n\"want\" is a more distant ancestor then (2) keeps the uninteresting\nstate from propagating to the \"want\" and we don\u0027t see the bug. If the\n\"shallow\" is not also a \"have\" then the shallow commit isn\u0027t parsed\nso (2) keeps the uninteresting state from propagating to the \"want\nso we don\u0027t see the bug.\n\nHere is a reproduction case (time flowing left to right, arrows\npointing to parents). \"C\" must be a commit that the client\nreports as a \"have\" during negotiation. That can only happen if the\nserver reports it as an existing branch or tag in the first round of\nnegotiation:\n\n  A \u003c-- B \u003c-- C \u003c-- D\n\nFirst do\n\n  git clone --depth 1 \u003crepo\u003e\n\nwhich yields D as a \"have\" and C as a \"shallow\" commit. Then try\n\n  git fetch --depth 1 \u003crepo\u003e B:refs/heads/B\n\nNegotiation sets up: have D, shallow C, have C, want B.\nBut due to this bug B is marked as uninteresting and is not sent.\n\nChange-Id: I6e14b57b2f85e52d28cdcf356df647870f475440\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2016/8/6 上午6:37",
      "commitName": "d385a7a5e5cacd875da4301ddeb46a7c56a725fa",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2016/8/5 上午8:20",
      "commitNameOld": "7edf05530d83d7f8971db4262ea43e11124c6b63",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1609,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "7edf05530d83d7f8971db4262ea43e11124c6b63": {
      "type": "Ybodychange",
      "commitMessage": "Shallow fetch: avoid sending unneeded blobs\n\nWhen doing an incremental fetch from JGit, \"have\" commits are marked\nas \"uninteresting\". In a non-shallow fetch, when the RevWalk hits an\n\"uninteresting\" commit it marks the commit\u0027s corresponding tree as\nuninteresting. That has the effect of dropping those trees and all the\ntrees and blobs they reference out of the thin pack returned to the\nclient.\n\nHowever, shallow fetches use a DepthWalk to limit the RevWalk, which\nnearly always causes the RevWalk to terminate before encountering the\n\"have\" commits. As a result the pack created for the incremental fetch\nnever encounters \"uninteresting\" tree objects and thus includes\nduplicate objects that it knows the client already has.\n\nChange-Id: I7b1f7c3b0d83e04d34cd2fa676f1ad4fec904c05\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2016/8/5 上午8:20",
      "commitName": "7edf05530d83d7f8971db4262ea43e11124c6b63",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2016/1/13 上午8:30",
      "commitNameOld": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 204.99,
      "commitsBetweenForRepo": 316,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) {\n            depthWalk.markRoot(obj);\n        }\n        for (RevObject obj : haveObjs) {\n            if (obj instanceof RevCommit) {\n                RevTree t \u003d ((RevCommit) obj).getTree();\n                depthWalk.markUninteresting(t);\n            }\n        }\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) {\n                depthWalk.markUnshallow(walker.parseAny(id));\n            }\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1608,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,164 +1,174 @@\n private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n-        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n+        for (RevObject obj : wantObjs) {\n+            depthWalk.markRoot(obj);\n+        }\n+        for (RevObject obj : haveObjs) {\n+            if (obj instanceof RevCommit) {\n+                RevTree t \u003d ((RevCommit) obj).getTree();\n+                depthWalk.markUninteresting(t);\n+            }\n+        }\n         if (unshallowObjects !\u003d null) {\n-            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n+            for (ObjectId id : unshallowObjects) {\n+                depthWalk.markUnshallow(walker.parseAny(id));\n+            }\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e650c0d76b716c0e9cb3592d30def9e609066c1": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Yparametermetachange)",
      "commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
      "commitDate": "2016/1/13 上午8:30",
      "commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
      "commitAuthor": "Shawn Pearce",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
          "commitDate": "2016/1/13 上午8:30",
          "commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
          "commitAuthor": "Shawn Pearce",
          "commitDateOld": "2015/12/30 上午7:32",
          "commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
          "commitAuthorOld": "Shawn Pearce",
          "daysBetweenCommits": 14.04,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 1608,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,166 +1,164 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n-    if (have \u003d\u003d null)\n-        have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
          "commitDate": "2016/1/13 上午8:30",
          "commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
          "commitAuthor": "Shawn Pearce",
          "commitDateOld": "2015/12/30 上午7:32",
          "commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
          "commitAuthorOld": "Shawn Pearce",
          "daysBetweenCommits": 14.04,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 1608,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,166 +1,164 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n-    if (have \u003d\u003d null)\n-        have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "PackWriter: Declare preparePack object sets as @NonNull\n\nRequire callers to pass in valid sets for both want and have\ncollections. Offer PackWriter.NONE as a handy constant for an\nempty collection for the have part of preparePack instead of null.\n\nChange-Id: Ifda4450f5e488cbfefd728382b7d30797e229217\n",
          "commitDate": "2016/1/13 上午8:30",
          "commitName": "4e650c0d76b716c0e9cb3592d30def9e609066c1",
          "commitAuthor": "Shawn Pearce",
          "commitDateOld": "2015/12/30 上午7:32",
          "commitNameOld": "29aa444760ea729dd10cdb0468055282a59096e5",
          "commitAuthorOld": "Shawn Pearce",
          "daysBetweenCommits": 14.04,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
          "functionStartLine": 1608,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,166 +1,164 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(@NonNull ProgressMonitor countingMonitor, @NonNull ObjectWalk walker, @NonNull Set\u003c? extends ObjectId\u003e want, @NonNull Set\u003c? extends ObjectId\u003e have) throws IOException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n-    if (have \u003d\u003d null)\n-        have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         if (c.getParentCount() \u003d\u003d 0) {\n             roots.add(c.copy());\n         }\n         countingMonitor.update(1);\n     }\n     stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Set\u003c? extends ObjectId\u003e(modifiers-final), have-Set\u003c? extends ObjectId\u003e]",
            "newValue": "[countingMonitor-ProgressMonitor(annotations-@NonNull), walker-ObjectWalk(annotations-@NonNull), want-Set\u003c? extends ObjectId\u003e(annotations-@NonNull), have-Set\u003c? extends ObjectId\u003e(annotations-@NonNull)]"
          }
        }
      ]
    },
    "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092": {
      "type": "Ybodychange",
      "commitMessage": "Expose the set of root commits in PackStatistics\n\nRoot commits are commits with zero parents.  If a commmit has no\nparents it is the first commit in the repository.  In general the root\ncommits should be unique for any given project, as the first commit\nwill be created at a different time, by a different user with its own\nmessage.  These root commits can be used as a \"fingerprint\" to\nidentify disjoint histories.\n\nChange-Id: Id891dbc1f17c816cea404569578bb7635ff85cdb\n",
      "commitDate": "2015/8/17 上午5:10",
      "commitName": "1d7d0f95e0be8121ee16640fa1cd3b0805fd9092",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2015/8/15 上午2:13",
      "commitNameOld": "f9bd6c1239b9e66bfd74e5a2462621a5f5fa641c",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        if (c.getParentCount() \u003d\u003d 0) {\n            roots.add(c.copy());\n        }\n        countingMonitor.update(1);\n    }\n    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1610,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,161 +1,166 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n+    Set\u003cObjectId\u003e roots \u003d new HashSet\u003c\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n+        if (c.getParentCount() \u003d\u003d 0) {\n+            roots.add(c.copy());\n+        }\n         countingMonitor.update(1);\n     }\n+    stats.rootCommits \u003d Collections.unmodifiableSet(roots);\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n     stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b": {
      "type": "Ybodychange",
      "commitMessage": "Update PackWriter.Statistics.getBitmapIndexMises()\n\nReturn -1 from PackWriter.Statistics.getBitmapIndexMises() when no\nbitmap indices were found, to differentiate it from the case where\nthe bitmap indices contained all of the want/have commits.\n\nChange-Id: I78d4600b462c19f62b347217a0b2c19eaaf3a14b\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e",
      "commitDate": "2015/6/3 上午10:49",
      "commitName": "dd22bc831a0ec47ecc999eb19be1bd8fad899e9b",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/5/27 上午5:37",
      "commitNameOld": "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
      "commitAuthorOld": "Terry Parker",
      "daysBetweenCommits": 7.22,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n    stats.bitmapIndexMisses \u003d -1;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1568,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,160 +1,161 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n+    stats.bitmapIndexMisses \u003d -1;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38": {
      "type": "Ybodychange",
      "commitMessage": "Add bitmap index misses to PackWriter.Statistics\n\nRevWalks to find commits that are not in bitmap indices are expensive.\nTrack the count of commits that are enumerated via RevWalks as \"bitmap\nindex misses\" in the PackWriter.Statistics class.\n\nChange-Id: Ie0135a0a0aeba2dfb6df78839d545006629f16cb\nSigned-off-by: Terry Parker \u003ctparker@google.com\u003e\n",
      "commitDate": "2015/5/27 上午5:37",
      "commitName": "0e8ac496cd9bbfa3fa306ac45706f501fc24ac38",
      "commitAuthor": "Terry Parker",
      "commitDateOld": "2015/5/21 上午8:05",
      "commitNameOld": "686124bec32fcdee1545e7d9c312dcf0276b44af",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 5.9,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1568,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,159 +1,160 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n+            stats.bitmapIndexMisses \u003d bitmapWalker.getCountOfBitmapIndexMisses();\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53e39094bf012a4f5b3fe5557219707cb7b0f010": {
      "type": "Ybodychange",
      "commitMessage": "ObjectWalk: make setRetainBody(false) the default\n\nDespite being the primary author of RevWalk and ObjectWalk I still\nfail to remember to setRetainBody(false) in application code using\nan ObjectWalk to examine the graph.\n\nDocument the default for RevWalk is setRetainBody(true), where the\napplication usually wants the commit bodies to display or inspect.\n\nChange the default for ObjectWalk to setRetainBody(false), as nearly\nall callers want only the graph shape and do not need the larger text\ninside a commit body. This allows some code in JGit to be simplified.\n\nChange-Id: I367e42209e805bd5e1f41b4072aeb2fa98ec9d99\n",
      "commitDate": "2015/5/11 上午1:45",
      "commitName": "53e39094bf012a4f5b3fe5557219707cb7b0f010",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2015/4/25 上午6:51",
      "commitNameOld": "10412ddfedfe80537ffa497c7960443d703ee129",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 15.79,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1576,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,160 +1,159 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n-    walker.setRetainBody(false);\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f32b8612433e499090c76ded014dd5e94322b786": {
      "type": "Yfilerename",
      "commitMessage": "JGit 3.0: move internal classes into an internal subpackage\n\nThis breaks all existing callers once. Applications are not supposed\nto build against the internal storage API unless they can accept API\nchurn and make necessary updates as versions change.\n\nChange-Id: I2ab1327c202ef2003565e1b0770a583970e432e9\n",
      "commitDate": "2013/3/19 上午12:30",
      "commitName": "f32b8612433e499090c76ded014dd5e94322b786",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/3/18 下午10:35",
      "commitNameOld": "462bbc052e766ee9ea585cd4366165a8dac86496",
      "commitAuthorOld": "Shawn Pearce",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java",
      "functionStartLine": 1597,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
        "newPath": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/pack/PackWriter.java"
      }
    },
    "3760e4319b02ce79ff1eeae021fd88faebf739d5": {
      "type": "Ybodychange",
      "commitMessage": "Remove cached_packs support in favor of bitmaps\n\nThe bitmap code in PackWriter knows exactly when to use a pack as\na \"cached pack\". It enables cached pack usage only when the pack\nhas a bitmap and its entire closure of objects needs to be sent.\nThis is a much simpler code path to maintain, and JGit actually\nhas a way to write the necessary index.\n\nChange-Id: I2645d482f8733fdf0c4120cc59ba9aa4d4ba6881\n",
      "commitDate": "2013/3/15 上午7:36",
      "commitName": "3760e4319b02ce79ff1eeae021fd88faebf739d5",
      "commitAuthor": "Shawn Pearce",
      "commitDateOld": "2013/3/6 上午3:15",
      "commitNameOld": "f82821728b60901932292bab6dd3e0a642301e02",
      "commitAuthorOld": "Colby Ranger",
      "daysBetweenCommits": 9.18,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1596,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,198 +1,160 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     walker.setRetainBody(false);\n     canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n     if (!shallowPack \u0026\u0026 useBitmaps) {\n         BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n         if (bitmapIndex !\u003d null) {\n             PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n             findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n             endPhase(countingMonitor);\n             stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n             return;\n         }\n     }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n-    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n-    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n-    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n-    keepOnRestart.add(inCachedPack);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n-        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n-            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n-            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n-            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n-                if (need.containsAll(pack.getTips())) {\n-                    need.removeAll(pack.getTips());\n-                    shortCircuit.add(pack);\n-                }\n-                for (ObjectId id : pack.getTips()) {\n-                    tipToPack.put(id, pack);\n-                    all.add(id);\n-                }\n-            }\n-            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n-                cachedPacks.addAll(shortCircuit);\n-                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n-                endPhase(countingMonitor);\n-                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n-                return;\n-            }\n-            haveEst +\u003d tipToPack.size();\n-        }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n-                if (tipToPack.containsKey(o))\n-                    o.add(inCachedPack);\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n-        if (c.has(inCachedPack)) {\n-            CachedPack pack \u003d tipToPack.get(c);\n-            if (includesAllTips(pack, include, walker)) {\n-                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n-                commits \u003d new BlockList\u003cRevCommit\u003e();\n-                endPhase(countingMonitor);\n-                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n-                continue;\n-            }\n-        }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dafcb8f6db82b899c917832768f1c240d273190c": {
      "type": "Ybodychange",
      "commitMessage": "Support creating pack bitmap indexes in PackWriter.\n\nUpdate the PackWriter to support writing out pack bitmap indexes,\na parallel \".bitmap\" file to the \".pack\" file.\nBitmaps are selected at commits every 1 to 5,000 commits for\neach unique path from the start. The most recent 100 commits are\nall bitmapped. The next 19,000 commits have a bitmaps every 100\ncommits. The remaining commits have a bitmap every 5,000 commits.\nCommits with more than 1 parent are prefered over ones\nwith 1 or less. Furthermore, previously computed bitmaps are reused,\nif the previous entry had the reuse flag set, which is set when the\nbitmap was placed at the max allowed distance.\n\nBitmaps are used to speed up the counting phase when packing, for\nrequests that are not shallow. The PackWriterBitmapWalker uses\na RevFilter to proactively mark commits with RevFlag.SEEN, when\nthey appear in a bitmap. The walker produces the full closure\nof reachable ObjectIds, given the collection of starting ObjectIds.\n\nFor fetch request, two ObjectWalks are executed to compute the\nObjectIds reachable from the haves and from the wants. The\nObjectIds needed to be written are determined by taking all the\nresulting wants AND NOT the haves.\n\nFor clone requests, we get cached pack support for \"free\" since\nit is possible to determine if all of the ObjectIds in a pack file\nare included in the resulting list of ObjectIds to write.\n\nOn my machine, the best times for clones and fetches of the linux\nkernel repository (with about 2.6M objects and 300K commits) are\ntabulated below:\n\nOperation                   Index V2               Index VE003\nClone                       37530ms (524.06 MiB)     82ms (524.06 MiB)\nFetch (1 commit back)          75ms                 107ms\nFetch (10 commits back)       456ms (269.51 KiB)    341ms (265.19 KiB)\nFetch (100 commits back)      449ms (269.91 KiB)    337ms (267.28 KiB)\nFetch (1000 commits back)    2229ms ( 14.75 MiB)    189ms ( 14.42 MiB)\nFetch (10000 commits back)   2177ms ( 16.30 MiB)    254ms ( 15.88 MiB)\nFetch (100000 commits back) 14340ms (185.83 MiB)   1655ms (189.39 MiB)\n\nChange-Id: Icdb0cdd66ff168917fb9ef17b96093990cc6a98d\n",
      "commitDate": "2013/3/6 上午3:14",
      "commitName": "dafcb8f6db82b899c917832768f1c240d273190c",
      "commitAuthor": "Colby Ranger",
      "commitDateOld": "2013/3/5 上午6:43",
      "commitNameOld": "be7a135e94d9c71da3e9cd28edfd10ba7be3747d",
      "commitAuthorOld": "Colby Ranger",
      "daysBetweenCommits": 0.86,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    walker.setRetainBody(false);\n    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n    if (!shallowPack \u0026\u0026 useBitmaps) {\n        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n        if (bitmapIndex !\u003d null) {\n            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n            endPhase(countingMonitor);\n            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n            return;\n        }\n    }\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1598,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,187 +1,198 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n+    walker.setRetainBody(false);\n+    canBuildBitmaps \u003d config.isBuildBitmaps() \u0026\u0026 !shallowPack \u0026\u0026 have.isEmpty() \u0026\u0026 (excludeInPacks \u003d\u003d null || excludeInPacks.length \u003d\u003d 0);\n+    if (!shallowPack \u0026\u0026 useBitmaps) {\n+        BitmapIndex bitmapIndex \u003d reader.getBitmapIndex();\n+        if (bitmapIndex !\u003d null) {\n+            PackWriterBitmapWalker bitmapWalker \u003d new PackWriterBitmapWalker(walker, bitmapIndex, countingMonitor);\n+            findObjectsToPackUsingBitmaps(bitmapWalker, want, have);\n+            endPhase(countingMonitor);\n+            stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n+            return;\n+        }\n+    }\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n-    walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 endPhase(countingMonitor);\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 endPhase(countingMonitor);\n                 beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012/12/27 下午11:57",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/8/14 上午5:29",
      "commitNameOld": "b77ba049762e4ea3aadb756dad1d06c859bb3fe3",
      "commitAuthorOld": "Colby Ranger",
      "daysBetweenCommits": 135.77,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1488,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "0f84b86e01da4680633c32bad101d021e0cb98ad": {
      "type": "Ybodychange",
      "commitMessage": "fix PackWriter excluded objects handling\n\nPackWriter supports excluding objects from being written to the pack.\nYou may specify a PackIndex which lists all those objects which should\nnot go into the new pack. This feature was broken because not all\ncommits have been checked whether they should be excluded or not. For\nother object types the exclude algorithm worked. This commit adds the\nmissing check.\n\nChange-Id: Id0047098393641ccba784c58b8325175c22fcece\nSigned-off-by: Christian Halstrick \u003cchristian.halstrick@sap.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/6/4 下午10:52",
      "commitName": "0f84b86e01da4680633c32bad101d021e0cb98ad",
      "commitAuthor": "Christian Halstrick",
      "commitDateOld": "2012/5/9 下午12:42",
      "commitNameOld": "17fb542e9eaca9dffc4c84a6d23608dadb4b1ea1",
      "commitAuthorOld": "Kevin Sawicki",
      "daysBetweenCommits": 26.42,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1488,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,187 +1,187 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 endPhase(countingMonitor);\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 endPhase(countingMonitor);\n                 beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n-                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n+                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING) \u0026\u0026 !exclude(p)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1": {
      "type": "Ybodychange",
      "commitMessage": "Add an object encapsulating the state of a PackWriter\n\nExposes essentially the same state machine to the programmer as is\nexposed to the client via a ProgressMonitor, using a wrapper around\nbeginTask()/endTask().\n\nChange-Id: Ic3622b4acea65d2b9b3551c668806981fa7293e3\n",
      "commitDate": "2011/11/15 上午2:27",
      "commitName": "16b8ebf2d1d099ac355767b1b1853ae7bf8854f1",
      "commitAuthor": "Dave Borowitz",
      "commitDateOld": "2011/9/15 上午6:34",
      "commitNameOld": "1b6a549ff350673402f797fe7f878175e2b5ba30",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 60.83,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                endPhase(countingMonitor);\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                endPhase(countingMonitor);\n                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    endPhase(countingMonitor);\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1436,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,187 +1,187 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n-    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n-                countingMonitor.endTask();\n+                endPhase(countingMonitor);\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o))\n                     haveObjs.add(o);\n                 if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     if (walker instanceof DepthWalk.ObjectWalk) {\n         DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n         for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n         if (unshallowObjects !\u003d null) {\n             for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n         }\n     } else {\n         for (RevObject obj : wantObjs) walker.markStart(obj);\n     }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n-                countingMonitor.endTask();\n-                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+                endPhase(countingMonitor);\n+                beginPhase(PackingPhase.COUNTING, countingMonitor, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (shallowPack) {\n         for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n         }\n     } else {\n         int commitCnt \u003d 0;\n         boolean putTagTargets \u003d false;\n         for (RevCommit cmit : commits) {\n             if (!cmit.has(added)) {\n                 cmit.add(added);\n                 addObject(cmit, 0);\n                 commitCnt++;\n             }\n             for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                 RevCommit p \u003d cmit.getParent(i);\n                 if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                     p.add(added);\n                     addObject(p, 0);\n                     commitCnt++;\n                 }\n             }\n             if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                 for (ObjectId id : tagTargets) {\n                     RevObject obj \u003d walker.lookupOrNull(id);\n                     if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                         obj.add(added);\n                         addObject(obj, 0);\n                     }\n                 }\n                 putTagTargets \u003d true;\n             }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n-    countingMonitor.endTask();\n+    endPhase(countingMonitor);\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9952223e0645fd7a8cddc6093a7f449c6390238d": {
      "type": "Ybodychange",
      "commitMessage": "Implement server support for shallow clones\n\nThis implements the server side of shallow clones only (i.e.\ngit-upload-pack), not the client side.\n\nCQ: 5517\nBug: 301627\nChange-Id: Ied5f501f9c8d1fe90ab2ba44fac5fa67ed0035a4\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/8/22 上午5:04",
      "commitName": "9952223e0645fd7a8cddc6093a7f449c6390238d",
      "commitAuthor": "Matt Fischer",
      "commitDateOld": "2011/8/22 上午4:59",
      "commitNameOld": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o))\n                    haveObjs.add(o);\n                if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    if (walker instanceof DepthWalk.ObjectWalk) {\n        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n        if (unshallowObjects !\u003d null) {\n            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n        }\n    } else {\n        for (RevObject obj : wantObjs) walker.markStart(obj);\n    }\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (shallowPack) {\n        for (RevCommit cmit : commits) {\n            addObject(cmit, 0);\n        }\n    } else {\n        int commitCnt \u003d 0;\n        boolean putTagTargets \u003d false;\n        for (RevCommit cmit : commits) {\n            if (!cmit.has(added)) {\n                cmit.add(added);\n                addObject(cmit, 0);\n                commitCnt++;\n            }\n            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n                RevCommit p \u003d cmit.getParent(i);\n                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                    p.add(added);\n                    addObject(p, 0);\n                    commitCnt++;\n                }\n            }\n            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n                for (ObjectId id : tagTargets) {\n                    RevObject obj \u003d walker.lookupOrNull(id);\n                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                        obj.add(added);\n                        addObject(obj, 0);\n                    }\n                }\n                putTagTargets \u003d true;\n            }\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1394,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,173 +1,187 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n-                if (have.contains(o)) {\n+                if (have.contains(o))\n                     haveObjs.add(o);\n-                } else if (want.contains(o)) {\n+                if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n-    for (RevObject obj : wantObjs) walker.markStart(obj);\n+    if (walker instanceof DepthWalk.ObjectWalk) {\n+        DepthWalk.ObjectWalk depthWalk \u003d (DepthWalk.ObjectWalk) walker;\n+        for (RevObject obj : wantObjs) depthWalk.markRoot(obj);\n+        if (unshallowObjects !\u003d null) {\n+            for (ObjectId id : unshallowObjects) depthWalk.markUnshallow(walker.parseAny(id));\n+        }\n+    } else {\n+        for (RevObject obj : wantObjs) walker.markStart(obj);\n+    }\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (exclude(c))\n             continue;\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n-    int commitCnt \u003d 0;\n-    boolean putTagTargets \u003d false;\n-    for (RevCommit cmit : commits) {\n-        if (!cmit.has(added)) {\n-            cmit.add(added);\n+    if (shallowPack) {\n+        for (RevCommit cmit : commits) {\n             addObject(cmit, 0);\n-            commitCnt++;\n         }\n-        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n-            RevCommit p \u003d cmit.getParent(i);\n-            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n-                p.add(added);\n-                addObject(p, 0);\n+    } else {\n+        int commitCnt \u003d 0;\n+        boolean putTagTargets \u003d false;\n+        for (RevCommit cmit : commits) {\n+            if (!cmit.has(added)) {\n+                cmit.add(added);\n+                addObject(cmit, 0);\n                 commitCnt++;\n             }\n-        }\n-        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n-            for (ObjectId id : tagTargets) {\n-                RevObject obj \u003d walker.lookupOrNull(id);\n-                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n-                    obj.add(added);\n-                    addObject(obj, 0);\n+            for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n+                RevCommit p \u003d cmit.getParent(i);\n+                if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n+                    p.add(added);\n+                    addObject(p, 0);\n+                    commitCnt++;\n                 }\n             }\n-            putTagTargets \u003d true;\n+            if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n+                for (ObjectId id : tagTargets) {\n+                    RevObject obj \u003d walker.lookupOrNull(id);\n+                    if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n+                        obj.add(added);\n+                        addObject(obj, 0);\n+                    }\n+                }\n+                putTagTargets \u003d true;\n+            }\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             if (exclude(o))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: support excluding objects already in other packs\n\nThis can be useful when implementing garbage collection and there\nare packs that should not be copied, such as huge packs that have\na sibling \".keep\" file alongside of them.\n\nCallers driving PackWriter need to initialize the list of packs not\nto include objects from by passing each index to excludeObjects().\n\nChange-Id: Id7f34df69df97be406bcae184308e92b0e8690fd\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/8/22 上午4:59",
      "commitName": "a1a8c6d77ec5bea13c4f5ca428e425d95e14e003",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/8/17 上午3:18",
      "commitNameOld": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (exclude(c))\n            continue;\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            if (exclude(o))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1365,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,167 +1,173 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n+        if (exclude(c))\n+            continue;\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     int commitCnt \u003d 0;\n     boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n             commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n                 commitCnt++;\n             }\n         }\n         if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n             for (ObjectId id : tagTargets) {\n                 RevObject obj \u003d walker.lookupOrNull(id);\n                 if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                     obj.add(added);\n                     addObject(obj, 0);\n                 }\n             }\n             putTagTargets \u003d true;\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n+            if (exclude(o))\n+                continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n+            if (exclude(o))\n+                continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74333e63b60440be5ff9f591f2203b635e26e3a0": {
      "type": "Yparameterchange",
      "commitMessage": "PackWriter: Make want/have actual sets\n\nDuring parsing these are used with contains(). If they are a List\ntype, the contains operation is not efficient. Some callers such\nas UploadPack often pass a List here, so convert to Set when the\ntype isn\u0027t efficient for contains().\n\nChange-Id: If948ae3bf1f46e756bd2d5db14795e12ba7a6207\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/8/17 上午3:18",
      "commitName": "74333e63b60440be5ff9f591f2203b635e26e3a0",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/8/14 上午8:01",
      "commitNameOld": "2610eaf386f37386e9886a8635d499ebf772a240",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1338,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,167 +1,167 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Set\u003c? extends ObjectId\u003e want, Set\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     int commitCnt \u003d 0;\n     boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n             commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n                 commitCnt++;\n             }\n         }\n         if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n             for (ObjectId id : tagTargets) {\n                 RevObject obj \u003d walker.lookupOrNull(id);\n                 if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                     obj.add(added);\n                     addObject(obj, 0);\n                 }\n             }\n             putTagTargets \u003d true;\n         }\n     }\n     commits \u003d null;\n     if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n         BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             int pathHash \u003d walker.getPathHashCode();\n             byte[] pathBuf \u003d walker.getPathBuffer();\n             int pathLen \u003d walker.getPathLength();\n             bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n             addObject(o, pathHash);\n             countingMonitor.update(1);\n         }\n     } else {\n         RevObject o;\n         while ((o \u003d walker.nextObject()) !\u003d null) {\n             if (o.has(RevFlag.UNINTERESTING))\n                 continue;\n             addObject(o, walker.getPathHashCode());\n             countingMonitor.update(1);\n         }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Collection\u003c? extends ObjectId\u003e(modifiers-final), have-Collection\u003c? extends ObjectId\u003e]",
        "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Set\u003c? extends ObjectId\u003e(modifiers-final), have-Set\u003c? extends ObjectId\u003e]"
      }
    },
    "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Only search for base objects on thin packs\n\nA non-thin pack does not need to worry about preferred bases, the pack\nwill be self-contained and all required delta base objects will appear\nwithin the pack itself. Obtaining the path buffer and length from the\nObjectWalk to build the preferred base table is \"expensive\", so avoid\nthe cost unless a thin pack is being constructed.\n\nChange-Id: I16e30cd864f4189d4304e7957a7cd5bdb9e84528\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/8/9 上午6:10",
      "commitName": "99e6cfb131bb407247acbc8c0a73e7c7cf37ebc2",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/7/29 上午1:22",
      "commitNameOld": "68cc21b60d83b5c4fb1de6c34a79836c51dd9b3b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 11.2,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            int pathHash \u003d walker.getPathHashCode();\n            byte[] pathBuf \u003d walker.getPathBuffer();\n            int pathLen \u003d walker.getPathLength();\n            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n            addObject(o, pathHash);\n            countingMonitor.update(1);\n        }\n    } else {\n        RevObject o;\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            if (o.has(RevFlag.UNINTERESTING))\n                continue;\n            addObject(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1258,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,157 +1,167 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     int commitCnt \u003d 0;\n     boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n             commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n                 commitCnt++;\n             }\n         }\n         if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n             for (ObjectId id : tagTargets) {\n                 RevObject obj \u003d walker.lookupOrNull(id);\n                 if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                     obj.add(added);\n                     addObject(obj, 0);\n                 }\n             }\n             putTagTargets \u003d true;\n         }\n     }\n     commits \u003d null;\n-    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n-    RevObject o;\n-    while ((o \u003d walker.nextObject()) !\u003d null) {\n-        if (o.has(RevFlag.UNINTERESTING))\n-            continue;\n-        int pathHash \u003d walker.getPathHashCode();\n-        byte[] pathBuf \u003d walker.getPathBuffer();\n-        int pathLen \u003d walker.getPathLength();\n-        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n-        addObject(o, pathHash);\n-        countingMonitor.update(1);\n+    if (thin \u0026\u0026 !baseTrees.isEmpty()) {\n+        BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n+        RevObject o;\n+        while ((o \u003d walker.nextObject()) !\u003d null) {\n+            if (o.has(RevFlag.UNINTERESTING))\n+                continue;\n+            int pathHash \u003d walker.getPathHashCode();\n+            byte[] pathBuf \u003d walker.getPathBuffer();\n+            int pathLen \u003d walker.getPathLength();\n+            bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n+            addObject(o, pathHash);\n+            countingMonitor.update(1);\n+        }\n+    } else {\n+        RevObject o;\n+        while ((o \u003d walker.nextObject()) !\u003d null) {\n+            if (o.has(RevFlag.UNINTERESTING))\n+                continue;\n+            addObject(o, walker.getPathHashCode());\n+            countingMonitor.update(1);\n+        }\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Speed up pruning of objects from cached packs\n\nDuring object enumeration for the thin pack, very few objects come\nout that are duplicated with the cached pack. Typically these are\nonly cases where a blob or tree was cherry-picked forward, got a\ncopy or rename, or was reverted... all relatively infrequent events.\n\nSpeed up pruning of the thin pack object list by combining the phase\nwith the object representation selection. Implementers should already\nbe offering to reuse the object from the cached pack if it is stored\nthere, at which point the implementation can perform a very fast type\nof containment test using the cached pack\u0027s identity rather than yet\nanother index lookup.  For the local disk case this is probably not a\nbig improvement, but it does help on the DHT implementation where the\ntwo passes combined into one reduces latency.\n\nChange-Id: I6a07fc75d9075bf6233e967360b6546f9e9a2b33\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/4/2 上午5:40",
      "commitName": "9f5bbb5dd41f87d6428eb49c021e00d8099d0c17",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/19 上午2:31",
      "commitNameOld": "bb1956e647d2f48ef36ef98a7f22120fdad0b37c",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 14.13,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1208,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,157 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n-    int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     int commitCnt \u003d 0;\n     boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n             commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n                 commitCnt++;\n             }\n         }\n         if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n             for (ObjectId id : tagTargets) {\n                 RevObject obj \u003d walker.lookupOrNull(id);\n                 if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                     obj.add(added);\n                     addObject(obj, 0);\n                 }\n             }\n             putTagTargets \u003d true;\n         }\n     }\n     commits \u003d null;\n-    for (CachedPack p : cachedPacks) {\n-        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n-            if (baseTrees.size() \u003c\u003d maxBases)\n-                baseTrees.add(walker.lookupCommit(d).getTree());\n-            objectsMap.get(d).setEdge();\n-            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n-        }\n-    }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n-    for (CachedPack p : cachedPacks) {\n-        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n-            objectsMap.get(d).setEdge();\n-            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n-        }\n-        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n-            objectsMap.get(d).setEdge();\n-            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n-        }\n-        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n-            objectsMap.get(d).setEdge();\n-            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n-        }\n-    }\n-    if (typesToPrune !\u003d 0) {\n-        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n-        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n-        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n-        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n-    }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f67e5602af72b7b2238eb6f6fcdc206a47edabd5": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Reduce GC during enumeration\n\nInstead of resizing an ArrayList until all objects have been added,\nappend objects into a specialized List type that uses small arrays\nof 1024 entries for each 1024 objects added.\n\nFor a large repository like linux-2.6, PackWriter will now allocate\n1,758 smaller arrays to hold the object list, without creating any\ngarbage from the intermediate states due to list expansion.\n\n1024 was chosen as the block size (and initial directory size) as this\nis a reasonable balance for the PackWriter code.  Each block uses\napproximately 4096 bytes in a 32 bit JVM, as does the default top\nlevel block directory.  The top level directory doesn\u0027t expand until 1\nmillion items have been added to the list, which for linux-2.6 won\u0027t\nyet occur as the lists are per-object-type and are thus bounded to\nabout 1/3 of 1.8 million.\n\nChange-Id: If9e4092eb502394c5d3d044b58cf49952772f6d6\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/3/8 上午10:23",
      "commitName": "f67e5602af72b7b2238eb6f6fcdc206a47edabd5",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/3/3 上午4:49",
      "commitNameOld": "a468cb57c2f2fbd8da163f002b505255ea768244",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 5.23,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new BlockList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1178,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,190 +1,186 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n-    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n+    BlockList\u003cRevCommit\u003e commits \u003d new BlockList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n-                commits \u003d new ArrayList\u003cRevCommit\u003e();\n+                commits \u003d new BlockList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n-    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n-        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n-        list.ensureCapacity(list.size() + commits.size());\n-    }\n     int commitCnt \u003d 0;\n     boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n             commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n                 commitCnt++;\n             }\n         }\n         if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n             for (ObjectId id : tagTargets) {\n                 RevObject obj \u003d walker.lookupOrNull(id);\n                 if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                     obj.add(added);\n                     addObject(obj, 0);\n                 }\n             }\n             putTagTargets \u003d true;\n         }\n     }\n     commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f865bfffed575c3a4db6d7db92dc5f752f97237": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Hoist and cluster reference targets\n\nMany source browsers and network related tools like UploadPack need\nto find and parse the target of all branches and annotated tags\nwithin the repository during their startup phase.  Clustering these\ntogether into the same part of the pack file will improve locality,\nreducing thrashing when an application starts and needs to load\nall of these into memory at once.\n\nTo prevent bottlenecking basic log viewing tools that are scannning\nbackwards from the tip of a current branch (and don\u0027t need tags)\nwe place this cluster of older targets after 4096 newer commits\nhave already been placed into the pack stream.  4096 was chosen as\na rough guess, but was based on a few factors:\n\n  - log viewers typically show 5-200 commits per page\n  - users only view the first page or two\n\n  - DHT can cram 2200-4000 commits per 1 MiB chunk\n    thus these will fall into the second commit chunk (roughly)\n\nUnfortunately this placement hurts history tools that are scanning\nbackwards through the commit graph and completely ignored tags or\nbranch heads when they started.\n\nAn ancient tagged commit is no longer positioned behind its first\nchild (its now much earlier), resulting in a page fault for the\nparser to reload this cluster of objects on demand.  This may be\nan acceptable loss.  If a user is walking backwards and has already\nscanned through more than 4096 commits of history, waiting for the\nregion to reload isn\u0027t really that bad compared to the amount of\ntime already spent.\n\nIf the repository is so small that there are less than 4096 commits,\nthis change has no impact on the placement of objects.\n\nChange-Id: If3052e430d305e17878d94145c93754f56b74c61\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/19 上午10:15",
      "commitName": "8f865bfffed575c3a4db6d7db92dc5f752f97237",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/19 上午10:15",
      "commitNameOld": "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    int commitCnt \u003d 0;\n    boolean putTagTargets \u003d false;\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n            commitCnt++;\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n                commitCnt++;\n            }\n        }\n        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n            for (ObjectId id : tagTargets) {\n                RevObject obj \u003d walker.lookupOrNull(id);\n                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n                    obj.add(added);\n                    addObject(obj, 0);\n                }\n            }\n            putTagTargets \u003d true;\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1119,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,176 +1,190 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     if (o instanceof RevTag)\n                         wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     if (!wantTags.isEmpty()) {\n         all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n         for (RevTag tag : wantTags) all.add(tag.getObject());\n         q \u003d walker.parseAny(all, true);\n         try {\n             while (q.next() !\u003d null) {\n             }\n         } finally {\n             q.release();\n         }\n     }\n     for (RevObject obj : wantObjs) walker.markStart(obj);\n     for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new ArrayList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n         ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n         list.ensureCapacity(list.size() + commits.size());\n     }\n+    int commitCnt \u003d 0;\n+    boolean putTagTargets \u003d false;\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n+            commitCnt++;\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n+                commitCnt++;\n             }\n         }\n+        if (!putTagTargets \u0026\u0026 4096 \u003c commitCnt) {\n+            for (ObjectId id : tagTargets) {\n+                RevObject obj \u003d walker.lookupOrNull(id);\n+                if (obj instanceof RevCommit \u0026\u0026 obj.has(include) \u0026\u0026 !obj.has(RevFlag.UNINTERESTING) \u0026\u0026 !obj.has(added)) {\n+                    obj.add(added);\n+                    addObject(obj, 0);\n+                }\n+            }\n+            putTagTargets \u003d true;\n+        }\n     }\n     commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "19037e8cfc2d9534f79e40c898fdaeacaf499e82": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Parse tag target objects in a batch\n\nIf the underlying storage has a high latency per SHA-1 lookup\n(e.g. the DHT support we are working on), parsing each wanted\nannotated tag object back to its underlying commit is too slow,\nits a sequential lookup for each tag.  With hundreds of tags in\na repository this takes far too long.\n\nInstead queue up a list of the tags whose objects need to be found,\nand then locate all of those in one parseAny batch.  This works\nfor the common case of annotated tag to single tree or commit.\nFor the less often used tag-\u003etag-\u003ecommit, it at least gets us\none level parsed in the larger batch before we have to go back to\nsequential lookups.\n\nChange-Id: I94beef3f14281406f15c8cf9fa02d83faf102a19\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/19 上午10:15",
      "commitName": "19037e8cfc2d9534f79e40c898fdaeacaf499e82",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/19 上午9:36",
      "commitNameOld": "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    if (o instanceof RevTag)\n                        wantTags.add((RevTag) o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    if (!wantTags.isEmpty()) {\n        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n        for (RevTag tag : wantTags) all.add(tag.getObject());\n        q \u003d walker.parseAny(all, true);\n        try {\n            while (q.next() !\u003d null) {\n            }\n        } finally {\n            q.release();\n        }\n    }\n    for (RevObject obj : wantObjs) walker.markStart(obj);\n    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1101,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,162 +1,176 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n             List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 if (need.containsAll(pack.getTips())) {\n                     need.removeAll(pack.getTips());\n                     shortCircuit.add(pack);\n                 }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                 cachedPacks.addAll(shortCircuit);\n                 for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                 countingMonitor.endTask();\n                 stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                 return;\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n+    List\u003cRevTag\u003e wantTags \u003d new ArrayList\u003cRevTag\u003e(want.size());\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n-                    walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n-                    walker.markStart(o);\n+                    if (o instanceof RevTag)\n+                        wantTags.add((RevTag) o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n+    if (!wantTags.isEmpty()) {\n+        all \u003d new ArrayList\u003cObjectId\u003e(wantTags.size());\n+        for (RevTag tag : wantTags) all.add(tag.getObject());\n+        q \u003d walker.parseAny(all, true);\n+        try {\n+            while (q.next() !\u003d null) {\n+            }\n+        } finally {\n+            q.release();\n+        }\n+    }\n+    for (RevObject obj : wantObjs) walker.markStart(obj);\n+    for (RevObject obj : haveObjs) walker.markUninteresting(obj);\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new ArrayList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n         ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n         list.ensureCapacity(list.size() + commits.size());\n     }\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n             }\n         }\n     }\n     commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Short-circuit counting on full cached pack reuse\n\nIf one or more cached packs fully covers the request, don\u0027t bother\nwith looking up the objects and trying to walk the graph.  Just use\nthe cached packs and return immediately.\n\nThis helps clones of quiet repositories that have not been modified\nsince their last repack, its likely the cached packs are accurate\nand no graph walking is required.\n\nChange-Id: I9062a5ac2f71b525322590209664a84051fd5f8a\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/19 上午9:36",
      "commitName": "3e64b928d51b3a28e89cfe2a3f0eeae35ef07839",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/19 上午9:36",
      "commitNameOld": "388ba7e005fdc5b61a7a494fa44ba24489d0c6d0",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                if (need.containsAll(pack.getTips())) {\n                    need.removeAll(pack.getTips());\n                    shortCircuit.add(pack);\n                }\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n                cachedPacks.addAll(shortCircuit);\n                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n                countingMonitor.endTask();\n                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n                return;\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1100,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,149 +1,162 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n+            Set\u003cObjectId\u003e need \u003d new HashSet\u003cObjectId\u003e(want);\n+            List\u003cCachedPack\u003e shortCircuit \u003d new LinkedList\u003cCachedPack\u003e();\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n+                if (need.containsAll(pack.getTips())) {\n+                    need.removeAll(pack.getTips());\n+                    shortCircuit.add(pack);\n+                }\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n+            if (need.isEmpty() \u0026\u0026 !shortCircuit.isEmpty()) {\n+                cachedPacks.addAll(shortCircuit);\n+                for (CachedPack pack : shortCircuit) countingMonitor.update((int) pack.getObjectCount());\n+                countingMonitor.endTask();\n+                stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n+                return;\n+            }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new ArrayList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n         ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n         list.ensureCapacity(list.size() + commits.size());\n     }\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n             }\n         }\n     }\n     commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4275c4c1cffeffae6b12eb6aa2df957c23107b48": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Fix warning about untyped collection\n\nChange-Id: I44699d8ab9768844ba91f7224a7d4ee685c93ce6\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/19 上午9:36",
      "commitName": "4275c4c1cffeffae6b12eb6aa2df957c23107b48",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/18 下午1:32",
      "commitNameOld": "733780e8a158b7bc45b8b687ac353ecadc905a63",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1097,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,149 +1,149 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n-    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet(want));\n-    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet(have));\n+    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(want));\n+    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet\u003cObjectId\u003e(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n     RevCommit c;\n     while ((c \u003d walker.next()) !\u003d null) {\n         if (c.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 commits \u003d new ArrayList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(c.getTree());\n             continue;\n         }\n         commits.add(c);\n         countingMonitor.update(1);\n     }\n     if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n         ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n         list.ensureCapacity(list.size() + commits.size());\n     }\n     for (RevCommit cmit : commits) {\n         if (!cmit.has(added)) {\n             cmit.add(added);\n             addObject(cmit, 0);\n         }\n         for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n             RevCommit p \u003d cmit.getParent(i);\n             if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                 p.add(added);\n                 addObject(p, 0);\n             }\n         }\n     }\n     commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "733780e8a158b7bc45b8b687ac353ecadc905a63": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Sort commits by parse order to improve locality\n\nRevWalk in JGit and the revision code in C Git both parse commits out\nof the pack file in an order that differs from strict timestamp and\ntopological sorting.  Both implementations pop a commit from the head\nof a date queue, and then immediately parse all of its parents in\norder to insert those into the date queue at the proper positions as\ndetermined by their committer timestamp field.  This implies that the\nparents are parsed when their most recent child is popped from the\nqueue, and not where they are popped during traversal.\n\nHoisting a parent commit to be immediately behind its child improves\nlocality by making sure all parents of a merge are clustered together,\nand thus can be paged into the parser by the pack file buffering\nsystem (aka WindowCache in JGit) together.\n\nChange-Id: I80f9e64cafa2e8f082776b43845edf23065386a2\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/18 下午1:32",
      "commitName": "733780e8a158b7bc45b8b687ac353ecadc905a63",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/16 上午8:32",
      "commitNameOld": "14f99dc29d67fa4d2cb227ab906c5c8379499f6b",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlag added \u003d walker.newFlag(\"added\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n    RevCommit c;\n    while ((c \u003d walker.next()) !\u003d null) {\n        if (c.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(c);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (c.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(c.getTree());\n            continue;\n        }\n        commits.add(c);\n        countingMonitor.update(1);\n    }\n    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n        list.ensureCapacity(list.size() + commits.size());\n    }\n    for (RevCommit cmit : commits) {\n        if (!cmit.has(added)) {\n            cmit.add(added);\n            addObject(cmit, 0);\n        }\n        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n            RevCommit p \u003d cmit.getParent(i);\n            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n                p.add(added);\n                addObject(p, 0);\n            }\n        }\n    }\n    commits \u003d null;\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    RevObject o;\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1097,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,127 +1,149 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet(want));\n     stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n+    final RevFlag added \u003d walker.newFlag(\"added\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n-    RevObject o;\n-    while ((o \u003d walker.next()) !\u003d null) {\n-        if (o.has(inCachedPack)) {\n-            CachedPack pack \u003d tipToPack.get(o);\n+    List\u003cRevCommit\u003e commits \u003d new ArrayList\u003cRevCommit\u003e();\n+    RevCommit c;\n+    while ((c \u003d walker.next()) !\u003d null) {\n+        if (c.has(inCachedPack)) {\n+            CachedPack pack \u003d tipToPack.get(c);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n+                commits \u003d new ArrayList\u003cRevCommit\u003e();\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n-        if (o.has(RevFlag.UNINTERESTING)) {\n+        if (c.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n-                baseTrees.add(((RevCommit) o).getTree());\n+                baseTrees.add(c.getTree());\n             continue;\n         }\n-        addObject(o, 0);\n+        commits.add(c);\n         countingMonitor.update(1);\n     }\n+    if (objectsLists[Constants.OBJ_COMMIT] instanceof ArrayList) {\n+        ArrayList\u003cObjectToPack\u003e list \u003d (ArrayList\u003cObjectToPack\u003e) objectsLists[Constants.OBJ_COMMIT];\n+        list.ensureCapacity(list.size() + commits.size());\n+    }\n+    for (RevCommit cmit : commits) {\n+        if (!cmit.has(added)) {\n+            cmit.add(added);\n+            addObject(cmit, 0);\n+        }\n+        for (int i \u003d 0; i \u003c cmit.getParentCount(); i++) {\n+            RevCommit p \u003d cmit.getParent(i);\n+            if (!p.has(added) \u0026\u0026 !p.has(RevFlag.UNINTERESTING)) {\n+                p.add(added);\n+                addObject(p, 0);\n+            }\n+        }\n+    }\n+    commits \u003d null;\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n+    RevObject o;\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n     stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8c4524b6b36c1d97e715de9e1ff1aa18763a390": {
      "type": "Ybodychange",
      "commitMessage": "UploadPack: Expose PackWriter activity to a logger\n\nThe UploadPackLogger interface allows applications that embed\nGitServlet or otherwise use UploadPack to service clients to\ntrack and log how PackWriter was used, and what it sent.  This\nprovides more granularity into the request activity than might\nbe available from the HTTP server logs, helping administrators\nto better understand utilization and Git server performance.\n\nChange-Id: I1d36b060eb3385339d5f986e68192789ef70fc4e\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/14 上午5:43",
      "commitName": "c8c4524b6b36c1d97e715de9e1ff1aa18763a390",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/14 上午5:43",
      "commitNameOld": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    final long countingStart \u003d System.currentTimeMillis();\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet(want));\n    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet(have));\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1096,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,123 +1,127 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+    final long countingStart \u003d System.currentTimeMillis();\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n+    stats.interestingObjects \u003d Collections.unmodifiableSet(new HashSet(want));\n+    stats.uninterestingObjects \u003d Collections.unmodifiableSet(new HashSet(have));\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         if (o.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(o);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (o.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(((RevCommit) o).getTree());\n             continue;\n         }\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n+    stats.timeCounting \u003d System.currentTimeMillis() - countingStart;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5664fb3bfb63e4db49dc07d13ace419e810186c2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client\u0027s have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn\u0027t want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/14 上午5:43",
      "commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client\u0027s have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn\u0027t want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2011/2/14 上午5:43",
          "commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/2/4 上午5:20",
          "commitNameOld": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 10.02,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 1077,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,124 +1,123 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n-    final ObjectWalk walker \u003d new ObjectWalk(reader);\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         if (o.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(o);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (o.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(((RevCommit) o).getTree());\n             continue;\n         }\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), want-Collection\u003c? extends ObjectId\u003e(modifiers-final), have-Collection\u003c? extends ObjectId\u003e]",
            "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final), want-Collection\u003c? extends ObjectId\u003e(modifiers-final), have-Collection\u003c? extends ObjectId\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "UploadPack: Donate parsed commits to PackWriter\n\nWhen UploadPack has computed the merge base between the client\u0027s have\nset and the want set, its already loaded and parsed all of the\ninteresting commits that PackWriter needs to transmit to the client.\nSwitching the RevWalk and its object pool over to be an ObjectWalk\nsaves PackWriter from needing to re-parse these same commits from the\nObjectDatabase, reducing the startup latency for the enumeration\nphase of packing.\n\nUploadPack doesn\u0027t want to use an ObjectWalk for the okToGiveUp()\ntests because its slower, during each commit popped it needs to cache\nthe tree into the pendingObjects list, and during each reset() it\ndiscards a bunch of ObjectWalk specific state and reallocates some\ninternal collections.  ObjectWalk was never meant to be rapidly\nreset() like UploadPack does, so its perhaps somewhat cleaner to allow\n\"upgrading\" a RevWalk to an ObjectWalk.\n\nBug: 301639\nChange-Id: I97ef52a0b79d78229c272880aedb7f74d0f7532f\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2011/2/14 上午5:43",
          "commitName": "5664fb3bfb63e4db49dc07d13ace419e810186c2",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/2/4 上午5:20",
          "commitNameOld": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 10.02,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 1077,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,124 +1,123 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n-    final ObjectWalk walker \u003d new ObjectWalk(reader);\n     final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n     final RevFlag include \u003d walker.newFlag(\"include\");\n     final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n     keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n     walker.carry(include);\n     int haveEst \u003d have.size();\n     if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n         if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n             for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                 for (ObjectId id : pack.getTips()) {\n                     tipToPack.put(id, pack);\n                     all.add(id);\n                 }\n             }\n             haveEst +\u003d tipToPack.size();\n         }\n     } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n     List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (tipToPack.containsKey(o))\n                     o.add(inCachedPack);\n                 if (have.contains(o)) {\n                     haveObjs.add(o);\n                     walker.markUninteresting(o);\n                 } else if (want.contains(o)) {\n                     o.add(include);\n                     wantObjs.add(o);\n                     walker.markStart(o);\n                 }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n     int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         if (o.has(inCachedPack)) {\n             CachedPack pack \u003d tipToPack.get(o);\n             if (includesAllTips(pack, include, walker)) {\n                 useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                 countingMonitor.endTask();\n                 countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                 continue;\n             }\n         }\n         if (o.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(((RevCommit) o).getTree());\n             continue;\n         }\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(walker.lookupCommit(d).getTree());\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n         }\n     }\n     BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     for (CachedPack p : cachedPacks) {\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n         }\n         for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n             objectsMap.get(d).setEdge();\n             typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n         }\n     }\n     if (typesToPrune !\u003d 0) {\n         pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n         pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n         pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n         pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n     }\n     for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "461b012e9565af8174e5b9d2b2c3a582011ce77e": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Support reuse of entire packs\n\nThe most expensive part of packing a repository for transport to\nanother system is enumerating all of the objects in the repository.\nOnce this gets to the size of the linux-2.6 repository (1.8 million\nobjects), enumeration can take several CPU minutes and costs a lot\nof temporary working set memory.\n\nTeach PackWriter to efficiently reuse an existing \"cached pack\"\nby answering a clone request with a thin pack followed by a larger\ncached pack appended to the end.  This requires the repository\nowner to first construct the cached pack by hand, and record the\ntip commits inside of $GIT_DIR/objects/info/cached-packs:\n\n  cd $GIT_DIR\n  root\u003d$(git rev-parse master)\n  tmp\u003dobjects/.tmp-$$\n  names\u003d$(echo $root | git pack-objects --keep-true-parents --revs $tmp)\n  for n in $names; do\n    chmod a-w $tmp-$n.pack $tmp-$n.idx\n    touch objects/pack/pack-$n.keep\n    mv $tmp-$n.pack objects/pack/pack-$n.pack\n    mv $tmp-$n.idx objects/pack/pack-$n.idx\n  done\n\n  (echo \"+ $root\";\n   for n in $names; do echo \"P $n\"; done;\n   echo) \u003e\u003eobjects/info/cached-packs\n\n  git repack -a -d\n\nWhen a clone request needs to include $root, the corresponding\ncached pack will be copied as-is, rather than enumerating all of\nthe objects that are reachable from $root.\n\nFor a linux-2.6 kernel repository that should be about 376 MiB,\nthe above process creates two packs of 368 MiB and 38 MiB[1].\nThis is a local disk usage increase of ~26 MiB, due to reduced\ndelta compression between the large cached pack and the smaller\nrecent activity pack.  The overhead is similar to 1 full copy of\nthe compressed project sources.\n\nWith this cached pack in hand, JGit daemon completes a clone request\nin 1m17s less time, but a slightly larger data transfer (+2.39 MiB):\n\n  Before:\n    remote: Counting objects: 1861830, done\n    remote: Finding sources: 100% (1861830/1861830)\n    remote: Getting sizes: 100% (88243/88243)\n    remote: Compressing objects: 100% (88184/88184)\n    Receiving objects: 100% (1861830/1861830), 376.01 MiB | 19.01 MiB/s, done.\n    remote: Total 1861830 (delta 4706), reused 1851053 (delta 1553844)\n    Resolving deltas: 100% (1564621/1564621), done.\n\n    real  3m19.005s\n\n  After:\n    remote: Counting objects: 1601, done\n    remote: Counting objects: 1828460, done\n    remote: Finding sources: 100% (50475/50475)\n    remote: Getting sizes: 100% (18843/18843)\n    remote: Compressing objects: 100% (7585/7585)\n    remote: Total 1861830 (delta 2407), reused 1856197 (delta 37510)\n    Receiving objects: 100% (1861830/1861830), 378.40 MiB | 31.31 MiB/s, done.\n    Resolving deltas: 100% (1559477/1559477), done.\n\n    real 2m2.938s\n\nRepository owners can periodically refresh their cached packs by\nrepacking their repository, folding all newer objects into a larger\ncached pack.  Since repacking is already considered to be a normal\nGit maintenance activity, this isn\u0027t a very big burden.\n\n[1] In this test $root was set back about two weeks.\n\nChange-Id: Ib87131d5c4b5e8c5cacb0f4fe16ff4ece554734b\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/2/4 上午5:20",
      "commitName": "461b012e9565af8174e5b9d2b2c3a582011ce77e",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/3 上午9:17",
      "commitNameOld": "71f168fcd77ec100d68233d3d467f770304f6eb8",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n    final RevFlag include \u003d walker.newFlag(\"include\");\n    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n    keepOnRestart.add(inCachedPack);\n    walker.setRetainBody(false);\n    walker.carry(include);\n    int haveEst \u003d have.size();\n    if (have.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n                for (ObjectId id : pack.getTips()) {\n                    tipToPack.put(id, pack);\n                    all.add(id);\n                }\n            }\n            haveEst +\u003d tipToPack.size();\n        }\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (tipToPack.containsKey(o))\n                    o.add(inCachedPack);\n                if (have.contains(o)) {\n                    haveObjs.add(o);\n                    walker.markUninteresting(o);\n                } else if (want.contains(o)) {\n                    o.add(include);\n                    wantObjs.add(o);\n                    walker.markStart(o);\n                }\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    int typesToPrune \u003d 0;\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(inCachedPack)) {\n            CachedPack pack \u003d tipToPack.get(o);\n            if (includesAllTips(pack, include, walker)) {\n                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n                countingMonitor.endTask();\n                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n                continue;\n            }\n        }\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(walker.lookupCommit(d).getTree());\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n        }\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    for (CachedPack p : cachedPacks) {\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n        }\n        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n            objectsMap.get(d).setEdge();\n            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n        }\n    }\n    if (typesToPrune !\u003d 0) {\n        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n    }\n    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n    countingMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1044,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,61 +1,124 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n+    final Map\u003cObjectId, CachedPack\u003e tipToPack \u003d new HashMap\u003cObjectId, CachedPack\u003e();\n     final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    final RevFlag inCachedPack \u003d walker.newFlag(\"inCachedPack\");\n+    final RevFlag include \u003d walker.newFlag(\"include\");\n+    final RevFlagSet keepOnRestart \u003d new RevFlagSet();\n+    keepOnRestart.add(inCachedPack);\n     walker.setRetainBody(false);\n-    if (have.isEmpty())\n+    walker.carry(include);\n+    int haveEst \u003d have.size();\n+    if (have.isEmpty()) {\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n-    else {\n+        if (useCachedPacks \u0026\u0026 reuseSupport !\u003d null) {\n+            for (CachedPack pack : reuseSupport.getCachedPacks()) {\n+                for (ObjectId id : pack.getTips()) {\n+                    tipToPack.put(id, pack);\n+                    all.add(id);\n+                }\n+            }\n+            haveEst +\u003d tipToPack.size();\n+        }\n+    } else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n+    List\u003cRevObject\u003e wantObjs \u003d new ArrayList\u003cRevObject\u003e(want.size());\n+    List\u003cRevObject\u003e haveObjs \u003d new ArrayList\u003cRevObject\u003e(haveEst);\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n-                if (have.contains(o))\n+                if (tipToPack.containsKey(o))\n+                    o.add(inCachedPack);\n+                if (have.contains(o)) {\n+                    haveObjs.add(o);\n                     walker.markUninteresting(o);\n-                else\n+                } else if (want.contains(o)) {\n+                    o.add(include);\n+                    wantObjs.add(o);\n                     walker.markStart(o);\n+                }\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n+    int typesToPrune \u003d 0;\n     final int maxBases \u003d config.getDeltaSearchWindowSize();\n     Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n+        if (o.has(inCachedPack)) {\n+            CachedPack pack \u003d tipToPack.get(o);\n+            if (includesAllTips(pack, include, walker)) {\n+                useCachedPack(walker, keepOnRestart, wantObjs, haveObjs, pack);\n+                countingMonitor.endTask();\n+                countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+                continue;\n+            }\n+        }\n         if (o.has(RevFlag.UNINTERESTING)) {\n             if (baseTrees.size() \u003c\u003d maxBases)\n                 baseTrees.add(((RevCommit) o).getTree());\n             continue;\n         }\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n-    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, edgeObjects, reader);\n+    for (CachedPack p : cachedPacks) {\n+        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_COMMIT])) {\n+            if (baseTrees.size() \u003c\u003d maxBases)\n+                baseTrees.add(walker.lookupCommit(d).getTree());\n+            objectsMap.get(d).setEdge();\n+            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_COMMIT;\n+        }\n+    }\n+    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, objectsMap, edgeObjects, reader);\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         if (o.has(RevFlag.UNINTERESTING))\n             continue;\n         int pathHash \u003d walker.getPathHashCode();\n         byte[] pathBuf \u003d walker.getPathBuffer();\n         int pathLen \u003d walker.getPathLength();\n         bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n         addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n+    for (CachedPack p : cachedPacks) {\n+        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TREE])) {\n+            objectsMap.get(d).setEdge();\n+            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TREE;\n+        }\n+        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_BLOB])) {\n+            objectsMap.get(d).setEdge();\n+            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_BLOB;\n+        }\n+        for (ObjectId d : p.hasObject(objectsLists[Constants.OBJ_TAG])) {\n+            objectsMap.get(d).setEdge();\n+            typesToPrune |\u003d 1 \u003c\u003c Constants.OBJ_TAG;\n+        }\n+    }\n+    if (typesToPrune !\u003d 0) {\n+        pruneObjectList(typesToPrune, Constants.OBJ_COMMIT);\n+        pruneObjectList(typesToPrune, Constants.OBJ_TREE);\n+        pruneObjectList(typesToPrune, Constants.OBJ_BLOB);\n+        pruneObjectList(typesToPrune, Constants.OBJ_TAG);\n+    }\n+    for (CachedPack pack : cachedPacks) countingMonitor.update((int) pack.getObjectCount());\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13bcf05a9ea2d4943faef2c879aac65d37517eb6": {
      "type": "Ybodychange",
      "commitMessage": "PackWriter: Make thin packs more efficient\n\nThere is no point in pushing all of the files within the edge\ncommits into the delta search when making a thin pack.  This floods\nthe delta search window with objects that are unlikely to be useful\nbases for the objects that will be written out, resulting in lower\ndata compression and higher transfer sizes.\n\nInstead observe the path of a tree or blob that is being pushed\ninto the outgoing set, and use that path to locate up to WINDOW\nancestor versions from the edge commits.  Push only those objects\ninto the edgeObjects set, reducing the number of objects seen by the\nsearch window.  This allows PackWriter to only look at ancestors\nfor the modified files, rather than all files in the project.\nLimiting the search to WINDOW size makes sense, because more than\nWINDOW edge objects will just skip through the window search as\nnone of them need to be delta compressed.\n\nTo further improve compression, sort edge objects into the front\nof the window list, rather than randomly throughout.  This puts\nnon-edges later in the window and gives them a better chance at\nfinding their base, since they search backwards through the window.\n\nThese changes make a significant difference in the thin-pack:\n\n  Before:\n    remote: Counting objects: 144190, done\n    remote: Finding sources: 100% (50275/50275)\n    remote: Getting sizes: 100% (101405/101405)\n    remote: Compressing objects: 100% (7587/7587)\n    Receiving objects: 100% (50275/50275), 24.67 MiB | 9.90 MiB/s, done.\n    Resolving deltas: 100% (40339/40339), completed with 2218 local objects.\n\n    real    0m30.267s\n\n  After:\n    remote: Counting objects: 61549, done\n    remote: Finding sources: 100% (50275/50275)\n    remote: Getting sizes: 100% (18862/18862)\n    remote: Compressing objects: 100% (7588/7588)\n    Receiving objects: 100% (50275/50275), 11.04 MiB | 3.51 MiB/s, done.\n    Resolving deltas: 100% (43160/43160), completed with 5014 local objects.\n\n    real    0m22.170s\n\nThe resulting pack is 13.63 MiB smaller, even though it contains the\nsame exact objects.  82,543 fewer objects had to have their sizes\nlooked up, which saved about 8s of server CPU time.  2,796 more\nobjects from the client were used as part of the base object set,\nwhich contributed to the smaller transfer size.\n\nChange-Id: Id01271950432c6960897495b09deab70e33993a9\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigend-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/2/1 下午11:12",
      "commitName": "13bcf05a9ea2d4943faef2c879aac65d37517eb6",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2011/2/1 下午11:03",
      "commitNameOld": "2fbcba41e365752681f635c706d577e605d3336a",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    final int maxBases \u003d config.getDeltaSearchWindowSize();\n    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING)) {\n            if (baseTrees.size() \u003c\u003d maxBases)\n                baseTrees.add(((RevCommit) o).getTree());\n            continue;\n        }\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, edgeObjects, reader);\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        if (o.has(RevFlag.UNINTERESTING))\n            continue;\n        int pathHash \u003d walker.getPathHashCode();\n        byte[] pathBuf \u003d walker.getPathBuffer();\n        int pathLen \u003d walker.getPathLength();\n        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n        addObject(o, pathHash);\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 984,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,61 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     if (have \u003d\u003d null)\n         have \u003d Collections.emptySet();\n     List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n     all.addAll(want);\n     all.addAll(have);\n     final ObjectWalk walker \u003d new ObjectWalk(reader);\n     walker.setRetainBody(false);\n     if (have.isEmpty())\n         walker.sort(RevSort.COMMIT_TIME_DESC);\n     else {\n         walker.sort(RevSort.TOPO);\n         if (thin)\n             walker.sort(RevSort.BOUNDARY, true);\n     }\n     AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n     try {\n         for (; ; ) {\n             try {\n                 RevObject o \u003d q.next();\n                 if (o \u003d\u003d null)\n                     break;\n                 if (have.contains(o))\n                     walker.markUninteresting(o);\n                 else\n                     walker.markStart(o);\n             } catch (MissingObjectException e) {\n                 if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                     continue;\n                 throw e;\n             }\n         }\n     } finally {\n         q.release();\n     }\n+    final int maxBases \u003d config.getDeltaSearchWindowSize();\n+    Set\u003cRevTree\u003e baseTrees \u003d new HashSet\u003cRevTree\u003e();\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n+        if (o.has(RevFlag.UNINTERESTING)) {\n+            if (baseTrees.size() \u003c\u003d maxBases)\n+                baseTrees.add(((RevCommit) o).getTree());\n+            continue;\n+        }\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n+    BaseSearch bases \u003d new BaseSearch(countingMonitor, baseTrees, edgeObjects, reader);\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n-        addObject(o, walker.getPathHashCode());\n+        if (o.has(RevFlag.UNINTERESTING))\n+            continue;\n+        int pathHash \u003d walker.getPathHashCode();\n+        byte[] pathBuf \u003d walker.getPathBuffer();\n+        int pathLen \u003d walker.getPathLength();\n+        bases.addBase(o.getType(), pathBuf, pathLen, pathHash);\n+        addObject(o, pathHash);\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2fbcba41e365752681f635c706d577e605d3336a": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject\u0027s broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/2/1 下午11:03",
      "commitName": "2fbcba41e365752681f635c706d577e605d3336a",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject\u0027s broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
          "commitDate": "2011/2/1 下午11:03",
          "commitName": "2fbcba41e365752681f635c706d577e605d3336a",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/2/1 下午11:01",
          "commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 976,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,47 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    if (have \u003d\u003d null)\n+        have \u003d Collections.emptySet();\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n+    all.addAll(want);\n+    all.addAll(have);\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    walker.setRetainBody(false);\n+    if (have.isEmpty())\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+    else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (have.contains(o))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o, walker.getPathHashCode());\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]",
            "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), want-Collection\u003c? extends ObjectId\u003e(modifiers-final), have-Collection\u003c? extends ObjectId\u003e]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject\u0027s broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
          "commitDate": "2011/2/1 下午11:03",
          "commitName": "2fbcba41e365752681f635c706d577e605d3336a",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/2/1 下午11:01",
          "commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 976,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,47 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    if (have \u003d\u003d null)\n+        have \u003d Collections.emptySet();\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n+    all.addAll(want);\n+    all.addAll(have);\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    walker.setRetainBody(false);\n+    if (have.isEmpty())\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+    else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (have.contains(o))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o, walker.getPathHashCode());\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]",
            "newValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "PackWriter: Cleanup findObjectToPack method\n\nSome of this code predates making ObjectId.equals() final\nand fixing RevObject.equals() to match ObjectId.equals().\nIt was therefore more complex than it needs to be, because\nit tried to work around RevObject\u0027s broken equals() rules\nby converting to ObjectId in a different collection.\n\nAlso combine setUpWalker() and findObjectsToPack() methods,\nthese can be one method and the code is actually cleaner.\n\nChange-Id: I0f4cf9997cd66d8b6e7f80873979ef1439e507fe\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
          "commitDate": "2011/2/1 下午11:03",
          "commitName": "2fbcba41e365752681f635c706d577e605d3336a",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/2/1 下午11:01",
          "commitNameOld": "8f63dface2e08b228cdeb3bef3f93458eab9ce14",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    if (have \u003d\u003d null)\n        have \u003d Collections.emptySet();\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n    all.addAll(want);\n    all.addAll(have);\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    walker.setRetainBody(false);\n    if (have.isEmpty())\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n    else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (have.contains(o))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 976,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,47 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e want, Collection\u003c? extends ObjectId\u003e have) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    if (have \u003d\u003d null)\n+        have \u003d Collections.emptySet();\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(want.size() + have.size());\n+    all.addAll(want);\n+    all.addAll(have);\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    walker.setRetainBody(false);\n+    if (have.isEmpty())\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+    else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (have.contains(o))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 have.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o, walker.getPathHashCode());\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "065a0a8122be356d1f898321763d3518b504b075": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren\u0027t always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that\u0027s more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn\u0027t be using a separate cache\nin JGit.\n",
      "commitDate": "2011/1/28 下午11:20",
      "commitName": "065a0a8122be356d1f898321763d3518b504b075",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren\u0027t always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that\u0027s more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn\u0027t be using a separate cache\nin JGit.\n",
          "commitDate": "2011/1/28 下午11:20",
          "commitName": "065a0a8122be356d1f898321763d3518b504b075",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午1:38",
          "commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.9,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 1026,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,62 +1,13 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n-    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n-    for (ObjectId id : interestingObjects) all.add(id.copy());\n-    final Set\u003cObjectId\u003e not;\n-    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n-        not \u003d new HashSet\u003cObjectId\u003e();\n-        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n-        all.addAll(not);\n-    } else\n-        not \u003d Collections.emptySet();\n-    final ObjectWalk walker \u003d new ObjectWalk(reader);\n-    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n-    walker.setRetainBody(false);\n-    if (not.isEmpty()) {\n-        walker.sort(RevSort.COMMIT_TIME_DESC);\n-        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n-    } else {\n-        walker.sort(RevSort.TOPO);\n-        if (thin)\n-            walker.sort(RevSort.BOUNDARY, true);\n-    }\n-    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n-    try {\n-        for (; ; ) {\n-            try {\n-                RevObject o \u003d q.next();\n-                if (o \u003d\u003d null)\n-                    break;\n-                if (not.contains(o.copy()))\n-                    walker.markUninteresting(o);\n-                else\n-                    walker.markStart(o);\n-            } catch (MissingObjectException e) {\n-                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n-                    continue;\n-                throw e;\n-            }\n-        }\n-    } finally {\n-        q.release();\n-    }\n-    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        if (o.has(hasObjectList)) {\n-            listName \u003d o;\n-            break;\n-        }\n-        addResultOrBase(o, 0);\n+        addObject(o, 0);\n         countingMonitor.update(1);\n     }\n-    if (listName !\u003d null) {\n-        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n-    } else {\n-        while ((o \u003d walker.nextObject()) !\u003d null) {\n-            addResultOrBase(o, walker.getPathHashCode());\n-            countingMonitor.update(1);\n-        }\n+    while ((o \u003d walker.nextObject()) !\u003d null) {\n+        addObject(o, walker.getPathHashCode());\n+        countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), interestingObjects-Collection\u003c? extends ObjectId\u003e(modifiers-final), uninterestingObjects-Collection\u003c? extends ObjectId\u003e(modifiers-final)]",
            "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren\u0027t always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that\u0027s more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn\u0027t be using a separate cache\nin JGit.\n",
          "commitDate": "2011/1/28 下午11:20",
          "commitName": "065a0a8122be356d1f898321763d3518b504b075",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午1:38",
          "commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.9,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 1026,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,62 +1,13 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n-    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n-    for (ObjectId id : interestingObjects) all.add(id.copy());\n-    final Set\u003cObjectId\u003e not;\n-    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n-        not \u003d new HashSet\u003cObjectId\u003e();\n-        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n-        all.addAll(not);\n-    } else\n-        not \u003d Collections.emptySet();\n-    final ObjectWalk walker \u003d new ObjectWalk(reader);\n-    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n-    walker.setRetainBody(false);\n-    if (not.isEmpty()) {\n-        walker.sort(RevSort.COMMIT_TIME_DESC);\n-        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n-    } else {\n-        walker.sort(RevSort.TOPO);\n-        if (thin)\n-            walker.sort(RevSort.BOUNDARY, true);\n-    }\n-    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n-    try {\n-        for (; ; ) {\n-            try {\n-                RevObject o \u003d q.next();\n-                if (o \u003d\u003d null)\n-                    break;\n-                if (not.contains(o.copy()))\n-                    walker.markUninteresting(o);\n-                else\n-                    walker.markStart(o);\n-            } catch (MissingObjectException e) {\n-                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n-                    continue;\n-                throw e;\n-            }\n-        }\n-    } finally {\n-        q.release();\n-    }\n-    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        if (o.has(hasObjectList)) {\n-            listName \u003d o;\n-            break;\n-        }\n-        addResultOrBase(o, 0);\n+        addObject(o, 0);\n         countingMonitor.update(1);\n     }\n-    if (listName !\u003d null) {\n-        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n-    } else {\n-        while ((o \u003d walker.nextObject()) !\u003d null) {\n-            addResultOrBase(o, walker.getPathHashCode());\n-            countingMonitor.update(1);\n-        }\n+    while ((o \u003d walker.nextObject()) !\u003d null) {\n+        addObject(o, walker.getPathHashCode());\n+        countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]",
            "newValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"Teach PackWriter how to reuse an existing object list\"\n\nThis reverts commit f5fe2dca3cb9f57891e1a4b18832fcc158d0c490.\n\nI regret adding this feature to the public API.  Caches aren\u0027t always\nthe best idea, as they require work to maintain.  Here the cache is\nredundant information that must be computed, and when it grows stale\nmust be removed.  The redundant information takes up more disk space,\nabout the same size as the pack-*.idx files are.  For the linux-2.6\nrepository, that\u0027s more than 40 MB for a 400 MB repository.  So the\ncache is a 10% increase in disk usage.\n\nThe entire point of this cache is to improve PackWriter performance,\nand only PackWriter performance, and only when sending an initial\nclone to a new client.  There may be better ways to optimize this, and\nuntil we have a solid solution, we shouldn\u0027t be using a separate cache\nin JGit.\n",
          "commitDate": "2011/1/28 下午11:20",
          "commitName": "065a0a8122be356d1f898321763d3518b504b075",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午1:38",
          "commitNameOld": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.9,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 1026,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,62 +1,13 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n-    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n-    for (ObjectId id : interestingObjects) all.add(id.copy());\n-    final Set\u003cObjectId\u003e not;\n-    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n-        not \u003d new HashSet\u003cObjectId\u003e();\n-        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n-        all.addAll(not);\n-    } else\n-        not \u003d Collections.emptySet();\n-    final ObjectWalk walker \u003d new ObjectWalk(reader);\n-    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n-    walker.setRetainBody(false);\n-    if (not.isEmpty()) {\n-        walker.sort(RevSort.COMMIT_TIME_DESC);\n-        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n-    } else {\n-        walker.sort(RevSort.TOPO);\n-        if (thin)\n-            walker.sort(RevSort.BOUNDARY, true);\n-    }\n-    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n-    try {\n-        for (; ; ) {\n-            try {\n-                RevObject o \u003d q.next();\n-                if (o \u003d\u003d null)\n-                    break;\n-                if (not.contains(o.copy()))\n-                    walker.markUninteresting(o);\n-                else\n-                    walker.markStart(o);\n-            } catch (MissingObjectException e) {\n-                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n-                    continue;\n-                throw e;\n-            }\n-        }\n-    } finally {\n-        q.release();\n-    }\n-    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        if (o.has(hasObjectList)) {\n-            listName \u003d o;\n-            break;\n-        }\n-        addResultOrBase(o, 0);\n+        addObject(o, 0);\n         countingMonitor.update(1);\n     }\n-    if (listName !\u003d null) {\n-        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n-    } else {\n-        while ((o \u003d walker.nextObject()) !\u003d null) {\n-            addResultOrBase(o, walker.getPathHashCode());\n-            countingMonitor.update(1);\n-        }\n+    while ((o \u003d walker.nextObject()) !\u003d null) {\n+        addObject(o, walker.getPathHashCode());\n+        countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project\u0027s history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn\u0027t desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit\u0027s immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2011/1/28 上午1:38",
      "commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project\u0027s history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn\u0027t desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit\u0027s immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2011/1/28 上午1:38",
          "commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午12:58",
          "commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n    for (ObjectId id : interestingObjects) all.add(id.copy());\n    final Set\u003cObjectId\u003e not;\n    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n        not \u003d new HashSet\u003cObjectId\u003e();\n        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n        all.addAll(not);\n    } else\n        not \u003d Collections.emptySet();\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n    walker.setRetainBody(false);\n    if (not.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (not.contains(o.copy()))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject listName \u003d null;\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(hasObjectList)) {\n            listName \u003d o;\n            break;\n        }\n        addResultOrBase(o, 0);\n        countingMonitor.update(1);\n    }\n    if (listName !\u003d null) {\n        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n    } else {\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            addResultOrBase(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 975,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,62 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n+    for (ObjectId id : interestingObjects) all.add(id.copy());\n+    final Set\u003cObjectId\u003e not;\n+    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n+        not \u003d new HashSet\u003cObjectId\u003e();\n+        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n+        all.addAll(not);\n+    } else\n+        not \u003d Collections.emptySet();\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n+    walker.setRetainBody(false);\n+    if (not.isEmpty()) {\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n+    } else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (not.contains(o.copy()))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n+    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        addObject(o, 0);\n+        if (o.has(hasObjectList)) {\n+            listName \u003d o;\n+            break;\n+        }\n+        addResultOrBase(o, 0);\n         countingMonitor.update(1);\n     }\n-    while ((o \u003d walker.nextObject()) !\u003d null) {\n-        addObject(o, walker.getPathHashCode());\n-        countingMonitor.update(1);\n+    if (listName !\u003d null) {\n+        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n+    } else {\n+        while ((o \u003d walker.nextObject()) !\u003d null) {\n+            addResultOrBase(o, walker.getPathHashCode());\n+            countingMonitor.update(1);\n+        }\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]",
            "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), interestingObjects-Collection\u003c? extends ObjectId\u003e(modifiers-final), uninterestingObjects-Collection\u003c? extends ObjectId\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project\u0027s history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn\u0027t desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit\u0027s immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2011/1/28 上午1:38",
          "commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午12:58",
          "commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n    for (ObjectId id : interestingObjects) all.add(id.copy());\n    final Set\u003cObjectId\u003e not;\n    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n        not \u003d new HashSet\u003cObjectId\u003e();\n        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n        all.addAll(not);\n    } else\n        not \u003d Collections.emptySet();\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n    walker.setRetainBody(false);\n    if (not.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (not.contains(o.copy()))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject listName \u003d null;\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(hasObjectList)) {\n            listName \u003d o;\n            break;\n        }\n        addResultOrBase(o, 0);\n        countingMonitor.update(1);\n    }\n    if (listName !\u003d null) {\n        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n    } else {\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            addResultOrBase(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 975,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,62 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n+    for (ObjectId id : interestingObjects) all.add(id.copy());\n+    final Set\u003cObjectId\u003e not;\n+    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n+        not \u003d new HashSet\u003cObjectId\u003e();\n+        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n+        all.addAll(not);\n+    } else\n+        not \u003d Collections.emptySet();\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n+    walker.setRetainBody(false);\n+    if (not.isEmpty()) {\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n+    } else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (not.contains(o.copy()))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n+    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        addObject(o, 0);\n+        if (o.has(hasObjectList)) {\n+            listName \u003d o;\n+            break;\n+        }\n+        addResultOrBase(o, 0);\n         countingMonitor.update(1);\n     }\n-    while ((o \u003d walker.nextObject()) !\u003d null) {\n-        addObject(o, walker.getPathHashCode());\n-        countingMonitor.update(1);\n+    if (listName !\u003d null) {\n+        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n+    } else {\n+        while ((o \u003d walker.nextObject()) !\u003d null) {\n+            addResultOrBase(o, walker.getPathHashCode());\n+            countingMonitor.update(1);\n+        }\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[MissingObjectException, IncorrectObjectTypeException, IOException]",
            "newValue": "[MissingObjectException, IOException, IncorrectObjectTypeException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Teach PackWriter how to reuse an existing object list\n\nCounting the objects needed for packing is the most expensive part of\nan UploadPack request that has no uninteresting objects (otherwise\nknown as an initial clone).  During this phase the PackWriter is\nenumerating the entire set of objects in this repository, so they can\nbe sent to the client for their new clone.\n\nAllow the ObjectReader (and therefore the underlying storage system)\nto keep a cached list of all reachable objects from a small number of\npoints in the project\u0027s history.  If one of those points is reached\nduring enumeration of the commit graph, most objects are obtained from\nthe cached list instead of direct traversal.\n\nPackWriter uses the list by discarding the current object lists and\nrestarting a traversal from all refs but marking the object list name\nas uninteresting.  This allows PackWriter to enumerate all objects\nthat are more recent than the list creation, or that were on side\nbranches that the list does not include.\n\nHowever, ObjectWalk tags all of the trees and commits within the list\ncommit as UNINTERESTING, which would normally cause PackWriter to\nconstruct a thin pack that excludes these objects.  To avoid that,\naddObject() was refactored to allow this list-based enumeration to\nalways include an object, even if it has been tagged UNINTERESTING by\nthe ObjectWalk.  This implies the list-based enumeration may only be\nused for initial clones, where all objects are being sent.\n\nThe UNINTERESTING labeling occurs because StartGenerator always\nenables the BoundaryGenerator if the walker is an ObjectWalk and a\ncommit was marked UNINTERESTING, even if RevSort.BOUNDARY was not\nenabled.  This is the default reasonable behavior for an ObjectWalk,\nbut isn\u0027t desired here in PackWriter with the list-based enumeration.\nRather than trying to change all of this behavior, PackWriter works\naround it.\n\nBecause the list name commit\u0027s immediate files and trees were all\nenumerated before the list enumeration itself starts (and are also\nwithin the list itself) PackWriter runs the risk of adding the same\nobjects to its ObjectIdSubclassMap twice.  Since this breaks the\ninternal map data structure (and also may cause the object to transmit\ntwice), PackWriter needs to use a new \"added\" RevFlag to track whether\nor not an object has been put into the outgoing list yet.\n\nChange-Id: Ie99ed4d969a6bb20cc2528ac6b8fb91043cee071\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2011/1/28 上午1:38",
          "commitName": "f5fe2dca3cb9f57891e1a4b18832fcc158d0c490",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2011/1/28 上午12:58",
          "commitNameOld": "c218a0760ddcdd9a392b0ae15f99fdccf823cd42",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n    for (ObjectId id : interestingObjects) all.add(id.copy());\n    final Set\u003cObjectId\u003e not;\n    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n        not \u003d new HashSet\u003cObjectId\u003e();\n        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n        all.addAll(not);\n    } else\n        not \u003d Collections.emptySet();\n    final ObjectWalk walker \u003d new ObjectWalk(reader);\n    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n    walker.setRetainBody(false);\n    if (not.isEmpty()) {\n        walker.sort(RevSort.COMMIT_TIME_DESC);\n        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n    } else {\n        walker.sort(RevSort.TOPO);\n        if (thin)\n            walker.sort(RevSort.BOUNDARY, true);\n    }\n    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n    try {\n        for (; ; ) {\n            try {\n                RevObject o \u003d q.next();\n                if (o \u003d\u003d null)\n                    break;\n                if (not.contains(o.copy()))\n                    walker.markUninteresting(o);\n                else\n                    walker.markStart(o);\n            } catch (MissingObjectException e) {\n                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n                    continue;\n                throw e;\n            }\n        }\n    } finally {\n        q.release();\n    }\n    RevObject listName \u003d null;\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        if (o.has(hasObjectList)) {\n            listName \u003d o;\n            break;\n        }\n        addResultOrBase(o, 0);\n        countingMonitor.update(1);\n    }\n    if (listName !\u003d null) {\n        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n    } else {\n        while ((o \u003d walker.nextObject()) !\u003d null) {\n            addResultOrBase(o, walker.getPathHashCode());\n            countingMonitor.update(1);\n        }\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 975,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,62 @@\n-private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final Collection\u003c? extends ObjectId\u003e interestingObjects, final Collection\u003c? extends ObjectId\u003e uninterestingObjects) throws MissingObjectException, IOException, IncorrectObjectTypeException {\n     countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n+    List\u003cObjectId\u003e all \u003d new ArrayList\u003cObjectId\u003e(interestingObjects.size());\n+    for (ObjectId id : interestingObjects) all.add(id.copy());\n+    final Set\u003cObjectId\u003e not;\n+    if (uninterestingObjects !\u003d null \u0026\u0026 !uninterestingObjects.isEmpty()) {\n+        not \u003d new HashSet\u003cObjectId\u003e();\n+        for (ObjectId id : uninterestingObjects) not.add(id.copy());\n+        all.addAll(not);\n+    } else\n+        not \u003d Collections.emptySet();\n+    final ObjectWalk walker \u003d new ObjectWalk(reader);\n+    final RevFlag hasObjectList \u003d walker.newFlag(\"hasObjectList\");\n+    walker.setRetainBody(false);\n+    if (not.isEmpty()) {\n+        walker.sort(RevSort.COMMIT_TIME_DESC);\n+        for (ObjectId listName : reader.getAvailableObjectLists()) walker.lookupCommit(listName).add(hasObjectList);\n+    } else {\n+        walker.sort(RevSort.TOPO);\n+        if (thin)\n+            walker.sort(RevSort.BOUNDARY, true);\n+    }\n+    AsyncRevObjectQueue q \u003d walker.parseAny(all, true);\n+    try {\n+        for (; ; ) {\n+            try {\n+                RevObject o \u003d q.next();\n+                if (o \u003d\u003d null)\n+                    break;\n+                if (not.contains(o.copy()))\n+                    walker.markUninteresting(o);\n+                else\n+                    walker.markStart(o);\n+            } catch (MissingObjectException e) {\n+                if (ignoreMissingUninteresting \u0026\u0026 not.contains(e.getObjectId()))\n+                    continue;\n+                throw e;\n+            }\n+        }\n+    } finally {\n+        q.release();\n+    }\n+    RevObject listName \u003d null;\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        addObject(o, 0);\n+        if (o.has(hasObjectList)) {\n+            listName \u003d o;\n+            break;\n+        }\n+        addResultOrBase(o, 0);\n         countingMonitor.update(1);\n     }\n-    while ((o \u003d walker.nextObject()) !\u003d null) {\n-        addObject(o, walker.getPathHashCode());\n-        countingMonitor.update(1);\n+    if (listName !\u003d null) {\n+        addByObjectList(listName, countingMonitor, walker, interestingObjects);\n+    } else {\n+        while ((o \u003d walker.nextObject()) !\u003d null) {\n+            addResultOrBase(o, walker.getPathHashCode());\n+            countingMonitor.update(1);\n+        }\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "21f76c2a69836ec618c82eb9305656dcec70befb": {
      "type": "Ybodychange",
      "commitMessage": "Remove static progress task names from PackWriter\n\nThese need to be dynamic based on the current thread\u0027s environment\nat time of execution in order to be properly localized for the end\nuser that will be seeing these messages.\n\nChange-Id: I4976f462cfe606edd2761c0e36b2f6b20f63d53c\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/29 上午1:50",
      "commitName": "21f76c2a69836ec618c82eb9305656dcec70befb",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/28 上午12:40",
      "commitNameOld": "a00377a7e23dbde315598ee20f61c45d031e159a",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 1.05,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 1291,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,13 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n-    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n+    countingMonitor.beginTask(JGitText.get().countingObjects, ProgressMonitor.UNKNOWN);\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o, walker.getPathHashCode());\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f93a09dd10696b6388a0fcb4099341ccef05169": {
      "type": "Ybodychange",
      "commitMessage": "Save object path hash codes during packing\n\nWe need to remember these so we can later cluster objects that\nhave similar file paths near each other as we search for deltas\nbetween them.\n\nChange-Id: I52cb1e4ca15c9c267a2dbf51dd0d795f885f4cf8\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/7/10 上午6:17",
      "commitName": "2f93a09dd10696b6388a0fcb4099341ccef05169",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/7/1 上午9:50",
      "commitNameOld": "a0fd06e5c2696cc6bed396fd513ec8e4465e399c",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 8.85,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o, 0);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o, walker.getPathHashCode());\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 808,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,13 @@\n private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n     countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n-        addObject(o);\n+        addObject(o, 0);\n         countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n-        addObject(o);\n+        addObject(o, walker.getPathHashCode());\n         countingMonitor.update(1);\n     }\n     countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b62e53b607630b6c00411741972838ced552f4d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/29 上午2:47",
      "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
      "commitAuthor": "Shawn O. Pearce",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/6/29 上午2:47",
          "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/6/29 上午2:47",
          "commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o);\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 768,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,13 @@\n-private void findObjectsToPack(final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n-    initMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o);\n-        initMonitor.update(1);\n+        countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o);\n-        initMonitor.update(1);\n+        countingMonitor.update(1);\n     }\n-    initMonitor.endTask();\n+    countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[walker-ObjectWalk(modifiers-final)]",
            "newValue": "[countingMonitor-ProgressMonitor(modifiers-final), walker-ObjectWalk(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move PackWriter progress monitors onto the operations\n\nRather than taking the ProgressMonitor objects in our constructor and\ncarrying them around as instance fields, take them as arguments to the\nactual time consuming operations we need to run.\n\nChange-Id: I2b230d07e277de029b1061c807e67de5428cc1c4\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
          "commitDate": "2010/6/29 上午2:47",
          "commitName": "6b62e53b607630b6c00411741972838ced552f4d",
          "commitAuthor": "Shawn O. Pearce",
          "commitDateOld": "2010/6/29 上午2:47",
          "commitNameOld": "f288c27e465a91e80b53c4100c0d9b2f2341a9aa",
          "commitAuthorOld": "Shawn O. Pearce",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o);\n        countingMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o);\n        countingMonitor.update(1);\n    }\n    countingMonitor.endTask();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
          "functionStartLine": 768,
          "functionName": "findObjectsToPack",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,13 +1,13 @@\n-private void findObjectsToPack(final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n-    initMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n+private void findObjectsToPack(final ProgressMonitor countingMonitor, final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+    countingMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n     RevObject o;\n     while ((o \u003d walker.next()) !\u003d null) {\n         addObject(o);\n-        initMonitor.update(1);\n+        countingMonitor.update(1);\n     }\n     while ((o \u003d walker.nextObject()) !\u003d null) {\n         addObject(o);\n-        initMonitor.update(1);\n+        countingMonitor.update(1);\n     }\n-    initMonitor.endTask();\n+    countingMonitor.endTask();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066": {
      "type": "Yfilerename",
      "commitMessage": "Move PackWriter over to storage.pack.PackWriter\n\nSimilar to what we did with the file code, move the pack writer\ninto its own package so the related classes and their package\nprivate methods are hidden from the rest of the library.\n\nChange-Id: Ic1b5c7c8c8d266e90c910d8d68dfc8e93586854f\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/6/27 上午9:51",
      "commitName": "ea21c111cb7ac0c8dc39c4df3fe90c08ddcce066",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/6/27 上午9:50",
      "commitNameOld": "71aace52f7bfc36c65c92ab54c6f020dffc873ab",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private void findObjectsToPack(final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    initMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o);\n        initMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o);\n        initMonitor.update(1);\n    }\n    initMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java",
      "functionStartLine": 779,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
        "newPath": "org.eclipse.jgit/src/org/eclipse/jgit/storage/pack/PackWriter.java"
      }
    },
    "1a6964c8274c50f0253db75f010d78ef0e739343": {
      "type": "Yintroduced",
      "commitMessage": "Initial JGit contribution to eclipse.org\n\nPer CQ 3448 this is the initial contribution of the JGit project\nto eclipse.org.  It is derived from the historical JGit repository\nat commit 3a2dd9921c8a08740a9e02c421469e5b1a9e47cb.\n\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2009/9/30 上午7:47",
      "commitName": "1a6964c8274c50f0253db75f010d78ef0e739343",
      "commitAuthor": "Git Development Community",
      "diff": "@@ -0,0 +1,13 @@\n+private void findObjectsToPack(final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n+    initMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n+    RevObject o;\n+    while ((o \u003d walker.next()) !\u003d null) {\n+        addObject(o);\n+        initMonitor.update(1);\n+    }\n+    while ((o \u003d walker.nextObject()) !\u003d null) {\n+        addObject(o);\n+        initMonitor.update(1);\n+    }\n+    initMonitor.endTask();\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void findObjectsToPack(final ObjectWalk walker) throws MissingObjectException, IncorrectObjectTypeException, IOException {\n    initMonitor.beginTask(COUNTING_OBJECTS_PROGRESS, ProgressMonitor.UNKNOWN);\n    RevObject o;\n    while ((o \u003d walker.next()) !\u003d null) {\n        addObject(o);\n        initMonitor.update(1);\n    }\n    while ((o \u003d walker.nextObject()) !\u003d null) {\n        addObject(o);\n        initMonitor.update(1);\n    }\n    initMonitor.endTask();\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/lib/PackWriter.java",
      "functionStartLine": 856,
      "functionName": "findObjectsToPack",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}