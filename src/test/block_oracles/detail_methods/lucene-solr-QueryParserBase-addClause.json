{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/lucene-solr/.git",
  "startCommitName": "38bf976cd4b9e324c21664bd7ae3d554df803705",
  "sourceFileName": "QueryParserBase.java",
  "functionName": "addClause",
  "functionId": "addClause___clauses-List__BooleanClause____conj-int__mods-int__q-Query",
  "sourceFilePath": "lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 374,
  "functionEndLine": 422,
  "numCommitsSeen": 276,
  "timeTaken": 3830,
  "changeHistory": [
    "4aafacfbef423a25a349dd8c6e5e6178ac1ba334",
    "e8e4245d9b36123446546ff15967ac95429ea2b0",
    "5f30bedccc3f8a2ed14df05e3207ef9ed56965b2",
    "8b4c80f04b4255b6f1f7309ffb01ccbea6db029b",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
    "649a0e83a47185fd5771e7d7492462d646789a80",
    "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b",
    "1bbfaa54451f5654abd9c5976c865dae47d83cb4",
    "197ad763d1a6320b60dfd21a5bfb13fa71144afa",
    "dfeed0220e6c4aa0c3a25157ce411ce25782a3f8",
    "f6c12e189a8bcb0291b70d6272ec81acc3f0fcc6",
    "2af2d858774f7391f13341b8f588e75287868237"
  ],
  "changeHistoryShort": {
    "4aafacfbef423a25a349dd8c6e5e6178ac1ba334": "Ybodychange",
    "e8e4245d9b36123446546ff15967ac95429ea2b0": "Yfilerename",
    "5f30bedccc3f8a2ed14df05e3207ef9ed56965b2": "Yfilerename",
    "8b4c80f04b4255b6f1f7309ffb01ccbea6db029b": "Ymovefromfile",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": "Yfilerename",
    "649a0e83a47185fd5771e7d7492462d646789a80": "Ymultichange(Yparameterchange,Ybodychange)",
    "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b": "Ymultichange(Yparameterchange,Ybodychange)",
    "1bbfaa54451f5654abd9c5976c865dae47d83cb4": "Ybodychange",
    "197ad763d1a6320b60dfd21a5bfb13fa71144afa": "Ybodychange",
    "dfeed0220e6c4aa0c3a25157ce411ce25782a3f8": "Ybodychange",
    "f6c12e189a8bcb0291b70d6272ec81acc3f0fcc6": "Ybodychange",
    "2af2d858774f7391f13341b8f588e75287868237": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4aafacfbef423a25a349dd8c6e5e6178ac1ba334": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-6570: Make BooleanQuery immutable.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1686145 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/6/18 下午3:14",
      "commitName": "4aafacfbef423a25a349dd8c6e5e6178ac1ba334",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": "2015/6/16 下午6:18",
      "commitNameOld": "c397fe723462cfe4069304fe3b3bcea648217060",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 1.87,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.MUST));\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.SHOULD));\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java",
      "functionStartLine": 418,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,33 @@\n protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n         BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n-            c.setOccur(BooleanClause.Occur.MUST);\n+            clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.MUST));\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n         BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n-            c.setOccur(BooleanClause.Occur.SHOULD);\n+            clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.SHOULD));\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e8e4245d9b36123446546ff15967ac95429ea2b0": {
      "type": "Yfilerename",
      "commitMessage": "LUCENE-3965: consolidate all api modules and fix packaging for 4.0\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1327094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/4/17 下午9:36",
      "commitName": "e8e4245d9b36123446546ff15967ac95429ea2b0",
      "commitAuthor": "Robert Muir",
      "commitDateOld": "2012/4/17 下午8:03",
      "commitNameOld": "0daa4b0aac1748bbb2c56547626e9f49e7fb4ed6",
      "commitAuthorOld": "Sami Siren",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java",
      "functionStartLine": 409,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java",
        "newPath": "lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java"
      }
    },
    "5f30bedccc3f8a2ed14df05e3207ef9ed56965b2": {
      "type": "Yfilerename",
      "commitMessage": "LUCENE-3283: Moved core QueryParsers to queryparser module\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1145016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/7/11 上午11:37",
      "commitName": "5f30bedccc3f8a2ed14df05e3207ef9ed56965b2",
      "commitAuthor": "Christopher John Male",
      "commitDateOld": "2011/7/11 上午9:11",
      "commitNameOld": "ef25bf2d31a5e462ad6a752919481e2a7d1e2bd2",
      "commitAuthorOld": "Steven Rowe",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java",
      "functionStartLine": 411,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java",
        "newPath": "modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java"
      }
    },
    "8b4c80f04b4255b6f1f7309ffb01ccbea6db029b": {
      "type": "Ymovefromfile",
      "commitMessage": "LUCENE-2718: pull java code out of the QP .jj\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1026331 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/10/22 下午10:04",
      "commitName": "8b4c80f04b4255b6f1f7309ffb01ccbea6db029b",
      "commitAuthor": "Yonik Seeley",
      "commitDateOld": "2010/10/22 下午9:31",
      "commitNameOld": "e999b25d05c8fa7403d8c9e48fb042e087f6b95e",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java",
      "functionStartLine": 438,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "lucene/src/java/org/apache/lucene/queryParser/QueryParser.java",
        "newPath": "lucene/src/java/org/apache/lucene/queryParser/QueryParserBase.java",
        "oldMethodName": "addClause",
        "newMethodName": "addClause"
      }
    },
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": {
      "type": "Yfilerename",
      "commitMessage": "SVN-GIT conversion, path copy emulation.\n",
      "commitDate": "2016/1/23 上午8:18",
      "commitName": "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
      "commitAuthor": "Dawid Weiss",
      "commitDateOld": "2010/3/17 下午10:57",
      "commitNameOld": "2e5c6cdadc820220f8cb86e1b6e215da941649f9",
      "commitAuthorOld": "Uwe Schindler",
      "daysBetweenCommits": 2137.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "lucene/src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 459,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/lucene/queryParser/QueryParser.java",
        "newPath": "lucene/src/java/org/apache/lucene/queryParser/QueryParser.java"
      }
    },
    "649a0e83a47185fd5771e7d7492462d646789a80": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove deprecations from QueryParser and generify (LUCENE-1257) QueryParser\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@827717 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/10/21 上午12:06",
      "commitName": "649a0e83a47185fd5771e7d7492462d646789a80",
      "commitAuthor": "Uwe Schindler",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove deprecations from QueryParser and generify (LUCENE-1257) QueryParser\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@827717 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/10/21 上午12:06",
          "commitName": "649a0e83a47185fd5771e7d7492462d646789a80",
          "commitAuthor": "Uwe Schindler",
          "commitDateOld": "2009/10/19 上午7:21",
          "commitNameOld": "3645281a5db9e18e06387781fb5630ceb2a91f62",
          "commitAuthorOld": "Uwe Schindler",
          "daysBetweenCommits": 1.7,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
          "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
          "functionStartLine": 453,
          "functionName": "addClause",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,33 @@\n-protected void addClause(List clauses, int conj, int mods, Query q) {\n+protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n-        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n+        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n-        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n+        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[clauses-List, conj-int, mods-int, q-Query]",
            "newValue": "[clauses-List\u003cBooleanClause\u003e, conj-int, mods-int, q-Query]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove deprecations from QueryParser and generify (LUCENE-1257) QueryParser\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@827717 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2009/10/21 上午12:06",
          "commitName": "649a0e83a47185fd5771e7d7492462d646789a80",
          "commitAuthor": "Uwe Schindler",
          "commitDateOld": "2009/10/19 上午7:21",
          "commitNameOld": "3645281a5db9e18e06387781fb5630ceb2a91f62",
          "commitAuthorOld": "Uwe Schindler",
          "daysBetweenCommits": 1.7,
          "commitsBetweenForRepo": 9,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
          "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
          "functionStartLine": 453,
          "functionName": "addClause",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,33 @@\n-protected void addClause(List clauses, int conj, int mods, Query q) {\n+protected void addClause(List\u003cBooleanClause\u003e clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n-        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n+        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n-        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n+        BooleanClause c \u003d clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n         clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "LUCENE-1369: switch from Hashtable to HashMap and from Vector to List, when possible\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@692921 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/9/8 上午3:22",
      "commitName": "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b",
      "commitAuthor": "Michael McCandless",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "LUCENE-1369: switch from Hashtable to HashMap and from Vector to List, when possible\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@692921 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2008/9/8 上午3:22",
          "commitName": "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b",
          "commitAuthor": "Michael McCandless",
          "commitDateOld": "2008/8/31 上午1:12",
          "commitNameOld": "1bbfaa54451f5654abd9c5976c865dae47d83cb4",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 8.09,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void addClause(List clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
          "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
          "functionStartLine": 421,
          "functionName": "addClause",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,33 @@\n-protected void addClause(Vector clauses, int conj, int mods, Query q) {\n+protected void addClause(List clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n-        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n-        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[clauses-Vector, conj-int, mods-int, q-Query]",
            "newValue": "[clauses-List, conj-int, mods-int, q-Query]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LUCENE-1369: switch from Hashtable to HashMap and from Vector to List, when possible\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@692921 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2008/9/8 上午3:22",
          "commitName": "d5a40278bc39ec0c4f300d68c9f5bd4be0fea85b",
          "commitAuthor": "Michael McCandless",
          "commitDateOld": "2008/8/31 上午1:12",
          "commitNameOld": "1bbfaa54451f5654abd9c5976c865dae47d83cb4",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 8.09,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void addClause(List clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
          "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
          "functionStartLine": 421,
          "functionName": "addClause",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,33 +1,33 @@\n-protected void addClause(Vector clauses, int conj, int mods, Query q) {\n+protected void addClause(List clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n-        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n-        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        BooleanClause c \u003d (BooleanClause) clauses.get(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n-        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n+        clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "1bbfaa54451f5654abd9c5976c865dae47d83cb4": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-1061: make it simpler to override concrete Query implementations created by QueryParser by factoring out protected newXXXQuery() methods\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@690535 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2008/8/31 上午1:12",
      "commitName": "1bbfaa54451f5654abd9c5976c865dae47d83cb4",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2008/8/20 下午10:38",
      "commitNameOld": "bb6b7117186b656b4777850fdc463e0eaa541130",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 10.11,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(Vector clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 415,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,33 @@\n protected void addClause(Vector clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n-        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n+        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n-        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n+        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n-        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n+        clauses.addElement(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "197ad763d1a6320b60dfd21a5bfb13fa71144afa": {
      "type": "Ybodychange",
      "commitMessage": "get/setOperator becomes get/setDefaultOperator and its parameter is now typsafe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@150668 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/11/24 上午7:13",
      "commitName": "197ad763d1a6320b60dfd21a5bfb13fa71144afa",
      "commitAuthor": "Daniel Naber",
      "commitDateOld": "2004/11/13 下午11:11",
      "commitNameOld": "f8d0d0b140defd38f9fe15710f61b53a2a531a49",
      "commitAuthorOld": "Daniel Naber",
      "daysBetweenCommits": 10.33,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(Vector clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d OR_OPERATOR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 273,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,33 @@\n protected void addClause(Vector clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n-    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n+    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d AND_OPERATOR \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n-    if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n+    if (operator \u003d\u003d OR_OPERATOR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dfeed0220e6c4aa0c3a25157ce411ce25782a3f8": {
      "type": "Ybodychange",
      "commitMessage": "Fix ArrayIndexOutOfBoundsExceptions\nThis patch is common to several patches\nfor QueryParser see e.g. Bug 9110 and it cannot have any\nnegative side effects.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@150498 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/9/8 下午9:31",
      "commitName": "dfeed0220e6c4aa0c3a25157ce411ce25782a3f8",
      "commitAuthor": "Christoph Goller",
      "commitDateOld": "2004/9/4 上午5:12",
      "commitNameOld": "f085bc15f589345f3fba62b13d9a1eae2aff70c7",
      "commitAuthorOld": "Daniel Naber",
      "daysBetweenCommits": 4.68,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(Vector clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 175,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,33 @@\n protected void addClause(Vector clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n-    if (conj \u003d\u003d CONJ_AND) {\n+    if (clauses.size() \u003e 0 \u0026\u0026 conj \u003d\u003d CONJ_AND) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.MUST);\n     }\n-    if (operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n+    if (clauses.size() \u003e 0 \u0026\u0026 operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n         if (!c.isProhibited())\n             c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n     if (required \u0026\u0026 !prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n     else if (!required \u0026\u0026 !prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n     else if (!required \u0026\u0026 prohibited)\n         clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n     else\n         throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f6c12e189a8bcb0291b70d6272ec81acc3f0fcc6": {
      "type": "Ybodychange",
      "commitMessage": "don\u0027t use the deprecated API for BooleanQuery.add()\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@150461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2004/8/28 上午5:50",
      "commitName": "f6c12e189a8bcb0291b70d6272ec81acc3f0fcc6",
      "commitAuthor": "Daniel Naber",
      "commitDateOld": "2004/5/23 上午1:34",
      "commitNameOld": "ee00e19246fa777e891202422a22316445585210",
      "commitAuthorOld": "Erik Hatcher",
      "daysBetweenCommits": 97.18,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void addClause(Vector clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.MUST);\n    }\n    if (operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.isProhibited())\n            c.setOccur(BooleanClause.Occur.SHOULD);\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    if (required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n    else if (!required \u0026\u0026 !prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n    else if (!required \u0026\u0026 prohibited)\n        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n    else\n        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n}",
      "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 175,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,26 +1,33 @@\n protected void addClause(Vector clauses, int conj, int mods, Query q) {\n     boolean required, prohibited;\n     if (conj \u003d\u003d CONJ_AND) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n-        if (!c.prohibited)\n-            c.required \u003d true;\n+        if (!c.isProhibited())\n+            c.setOccur(BooleanClause.Occur.MUST);\n     }\n     if (operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n         BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n-        if (!c.prohibited)\n-            c.required \u003d false;\n+        if (!c.isProhibited())\n+            c.setOccur(BooleanClause.Occur.SHOULD);\n     }\n     if (q \u003d\u003d null)\n         return;\n     if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (mods \u003d\u003d MOD_REQ);\n         if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n             required \u003d true;\n         }\n     } else {\n         prohibited \u003d (mods \u003d\u003d MOD_NOT);\n         required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n     }\n-    clauses.addElement(new BooleanClause(q, required, prohibited));\n+    if (required \u0026\u0026 !prohibited)\n+        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST));\n+    else if (!required \u0026\u0026 !prohibited)\n+        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.SHOULD));\n+    else if (!required \u0026\u0026 prohibited)\n+        clauses.addElement(new BooleanClause(q, BooleanClause.Occur.MUST_NOT));\n+    else\n+        throw new RuntimeException(\"Clause cannot be both required and prohibited\");\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2af2d858774f7391f13341b8f588e75287868237": {
      "type": "Yintroduced",
      "commitMessage": "PR 19468, but not exactly as it was done in the provided patches.  JavaCC is no longer required to build Lucene, but can be run optionally\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@150017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/9/11 上午9:51",
      "commitName": "2af2d858774f7391f13341b8f588e75287868237",
      "commitAuthor": "Erik Hatcher",
      "diff": "@@ -0,0 +1,26 @@\n+protected void addClause(Vector clauses, int conj, int mods, Query q) {\n+    boolean required, prohibited;\n+    if (conj \u003d\u003d CONJ_AND) {\n+        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        if (!c.prohibited)\n+            c.required \u003d true;\n+    }\n+    if (operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n+        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n+        if (!c.prohibited)\n+            c.required \u003d false;\n+    }\n+    if (q \u003d\u003d null)\n+        return;\n+    if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n+        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n+        required \u003d (mods \u003d\u003d MOD_REQ);\n+        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n+            required \u003d true;\n+        }\n+    } else {\n+        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n+        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n+    }\n+    clauses.addElement(new BooleanClause(q, required, prohibited));\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected void addClause(Vector clauses, int conj, int mods, Query q) {\n    boolean required, prohibited;\n    if (conj \u003d\u003d CONJ_AND) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.prohibited)\n            c.required \u003d true;\n    }\n    if (operator \u003d\u003d DEFAULT_OPERATOR_AND \u0026\u0026 conj \u003d\u003d CONJ_OR) {\n        BooleanClause c \u003d (BooleanClause) clauses.elementAt(clauses.size() - 1);\n        if (!c.prohibited)\n            c.required \u003d false;\n    }\n    if (q \u003d\u003d null)\n        return;\n    if (operator \u003d\u003d DEFAULT_OPERATOR_OR) {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (mods \u003d\u003d MOD_REQ);\n        if (conj \u003d\u003d CONJ_AND \u0026\u0026 !prohibited) {\n            required \u003d true;\n        }\n    } else {\n        prohibited \u003d (mods \u003d\u003d MOD_NOT);\n        required \u003d (!prohibited \u0026\u0026 conj !\u003d CONJ_OR);\n    }\n    clauses.addElement(new BooleanClause(q, required, prohibited));\n}",
      "path": "src/java/org/apache/lucene/queryParser/QueryParser.java",
      "functionStartLine": 155,
      "functionName": "addClause",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}