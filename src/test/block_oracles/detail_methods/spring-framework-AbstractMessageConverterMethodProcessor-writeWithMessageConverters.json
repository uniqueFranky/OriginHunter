{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "AbstractMessageConverterMethodProcessor.java",
  "functionName": "writeWithMessageConverters",
  "functionId": "writeWithMessageConverters___value-T(annotations-@Nullable)__returnType-MethodParameter__inputMessage-ServletServerHttpRequest__outputMessage-ServletServerHttpResponse",
  "sourceFilePath": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
  "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
  "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
  "functionStartLine": 179,
  "functionEndLine": 307,
  "numCommitsSeen": 112,
  "timeTaken": 9771,
  "changeHistory": [
    "29ce6685cad0f6caf829c49024b1885ab31d62e0",
    "0be8c20fca26357aa61c28dec2f3720f1d7488be",
    "b915e42c387195ed956fd908602094139148aac3",
    "818e4b077640056d6e65ef37be1bec76537fa991",
    "900bc8a2e341277296a463c7b5db4abb944e14d7",
    "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
    "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c",
    "fda08852ba9f5d52c149209382c0d03380de413c",
    "9a894ab61e4613af176029761b75d7ad2a733440",
    "582014e944002609b562f6e4998935c06bbe6922",
    "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "39f8bd663ee944d92ecd8b1e33b5315807419c94",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "b204437cef0976f5af0e1c5290e77e266b306a51",
    "7756feacd877093ad925d222c8bb911b6bb7c381",
    "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
    "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543",
    "667fc7e4a9d9daf15110339af3659404ace6adba",
    "d83735694eff6919434e8a4557cfb6dc66e5175d",
    "289f35da3a57bb5e491b30c7351072b4e801c519",
    "31a5434ea433bdec2283797bf9415c02bb2f41c1",
    "8d7812b1b6c47c3edef1332639cb57b92327ec46",
    "0556ed4f161cddf992cc49960ba0181a564a8667",
    "c5e360d886931f761c2be5ff4b31d5df2042d415",
    "8cce40469631327e0afdd5d41393248313819270",
    "a9b2a12491aa2259851b93824b7e560b3dbd1902",
    "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
    "2655c507e041fb3c245d550b33ba7f1b21fc341e",
    "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
    "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
    "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
    "ec7d80b8519332ffb5f0595dddc9ef52de532730",
    "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
    "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d",
    "f05e2bc56f8e03466977d73a5e99c37651248803",
    "982cb2f258a5be1173115044d379f54702dc8c5b",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54",
    "c5833b192e3f3a280f8c63a9c45ca96776415a6b",
    "5fa7f24794cc23cd0a803d8d49024d34f7df328b",
    "1eaca6572091c014379e453299773e880a7766b9",
    "af1dfd357743e6f4d5b9589ddb584f472a699e41",
    "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
    "ad2e0d45875651d9a707b514dd3966fa81a9048c",
    "acc75aa4b898a34dce42748df5b54624f8b3e9f2"
  ],
  "changeHistoryShort": {
    "29ce6685cad0f6caf829c49024b1885ab31d62e0": "Ybodychange",
    "0be8c20fca26357aa61c28dec2f3720f1d7488be": "Ybodychange",
    "b915e42c387195ed956fd908602094139148aac3": "Ybodychange",
    "818e4b077640056d6e65ef37be1bec76537fa991": "Ybodychange",
    "900bc8a2e341277296a463c7b5db4abb944e14d7": "Ybodychange",
    "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5": "Ybodychange",
    "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c": "Ybodychange",
    "fda08852ba9f5d52c149209382c0d03380de413c": "Ybodychange",
    "9a894ab61e4613af176029761b75d7ad2a733440": "Ybodychange",
    "582014e944002609b562f6e4998935c06bbe6922": "Ybodychange",
    "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9": "Ymultichange(Ybodychange,Yannotationchange)",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ymultichange(Ybodychange,Yparametermetachange)",
    "39f8bd663ee944d92ecd8b1e33b5315807419c94": "Ydocchange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "b204437cef0976f5af0e1c5290e77e266b306a51": "Ybodychange",
    "7756feacd877093ad925d222c8bb911b6bb7c381": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "1291d6e1bd5ba6524c3fb68813aad807d123c2e1": "Ybodychange",
    "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543": "Ybodychange",
    "667fc7e4a9d9daf15110339af3659404ace6adba": "Ybodychange",
    "d83735694eff6919434e8a4557cfb6dc66e5175d": "Yexceptionschange",
    "289f35da3a57bb5e491b30c7351072b4e801c519": "Ybodychange",
    "31a5434ea433bdec2283797bf9415c02bb2f41c1": "Ybodychange",
    "8d7812b1b6c47c3edef1332639cb57b92327ec46": "Ybodychange",
    "0556ed4f161cddf992cc49960ba0181a564a8667": "Ybodychange",
    "c5e360d886931f761c2be5ff4b31d5df2042d415": "Ybodychange",
    "8cce40469631327e0afdd5d41393248313819270": "Ybodychange",
    "a9b2a12491aa2259851b93824b7e560b3dbd1902": "Ybodychange",
    "c9d0ebd730953ef693edf275b57cfeeb9bf15af9": "Ybodychange",
    "2655c507e041fb3c245d550b33ba7f1b21fc341e": "Ybodychange",
    "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096": "Ybodychange",
    "96b18c8dc22c0c57605a594b21ceec84ec16ee37": "Ybodychange",
    "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2": "Ybodychange",
    "ec7d80b8519332ffb5f0595dddc9ef52de532730": "Ybodychange",
    "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa": "Ybodychange",
    "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d": "Ybodychange",
    "f05e2bc56f8e03466977d73a5e99c37651248803": "Ybodychange",
    "982cb2f258a5be1173115044d379f54702dc8c5b": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54": "Yfilerename",
    "c5833b192e3f3a280f8c63a9c45ca96776415a6b": "Ybodychange",
    "5fa7f24794cc23cd0a803d8d49024d34f7df328b": "Ybodychange",
    "1eaca6572091c014379e453299773e880a7766b9": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "af1dfd357743e6f4d5b9589ddb584f472a699e41": "Ymultichange(Yparameterchange,Ybodychange)",
    "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235": "Ybodychange",
    "ad2e0d45875651d9a707b514dd3966fa81a9048c": "Ymultichange(Yparameterchange,Ybodychange)",
    "acc75aa4b898a34dce42748df5b54624f8b3e9f2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "29ce6685cad0f6caf829c49024b1885ab31d62e0": {
      "type": "Ybodychange",
      "commitMessage": "Add handleFailure property to FrameworkServlet\n\nIssue: SPR-17100\n",
      "commitDate": "2018/8/2 上午5:49",
      "commitName": "29ce6685cad0f6caf829c49024b1885ab31d62e0",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2018/7/25 上午8:47",
      "commitNameOld": "0be8c20fca26357aa61c28dec2f3720f1d7488be",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 7.88,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        targetType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                targetType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    MediaType selectedMediaType \u003d null;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n        }\n        selectedMediaType \u003d contentType;\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e acceptableTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n        if (body !\u003d null \u0026\u0026 producibleTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        List\u003cMediaType\u003e mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : acceptableTypes) {\n            for (MediaType producibleType : producibleTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n        for (MediaType mediaType : mediaTypesToUse) {\n            if (mediaType.isConcrete()) {\n                selectedMediaType \u003d mediaType;\n                break;\n            } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n                selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n                break;\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027, given \" + acceptableTypes + \" and supported \" + producibleTypes);\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Writing [\" + formatValue(body) + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 179,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,105 +1,104 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object body;\n     Class\u003c?\u003e valueType;\n     Type targetType;\n     if (value instanceof CharSequence) {\n         body \u003d value.toString();\n         valueType \u003d String.class;\n         targetType \u003d String.class;\n     } else {\n         body \u003d value;\n         valueType \u003d getReturnValueType(body, returnType);\n         targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d body.getClass();\n                 targetType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     MediaType selectedMediaType \u003d null;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n         }\n         selectedMediaType \u003d contentType;\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e acceptableTypes \u003d getAcceptableMediaTypes(request);\n         List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n         if (body !\u003d null \u0026\u0026 producibleTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         List\u003cMediaType\u003e mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : acceptableTypes) {\n             for (MediaType producibleType : producibleTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n         if (mediaTypesToUse.isEmpty()) {\n             if (body !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n             }\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n         for (MediaType mediaType : mediaTypesToUse) {\n             if (mediaType.isConcrete()) {\n                 selectedMediaType \u003d mediaType;\n                 break;\n             } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n                 selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n                 break;\n             }\n         }\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027, given \" + acceptableTypes + \" and supported \" + producibleTypes);\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (body !\u003d null) {\n                     if (logger.isDebugEnabled()) {\n-                        Object formatted \u003d (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n-                        logger.debug(\"Writing [\" + formatted + \"]\");\n+                        logger.debug(\"Writing [\" + formatValue(body) + \"]\");\n                     }\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n                 } else {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Nothing to write: null body\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0be8c20fca26357aa61c28dec2f3720f1d7488be": {
      "type": "Ybodychange",
      "commitMessage": "Consistent logging of selected media types\n",
      "commitDate": "2018/7/25 上午8:47",
      "commitName": "0be8c20fca26357aa61c28dec2f3720f1d7488be",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2018/7/17 上午1:45",
      "commitNameOld": "b915e42c387195ed956fd908602094139148aac3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.29,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        targetType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                targetType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    MediaType selectedMediaType \u003d null;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n        }\n        selectedMediaType \u003d contentType;\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e acceptableTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n        if (body !\u003d null \u0026\u0026 producibleTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        List\u003cMediaType\u003e mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : acceptableTypes) {\n            for (MediaType producibleType : producibleTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n        for (MediaType mediaType : mediaTypesToUse) {\n            if (mediaType.isConcrete()) {\n                selectedMediaType \u003d mediaType;\n                break;\n            } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n                selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n                break;\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027, given \" + acceptableTypes + \" and supported \" + producibleTypes);\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted \u003d (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 179,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,106 +1,105 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object body;\n     Class\u003c?\u003e valueType;\n     Type targetType;\n     if (value instanceof CharSequence) {\n         body \u003d value.toString();\n         valueType \u003d String.class;\n         targetType \u003d String.class;\n     } else {\n         body \u003d value;\n         valueType \u003d getReturnValueType(body, returnType);\n         targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d body.getClass();\n                 targetType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n-    List\u003cMediaType\u003e mediaTypesToUse;\n+    MediaType selectedMediaType \u003d null;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n         }\n-        mediaTypesToUse \u003d Collections.singletonList(contentType);\n+        selectedMediaType \u003d contentType;\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n-        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n-        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n-        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        List\u003cMediaType\u003e acceptableTypes \u003d getAcceptableMediaTypes(request);\n+        List\u003cMediaType\u003e producibleTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n+        if (body !\u003d null \u0026\u0026 producibleTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n-        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n-        for (MediaType requestedType : requestedMediaTypes) {\n-            for (MediaType producibleType : producibleMediaTypes) {\n+        List\u003cMediaType\u003e mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n+        for (MediaType requestedType : acceptableTypes) {\n+            for (MediaType producibleType : producibleTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n-        }\n         if (mediaTypesToUse.isEmpty()) {\n             if (body !\u003d null) {\n-                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+                throw new HttpMediaTypeNotAcceptableException(producibleTypes);\n+            }\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No match for \" + acceptableTypes + \", supported: \" + producibleTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n-    }\n-    MediaType selectedMediaType \u003d null;\n-    for (MediaType mediaType : mediaTypesToUse) {\n-        if (mediaType.isConcrete()) {\n-            selectedMediaType \u003d mediaType;\n-            break;\n-        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n-            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n-            break;\n+        for (MediaType mediaType : mediaTypesToUse) {\n+            if (mediaType.isConcrete()) {\n+                selectedMediaType \u003d mediaType;\n+                break;\n+            } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+                selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+                break;\n+            }\n         }\n-    }\n-    if (logger.isDebugEnabled()) {\n-        logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027, given \" + acceptableTypes + \" and supported \" + producibleTypes);\n+        }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (body !\u003d null) {\n                     if (logger.isDebugEnabled()) {\n                         Object formatted \u003d (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                         logger.debug(\"Writing [\" + formatted + \"]\");\n                     }\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n                 } else {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Nothing to write: null body\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b915e42c387195ed956fd908602094139148aac3": {
      "type": "Ybodychange",
      "commitMessage": "Resolve target type for GenericHttpMessageConverter.canWrite/write\n\nIssue: SPR-16877\n",
      "commitDate": "2018/7/17 上午1:45",
      "commitName": "b915e42c387195ed956fd908602094139148aac3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/7/10 下午6:11",
      "commitNameOld": "818e4b077640056d6e65ef37be1bec76537fa991",
      "commitAuthorOld": "Brian Clozel",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type targetType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        targetType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                targetType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n        }\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted \u003d (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 179,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,106 +1,106 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object body;\n     Class\u003c?\u003e valueType;\n-    Type declaredType;\n+    Type targetType;\n     if (value instanceof CharSequence) {\n         body \u003d value.toString();\n         valueType \u003d String.class;\n-        declaredType \u003d String.class;\n+        targetType \u003d String.class;\n     } else {\n         body \u003d value;\n         valueType \u003d getReturnValueType(body, returnType);\n-        declaredType \u003d getGenericType(returnType);\n+        targetType \u003d GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d body.getClass();\n-                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n+                targetType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n         }\n         mediaTypesToUse \u003d Collections.singletonList(contentType);\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n-        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n+        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, targetType);\n         if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : requestedMediaTypes) {\n             for (MediaType producibleType : producibleMediaTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n         }\n         if (mediaTypesToUse.isEmpty()) {\n             if (body !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (logger.isDebugEnabled()) {\n         logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n-            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n+            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (body !\u003d null) {\n                     if (logger.isDebugEnabled()) {\n-                        Object formatted \u003d body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n+                        Object formatted \u003d (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body);\n                         logger.debug(\"Writing [\" + formatted + \"]\");\n                     }\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n-                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n+                        genericConverter.write(body, targetType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n                 } else {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Nothing to write: null body\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "818e4b077640056d6e65ef37be1bec76537fa991": {
      "type": "Ybodychange",
      "commitMessage": "Refine Content-Range support for Resources\n\nThis commit restricts the support of `\"Content-Range\"` when returning\n`Resource` instances from Controllers - now only \"HTTP 200 OK\" responses\nwill be considered, as Controllers might want to handle content range\nthemselves.\n\nIssue: SPR-16921\n",
      "commitDate": "2018/7/10 下午6:11",
      "commitName": "818e4b077640056d6e65ef37be1bec76537fa991",
      "commitAuthor": "Brian Clozel",
      "commitDateOld": "2018/6/28 下午4:28",
      "commitNameOld": "e0480f75ac4e0367a053eabd3a07c3fa34eccf61",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n        }\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted \u003d body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 177,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,106 +1,106 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object body;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         body \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         body \u003d value;\n         valueType \u003d getReturnValueType(body, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n-        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n+        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null \u0026\u0026 outputMessage.getServletResponse().getStatus() \u003d\u003d 200) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d body.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n         }\n         mediaTypesToUse \u003d Collections.singletonList(contentType);\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n         List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n         if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : requestedMediaTypes) {\n             for (MediaType producibleType : producibleMediaTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n         if (logger.isDebugEnabled()) {\n             logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n         }\n         if (mediaTypesToUse.isEmpty()) {\n             if (body !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (logger.isDebugEnabled()) {\n         logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (body !\u003d null) {\n                     if (logger.isDebugEnabled()) {\n                         Object formatted \u003d body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n                         logger.debug(\"Writing [\" + formatted + \"]\");\n                     }\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n                 } else {\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Nothing to write: null body\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "900bc8a2e341277296a463c7b5db4abb944e14d7": {
      "type": "Ybodychange",
      "commitMessage": "Logging improvements for WebFlux\n\nIssue: SPR-16898\n",
      "commitDate": "2018/6/23 上午10:44",
      "commitName": "900bc8a2e341277296a463c7b5db4abb944e14d7",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2018/6/19 上午6:33",
      "commitNameOld": "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.17,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n        }\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    if (logger.isDebugEnabled()) {\n                        Object formatted \u003d body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n                        logger.debug(\"Writing [\" + formatted + \"]\");\n                    }\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                } else {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Nothing to write: null body\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 176,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,92 +1,106 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object body;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         body \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         body \u003d value;\n         valueType \u003d getReturnValueType(body, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d body.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found \u0027Content-Type:\" + contentType + \"\u0027 in response\");\n+        }\n         mediaTypesToUse \u003d Collections.singletonList(contentType);\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n         List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n         if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : requestedMediaTypes) {\n             for (MediaType producibleType : producibleMediaTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"No match for \" + requestedMediaTypes + \", supported: \" + producibleMediaTypes);\n+        }\n         if (mediaTypesToUse.isEmpty()) {\n             if (body !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n+    if (logger.isDebugEnabled()) {\n+        logger.debug(\"Using \u0027\" + selectedMediaType + \"\u0027 given \" + mediaTypesToUse);\n+    }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (body !\u003d null) {\n+                    if (logger.isDebugEnabled()) {\n+                        Object formatted \u003d body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body;\n+                        logger.debug(\"Writing [\" + formatted + \"]\");\n+                    }\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n+                } else {\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" + \"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n+                        logger.debug(\"Nothing to write: null body\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5": {
      "type": "Ybodychange",
      "commitMessage": "Improve DEBUG/TRACE logging for Spring MVC\n\nIssue: SPR-16898\n",
      "commitDate": "2018/6/19 上午6:33",
      "commitName": "28a5c3009ea0c31f879c0bb8b9e6cfd33faa81e5",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2018/4/24 上午12:39",
      "commitNameOld": "e9a8a5065bf30826bc0209b6e4db472348e51ce0",
      "commitAuthorOld": "Brian Clozel",
      "daysBetweenCommits": 56.25,
      "commitsBetweenForRepo": 239,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object body;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        body \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        body \u003d value;\n        valueType \u003d getReturnValueType(body, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d body.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (body !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (body !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" + \"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (body !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 176,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,92 +1,92 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n-    Object outputValue;\n+    Object body;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n-        outputValue \u003d value.toString();\n+        body \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n-        outputValue \u003d value;\n-        valueType \u003d getReturnValueType(outputValue, returnType);\n+        body \u003d value;\n+        valueType \u003d getReturnValueType(body, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n-                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n-                valueType \u003d outputValue.getClass();\n+                body \u003d HttpRange.toResourceRegions(httpRanges, resource);\n+                valueType \u003d body.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         mediaTypesToUse \u003d Collections.singletonList(contentType);\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n         List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n-        if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        if (body !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : requestedMediaTypes) {\n             for (MediaType producibleType : producibleMediaTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n         if (mediaTypesToUse.isEmpty()) {\n-            if (outputValue !\u003d null) {\n+            if (body !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n-                outputValue \u003d getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n-                if (outputValue !\u003d null) {\n+                body \u003d getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n+                if (body !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n-                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n+                        genericConverter.write(body, declaredType, selectedMediaType, outputMessage);\n                     } else {\n-                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n+                        ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);\n                     }\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n+                        logger.debug(\"Written \\\"\" + selectedMediaType + \"\\\" from \" + \"[\" + (body instanceof CharSequence ? \"\\\"\" + body + \"\\\"\" : body) + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    if (outputValue !\u003d null) {\n+    if (body !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c": {
      "type": "Ybodychange",
      "commitMessage": "Clean up warnings in spring-webmvc\n",
      "commitDate": "2018/4/4 下午8:04",
      "commitName": "aba882af4c4f7d2ec6e0b859dbffc1bcf65e000c",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2018/3/28 上午4:54",
      "commitNameOld": "f3994467c4e1094f5229d05c5679550f956cba8e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 7.63,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d outputValue.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n        if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (outputValue !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 175,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,92 +1,92 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d outputValue.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n     if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n         mediaTypesToUse \u003d Collections.singletonList(contentType);\n     } else {\n         HttpServletRequest request \u003d inputMessage.getServletRequest();\n         List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n         List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n         if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n             throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n         }\n         mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n         for (MediaType requestedType : requestedMediaTypes) {\n             for (MediaType producibleType : producibleMediaTypes) {\n                 if (requestedType.isCompatibleWith(producibleType)) {\n                     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                 }\n             }\n         }\n         if (mediaTypesToUse.isEmpty()) {\n             if (outputValue !\u003d null) {\n                 throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n             }\n             return;\n         }\n         MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n-                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n+                outputValue \u003d getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                     }\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fda08852ba9f5d52c149209382c0d03380de413c": {
      "type": "Ybodychange",
      "commitMessage": "Take content-type from ResponseEntity unconditionally\n\nFrom #9a894a we began using the content-type from the ResponseEntity\nbut cross-checking it still against the requested content type.\n\nArguably there isn\u0027t any purpose in cross-checking. The only possible\noutcomes are: a) it\u0027s compatible or b) it\u0027s not, which would result in\n406 (NOT_ACCEPTABLE). As we\u0027ve been given explicitly the media type to\nuse, it makes little sense to send 406, ignoring the wish to use that\ncontent type.\n\nIssue: SPR-16251\n",
      "commitDate": "2017/12/2 下午1:43",
      "commitName": "fda08852ba9f5d52c149209382c0d03380de413c",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2017/11/11 上午4:05",
      "commitNameOld": "9a894ab61e4613af176029761b75d7ad2a733440",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 21.4,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d outputValue.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    List\u003cMediaType\u003e mediaTypesToUse;\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n        mediaTypesToUse \u003d Collections.singletonList(contentType);\n    } else {\n        HttpServletRequest request \u003d inputMessage.getServletRequest();\n        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n        if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n        }\n        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n        for (MediaType requestedType : requestedMediaTypes) {\n            for (MediaType producibleType : producibleMediaTypes) {\n                if (requestedType.isCompatibleWith(producibleType)) {\n                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n                }\n            }\n        }\n        if (mediaTypesToUse.isEmpty()) {\n            if (outputValue !\u003d null) {\n                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n            }\n            return;\n        }\n        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n    }\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypesToUse) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 175,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,88 +1,92 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d outputValue.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n-    HttpServletRequest request \u003d inputMessage.getServletRequest();\n-    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+    List\u003cMediaType\u003e mediaTypesToUse;\n     MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d (contentType !\u003d null \u0026\u0026 contentType.isConcrete() ? Collections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n-    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n-    }\n-    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n-    for (MediaType requestedType : requestedMediaTypes) {\n-        for (MediaType producibleType : producibleMediaTypes) {\n-            if (requestedType.isCompatibleWith(producibleType)) {\n-                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n+    if (contentType !\u003d null \u0026\u0026 contentType.isConcrete()) {\n+        mediaTypesToUse \u003d Collections.singletonList(contentType);\n+    } else {\n+        HttpServletRequest request \u003d inputMessage.getServletRequest();\n+        List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+        List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n+        if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+            throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n+        }\n+        mediaTypesToUse \u003d new ArrayList\u003c\u003e();\n+        for (MediaType requestedType : requestedMediaTypes) {\n+            for (MediaType producibleType : producibleMediaTypes) {\n+                if (requestedType.isCompatibleWith(producibleType)) {\n+                    mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));\n+                }\n             }\n         }\n-    }\n-    if (compatibleMediaTypes.isEmpty()) {\n-        if (outputValue !\u003d null) {\n-            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+        if (mediaTypesToUse.isEmpty()) {\n+            if (outputValue !\u003d null) {\n+                throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+            }\n+            return;\n         }\n-        return;\n+        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);\n     }\n-    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n-    MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n-    for (MediaType mediaType : mediaTypes) {\n+    for (MediaType mediaType : mediaTypesToUse) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                     }\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a894ab61e4613af176029761b75d7ad2a733440": {
      "type": "Ybodychange",
      "commitMessage": "Use ResponseEntity Content-Type as producible media type\n\nIssue: SPR-16172\n",
      "commitDate": "2017/11/11 上午4:05",
      "commitName": "9a894ab61e4613af176029761b75d7ad2a733440",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2017/10/21 上午4:42",
      "commitNameOld": "1cc5afe24b592a50ab68c090e438138ab180374a",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 20.97,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d outputValue.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n    List\u003cMediaType\u003e producibleMediaTypes \u003d (contentType !\u003d null \u0026\u0026 contentType.isConcrete() ? Collections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 176,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,87 +1,88 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     if (isResourceType(value, returnType)) {\n         outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n         if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n             Resource resource \u003d (Resource) value;\n             try {\n                 List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                 outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                 outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                 valueType \u003d outputValue.getClass();\n                 declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n             } catch (IllegalArgumentException ex) {\n                 outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                 outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n             }\n         }\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n+    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d (contentType !\u003d null \u0026\u0026 contentType.isConcrete() ? Collections.singletonList(contentType) : getProducibleMediaTypes(request, valueType, declaredType));\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                     }\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "582014e944002609b562f6e4998935c06bbe6922": {
      "type": "Ybodychange",
      "commitMessage": "Support HTTP range requests in MVC Controllers\n\nPrior to this commit, HTTP Range requests were only supported by the\nResourceHttpRequestHandler when serving static resources.\n\nThis commit improves the `HttpEntityMethodProcessor` and\nthe `RequestResponseBodyMethodProcessor`. They now extract\n`ResourceRegion`s from the `Resource` instance returned by the\nController and let the Resource-related message converters\nhandle the writing of the resource (including partial writes).\n\nController methods can now handle Range requests for\nreturn types that extend Resource or HttpEntity:\n\n    @RequestMapping(\"/example/video.mp4\")\n    public Resource handler() { }\n\n    @RequestMapping(\"/example/video.mp4\")\n    public HttpEntity\u003cResource\u003e handler() { }\n\nIssue: SPR-15789, SPR-13834\n",
      "commitDate": "2017/8/25 上午2:50",
      "commitName": "582014e944002609b562f6e4998935c06bbe6922",
      "commitAuthor": "Brian Clozel",
      "commitDateOld": "2017/6/13 下午5:37",
      "commitNameOld": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 72.38,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    if (isResourceType(value, returnType)) {\n        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n            Resource resource \u003d (Resource) value;\n            try {\n                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n                valueType \u003d outputValue.getClass();\n                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n            } catch (IllegalArgumentException ex) {\n                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n            }\n        }\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 176,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "@@ -1,71 +1,87 @@\n @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n+    if (isResourceType(value, returnType)) {\n+        outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, \"bytes\");\n+        if (value !\u003d null \u0026\u0026 inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) !\u003d null) {\n+            Resource resource \u003d (Resource) value;\n+            try {\n+                List\u003cHttpRange\u003e httpRanges \u003d inputMessage.getHeaders().getRange();\n+                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());\n+                outputValue \u003d HttpRange.toResourceRegions(httpRanges, resource);\n+                valueType \u003d outputValue.getClass();\n+                declaredType \u003d RESOURCE_REGION_LIST_TYPE;\n+            } catch (IllegalArgumentException ex) {\n+                outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, \"bytes */\" + resource.contentLength());\n+                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());\n+            }\n+        }\n+    }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n             GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n             if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     if (genericConverter !\u003d null) {\n                         genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                     } else {\n                         ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                     }\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Fixes for ignored tests after last week\u0027s nullability commit\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/13 下午5:37",
      "commitName": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fixes for ignored tests after last week\u0027s nullability commit\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/13 下午5:37",
          "commitName": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/9 上午4:52",
          "commitNameOld": "fd53d2a51a4de263ac18d2f698abeab7afabce75",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 4.53,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 168,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
          "diff": "@@ -1,78 +1,71 @@\n-@SuppressWarnings(\"unchecked\")\n+@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n-        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-            if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n-                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (outputValue !\u003d null) {\n-                        addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n-                        }\n-                    }\n-                    return;\n-                }\n-            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n-                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n+            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n+            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n+                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n+                    if (genericConverter !\u003d null) {\n+                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n+                    } else {\n+                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n+                    }\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Fixes for ignored tests after last week\u0027s nullability commit\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/13 下午5:37",
          "commitName": "7dd8dc62a5fa08e3cc99d2388ff62f5825151fb9",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/9 上午4:52",
          "commitNameOld": "fd53d2a51a4de263ac18d2f698abeab7afabce75",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 4.53,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    if (genericConverter !\u003d null) {\n                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 168,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
          "diff": "@@ -1,78 +1,71 @@\n-@SuppressWarnings(\"unchecked\")\n+@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n-        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-            if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n-                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (outputValue !\u003d null) {\n-                        addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n-                        }\n-                    }\n-                    return;\n-                }\n-            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n-                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+        for (HttpMessageConverter\u003c?\u003e converter : this.messageConverters) {\n+            GenericHttpMessageConverter genericConverter \u003d (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter\u003c?\u003e) converter : null);\n+            if (genericConverter !\u003d null ? ((GenericHttpMessageConverter) converter).canWrite(declaredType, valueType, selectedMediaType) : converter.canWrite(valueType, selectedMediaType)) {\n+                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) converter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n+                    if (genericConverter !\u003d null) {\n+                        genericConverter.write(outputValue, declaredType, selectedMediaType, outputMessage);\n+                    } else {\n+                        ((HttpMessageConverter) converter).write(outputValue, selectedMediaType, outputMessage);\n+                    }\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + converter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })"
          }
        }
      ]
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/7 下午8:19",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/7 下午8:19",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/1 上午3:42",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 167,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
          "diff": "@@ -1,78 +1,78 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n+protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n+        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                     outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (outputValue !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n                         ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/7 下午8:19",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/1 上午3:42",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 167,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
          "diff": "@@ -1,78 +1,78 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n+protected \u003cT\u003e void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n+        throw new HttpMessageNotWritableException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                     outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (outputValue !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n                         ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[value-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]",
            "newValue": "[value-T(annotations-@Nullable), returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
          }
        }
      ]
    },
    "39f8bd663ee944d92ecd8b1e33b5315807419c94": {
      "type": "Ydocchange",
      "commitMessage": "Polishing\n",
      "commitDate": "2017/5/6 上午5:19",
      "commitName": "39f8bd663ee944d92ecd8b1e33b5315807419c94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/12/13 下午8:02",
      "commitNameOld": "5169c51a6c5a7ac3911a367bd855f574632c95c6",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 143.39,
      "commitsBetweenForRepo": 934,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 163,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
        "newValue": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated\nby the {@code Accept} header on the request cannot be met by the message converters\n"
      }
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016/7/5 下午11:00",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2016/7/2 下午8:48",
      "commitNameOld": "b204437cef0976f5af0e1c5290e77e266b306a51",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.09,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 164,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,78 +1,78 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Object outputValue;\n     Class\u003c?\u003e valueType;\n     Type declaredType;\n     if (value instanceof CharSequence) {\n         outputValue \u003d value.toString();\n         valueType \u003d String.class;\n         declaredType \u003d String.class;\n     } else {\n         outputValue \u003d value;\n         valueType \u003d getReturnValueType(outputValue, returnType);\n         declaredType \u003d getGenericType(returnType);\n     }\n     HttpServletRequest request \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n     if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n     }\n-    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n+    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003c\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n-    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n+    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003c\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                     outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (outputValue !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n                         ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                 outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b204437cef0976f5af0e1c5290e77e266b306a51": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2016/7/2 下午8:48",
      "commitName": "b204437cef0976f5af0e1c5290e77e266b306a51",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/2 下午7:02",
      "commitNameOld": "e7a53e37fb1a0131f2c753fd83c1d161e21b1105",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Object outputValue;\n    Class\u003c?\u003e valueType;\n    Type declaredType;\n    if (value instanceof CharSequence) {\n        outputValue \u003d value.toString();\n        valueType \u003d String.class;\n        declaredType \u003d String.class;\n    } else {\n        outputValue \u003d value;\n        valueType \u003d getReturnValueType(outputValue, returnType);\n        declaredType \u003d getGenericType(returnType);\n    }\n    HttpServletRequest request \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (outputValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (outputValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (outputValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (outputValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 164,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,73 +1,78 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n-    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n-    Type type \u003d getGenericType(returnType);\n-    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n-        clazz \u003d String.class;\n-        type \u003d String.class;\n-        value \u003d (T) value.toString();\n+    Object outputValue;\n+    Class\u003c?\u003e valueType;\n+    Type declaredType;\n+    if (value instanceof CharSequence) {\n+        outputValue \u003d value.toString();\n+        valueType \u003d String.class;\n+        declaredType \u003d String.class;\n+    } else {\n+        outputValue \u003d value;\n+        valueType \u003d getReturnValueType(outputValue, returnType);\n+        declaredType \u003d getGenericType(returnType);\n     }\n-    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n-    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n-    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n+    HttpServletRequest request \u003d inputMessage.getServletRequest();\n+    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(request);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(request, valueType, declaredType);\n+    if (outputValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        throw new IllegalArgumentException(\"No converter found for return value of type: \" + valueType);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        if (value !\u003d null) {\n+        if (outputValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n-                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (value !\u003d null) {\n+                if (((GenericHttpMessageConverter) messageConverter).canWrite(declaredType, valueType, selectedMediaType)) {\n+                    outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                    if (outputValue !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n+                        ((GenericHttpMessageConverter) messageConverter).write(outputValue, declaredType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                            logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n-            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n-                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                if (value !\u003d null) {\n+            } else if (messageConverter.canWrite(valueType, selectedMediaType)) {\n+                outputValue \u003d (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                if (outputValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n+                    ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + outputValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    if (value !\u003d null) {\n+    if (outputValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7756feacd877093ad925d222c8bb911b6bb7c381": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Polish\n",
      "commitDate": "2016/2/5 下午1:04",
      "commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
      "commitAuthor": "Rossen Stoyanchev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Polish\n",
          "commitDate": "2016/2/5 下午1:04",
          "commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/2/5 下午12:55",
          "commitNameOld": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n    Type type \u003d getGenericType(returnType);\n    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n        clazz \u003d String.class;\n        type \u003d String.class;\n        value \u003d (T) value.toString();\n    }\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (value !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (value !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (value !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (value !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 167,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,73 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n-    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n-    Type returnValueType \u003d getGenericType(returnType);\n-    if (returnValue !\u003d null \u0026\u0026 returnValue instanceof CharSequence) {\n-        returnValueClass \u003d String.class;\n-        returnValueType \u003d String.class;\n-        returnValue \u003d (T) returnValue.toString();\n+protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n+    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n+    Type type \u003d getGenericType(returnType);\n+    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n+        clazz \u003d String.class;\n+        type \u003d String.class;\n+        value \u003d (T) value.toString();\n     }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n-    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n+    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        if (returnValue !\u003d null) {\n+        if (value !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n-                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (returnValue !\u003d null) {\n+                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n+                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                    if (value !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n+                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n-            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                if (returnValue !\u003d null) {\n+            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n+                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                if (value !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    if (returnValue !\u003d null) {\n+    if (value !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]",
            "newValue": "[value-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Polish\n",
          "commitDate": "2016/2/5 下午1:04",
          "commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/2/5 下午12:55",
          "commitNameOld": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n    Type type \u003d getGenericType(returnType);\n    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n        clazz \u003d String.class;\n        type \u003d String.class;\n        value \u003d (T) value.toString();\n    }\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (value !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (value !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (value !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (value !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 167,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,73 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n-    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n-    Type returnValueType \u003d getGenericType(returnType);\n-    if (returnValue !\u003d null \u0026\u0026 returnValue instanceof CharSequence) {\n-        returnValueClass \u003d String.class;\n-        returnValueType \u003d String.class;\n-        returnValue \u003d (T) returnValue.toString();\n+protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n+    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n+    Type type \u003d getGenericType(returnType);\n+    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n+        clazz \u003d String.class;\n+        type \u003d String.class;\n+        value \u003d (T) value.toString();\n     }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n-    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n+    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        if (returnValue !\u003d null) {\n+        if (value !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n-                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (returnValue !\u003d null) {\n+                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n+                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                    if (value !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n+                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n-            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                if (returnValue !\u003d null) {\n+            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n+                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                if (value !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    if (returnValue !\u003d null) {\n+    if (value !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Polish\n",
          "commitDate": "2016/2/5 下午1:04",
          "commitName": "7756feacd877093ad925d222c8bb911b6bb7c381",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2016/2/5 下午12:55",
          "commitNameOld": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n    Type type \u003d getGenericType(returnType);\n    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n        clazz \u003d String.class;\n        type \u003d String.class;\n        value \u003d (T) value.toString();\n    }\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (value !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (value !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (value !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (value !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
          "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 167,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,73 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n-    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n-    Type returnValueType \u003d getGenericType(returnType);\n-    if (returnValue !\u003d null \u0026\u0026 returnValue instanceof CharSequence) {\n-        returnValueClass \u003d String.class;\n-        returnValueType \u003d String.class;\n-        returnValue \u003d (T) returnValue.toString();\n+protected \u003cT\u003e void writeWithMessageConverters(T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n+    Class\u003c?\u003e clazz \u003d getReturnValueType(value, returnType);\n+    Type type \u003d getGenericType(returnType);\n+    if (value !\u003d null \u0026\u0026 value instanceof CharSequence) {\n+        clazz \u003d String.class;\n+        type \u003d String.class;\n+        value \u003d (T) value.toString();\n     }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n-    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n-        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, clazz, type);\n+    if (value !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        throw new IllegalArgumentException(\"No converter found for return value of type: \" + clazz);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        if (returnValue !\u003d null) {\n+        if (value !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n-                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n-                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                    if (returnValue !\u003d null) {\n+                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(type, clazz, selectedMediaType)) {\n+                    value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                    if (value !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n-                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n+                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(value, type, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n-                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                            logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n-            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                if (returnValue !\u003d null) {\n+            } else if (messageConverter.canWrite(clazz, selectedMediaType)) {\n+                value \u003d (T) getAdvice().beforeBodyWrite(value, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                if (value !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n-                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(value, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        logger.debug(\"Written [\" + value + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    if (returnValue !\u003d null) {\n+    if (value !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
            "newValue": "Writes the given return type to the given output message.\n\n@param value the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n"
          }
        }
      ]
    },
    "1291d6e1bd5ba6524c3fb68813aad807d123c2e1": {
      "type": "Ybodychange",
      "commitMessage": "Support CharSequence for response body\n\nIssue: SPR-13423\n",
      "commitDate": "2016/2/5 下午12:55",
      "commitName": "1291d6e1bd5ba6524c3fb68813aad807d123c2e1",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/11/12 上午6:14",
      "commitNameOld": "3a919a48d6941622ae1b08034630b0f565d0554b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 85.28,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    Type returnValueType \u003d getGenericType(returnType);\n    if (returnValue !\u003d null \u0026\u0026 returnValue instanceof CharSequence) {\n        returnValueClass \u003d String.class;\n        returnValueType \u003d String.class;\n        returnValue \u003d (T) returnValue.toString();\n    }\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 167,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,68 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     Type returnValueType \u003d getGenericType(returnType);\n+    if (returnValue !\u003d null \u0026\u0026 returnValue instanceof CharSequence) {\n+        returnValueClass \u003d String.class;\n+        returnValueType \u003d String.class;\n+        returnValue \u003d (T) returnValue.toString();\n+    }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n     if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                     returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (returnValue !\u003d null) {\n                         addContentDispositionHeader(inputMessage, outputMessage);\n                         ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     addContentDispositionHeader(inputMessage, outputMessage);\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543": {
      "type": "Ybodychange",
      "commitMessage": "Protect against RFD exploits\n\nIssue: SPR-13548\n",
      "commitDate": "2015/10/15 下午4:33",
      "commitName": "2bd1daa75ee0b8ec33608ca6ab065ef3e1815543",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/9/4 下午8:38",
      "commitNameOld": "667fc7e4a9d9daf15110339af3659404ace6adba",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 40.83,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    Type returnValueType \u003d getGenericType(returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue !\u003d null) {\n                        addContentDispositionHeader(inputMessage, outputMessage);\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    addContentDispositionHeader(inputMessage, outputMessage);\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 147,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,66 +1,68 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     Type returnValueType \u003d getGenericType(returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n     if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n         throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n     }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                     returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (returnValue !\u003d null) {\n+                        addContentDispositionHeader(inputMessage, outputMessage);\n                         ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n+                    addContentDispositionHeader(inputMessage, outputMessage);\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "667fc7e4a9d9daf15110339af3659404ace6adba": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2015/9/4 下午8:38",
      "commitName": "667fc7e4a9d9daf15110339af3659404ace6adba",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/7/28 下午6:15",
      "commitNameOld": "d83735694eff6919434e8a4557cfb6dc66e5175d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 38.1,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    Type returnValueType \u003d getGenericType(returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n    }\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue !\u003d null) {\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 113,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,64 +1,66 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     Type returnValueType \u003d getGenericType(returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n-    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n+    if (returnValue !\u003d null \u0026\u0026 producibleMediaTypes.isEmpty()) {\n+        throw new IllegalArgumentException(\"No converter found for return value of type: \" + returnValueClass);\n+    }\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                     returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (returnValue !\u003d null) {\n                         ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d83735694eff6919434e8a4557cfb6dc66e5175d": {
      "type": "Yexceptionschange",
      "commitMessage": "Polishing\n",
      "commitDate": "2015/7/28 下午6:15",
      "commitName": "d83735694eff6919434e8a4557cfb6dc66e5175d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/6/25 下午9:02",
      "commitNameOld": "289f35da3a57bb5e491b30c7351072b4e801c519",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 32.88,
      "commitsBetweenForRepo": 219,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    Type returnValueType \u003d getGenericType(returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue !\u003d null) {\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 114,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,64 +1,64 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     Type returnValueType \u003d getGenericType(returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n     Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof GenericHttpMessageConverter) {\n                 if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                     returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                     if (returnValue !\u003d null) {\n                         ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                         }\n                     }\n                     return;\n                 }\n             } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[IOException, HttpMediaTypeNotAcceptableException]",
        "newValue": "[IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException]"
      }
    },
    "289f35da3a57bb5e491b30c7351072b4e801c519": {
      "type": "Ybodychange",
      "commitMessage": "Call type aware canWrite() when using a GenericHttpMessageConverter\n\nThis commit introduces the following changes:\n - In AbstractMessageConverterMethodProcessor, the type aware variant of\n   canWrite() is now called when the converter implements\n   GenericHttpMessageConverter.\n - The Javadoc has been updated in GenericHttpMessageConverter to make it clear\n   that the type aware canRead() and canWrite() methods should perform the same\n   checks than non type aware ones.\n  - AbstractGenericHttpMessageConverter now implements default type aware\n    canRead() and canWrite() methods than just call the non type aware variants.\n    Due to this, if subclasses just override the non type aware variants,\n    they still have the right behavior.\n\nIssue: SPR-13161\n",
      "commitDate": "2015/6/25 下午9:02",
      "commitName": "289f35da3a57bb5e491b30c7351072b4e801c519",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/6/22 下午11:05",
      "commitNameOld": "31a5434ea433bdec2283797bf9415c02bb2f41c1",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 2.91,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    Type returnValueType \u003d getGenericType(returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof GenericHttpMessageConverter) {\n                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                    if (returnValue !\u003d null) {\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                        }\n                    }\n                    return;\n                }\n            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 114,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,63 +1,64 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n+    Type returnValueType \u003d getGenericType(returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass, returnValueType);\n     Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n+            if (messageConverter instanceof GenericHttpMessageConverter) {\n+                if (((GenericHttpMessageConverter\u003cT\u003e) messageConverter).canWrite(returnValueType, returnValueClass, selectedMediaType)) {\n+                    returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                    if (returnValue !\u003d null) {\n+                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, returnValueType, selectedMediaType, outputMessage);\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                        }\n+                    }\n+                    return;\n+                }\n+            } else if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n-                    if (messageConverter instanceof GenericHttpMessageConverter) {\n-                        Type type;\n-                        if (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n-                            returnType.increaseNestingLevel();\n-                            type \u003d returnType.getNestedGenericParameterType();\n-                        } else {\n-                            type \u003d returnType.getGenericParameterType();\n-                        }\n-                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n-                    } else {\n-                        ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n-                    }\n+                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "31a5434ea433bdec2283797bf9415c02bb2f41c1": {
      "type": "Ybodychange",
      "commitMessage": "Make @ResponseBody method return type available for message converters\n\nThis commit adds canWrite() and write() methods to the\nGenericHttpMessageConverter interface. These are type aware variants\nof the methods available in HttpMessageConverter, in order to keep\nparametrized type information when serializing objects.\n\nAbstractMessageConverterMethodProcessor now calls those type aware\nmethods when the message converter implements GenericHttpMessageConverter.\n\nAbstractJackson2HttpMessageConverter and GsonHttpMessageConverter uses\nthese new methods to make @ResponseBody method return type available\nfor type resolution instead of just letting the JSON serializer trying\nto guess the type to use from the object to serialize.\n\nIssue: SPR-12811\n",
      "commitDate": "2015/6/22 下午11:05",
      "commitName": "31a5434ea433bdec2283797bf9415c02bb2f41c1",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2015/6/18 上午5:03",
      "commitNameOld": "8d7812b1b6c47c3edef1332639cb57b92327ec46",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    if (messageConverter instanceof GenericHttpMessageConverter) {\n                        Type type;\n                        if (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n                            returnType.increaseNestingLevel();\n                            type \u003d returnType.getNestedGenericParameterType();\n                        } else {\n                            type \u003d returnType.getGenericParameterType();\n                        }\n                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n                    } else {\n                        ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 114,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,52 +1,63 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n-                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    if (messageConverter instanceof GenericHttpMessageConverter) {\n+                        Type type;\n+                        if (HttpEntity.class.isAssignableFrom(returnType.getParameterType())) {\n+                            returnType.increaseNestingLevel();\n+                            type \u003d returnType.getNestedGenericParameterType();\n+                        } else {\n+                            type \u003d returnType.getGenericParameterType();\n+                        }\n+                        ((GenericHttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, type, selectedMediaType, outputMessage);\n+                    } else {\n+                        ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    }\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d7812b1b6c47c3edef1332639cb57b92327ec46": {
      "type": "Ybodychange",
      "commitMessage": "Raise IAE when no converter matches return type\n\nBefore this change the AbstractMessageConverterMethodProcessor always\nraised a 406 if it couldn\u0027t find a converter. However if the reason\nfor not finding it is because there is simply no converter for the\nreturn value type (i.e. programming error) and doesn\u0027t have anything to\ndo with content negotiation, then we should raise a 500 instead and\nmake it easier to figure out what\u0027s wrong.\n\nIssue: SPR-13135\n",
      "commitDate": "2015/6/18 上午5:03",
      "commitName": "8d7812b1b6c47c3edef1332639cb57b92327ec46",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2015/3/30 上午9:42",
      "commitNameOld": "0556ed4f161cddf992cc49960ba0181a564a8667",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 79.81,
      "commitsBetweenForRepo": 481,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 111,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,51 +1,52 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n+    Assert.isTrue(returnValue \u003d\u003d null || !producibleMediaTypes.isEmpty(), \"No converter found for return value of type: \" + returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0556ed4f161cddf992cc49960ba0181a564a8667": {
      "type": "Ybodychange",
      "commitMessage": "Add RequestBodyAdvice\n\nRequestBodyAdvice is analogous to ResponseBodyAdvice (added in 4.1)\nbut for intercepting for reading the request with an\nHttpMessageConverter for resolving an @RequestBody or an HttpEntity\nmethod argument.\n\nIssue: SPR-12501\n",
      "commitDate": "2015/3/30 上午9:42",
      "commitName": "0556ed4f161cddf992cc49960ba0181a564a8667",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/10/18 上午1:21",
      "commitNameOld": "c5e360d886931f761c2be5ff4b31d5df2042d415",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 163.35,
      "commitsBetweenForRepo": 605,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 110,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,51 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         if (returnValue !\u003d null) {\n             throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n         }\n         return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                returnValue \u003d (T) getAdvice().beforeBodyWrite(returnValue, returnType, selectedMediaType, (Class\u003c? extends HttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     if (returnValue !\u003d null) {\n         throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5e360d886931f761c2be5ff4b31d5df2042d415": {
      "type": "Ybodychange",
      "commitMessage": "Fix regression with raw ResponseEntity type\n\nThis fix addresses a 4.1.1 regression where a raw ResponseEntity return\nvalue (used to return potentially a different kind of body) caused an\nexception.\n\nThe regression came from the fact we now try to render a null body in\norder to give ResponseBodyAdvice a chance to substitute a different\nvalue. That in turn means we have to try to determine the body type\nfrom the method signature.\n\nThis change improves the logic for extracting the generic parameter\ntype to accommodate a raw ResponseEntity class. Also we avoid raising\nHttpMediaTypeNotAcceptableException if the value to be rendered is\nnull.\n\nIssue: SPR-12287\n",
      "commitDate": "2014/10/18 上午1:21",
      "commitName": "c5e360d886931f761c2be5ff4b31d5df2042d415",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/10/16 上午5:06",
      "commitNameOld": "8cce40469631327e0afdd5d41393248313819270",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        if (returnValue !\u003d null) {\n            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n        }\n        return;\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    if (returnValue !\u003d null) {\n        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n    }\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 115,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,49 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n-    if (returnValue \u003d\u003d null \u0026\u0026 Void.class.equals(returnValueClass)) {\n-        return;\n-    }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+        if (returnValue !\u003d null) {\n+            throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n+        }\n+        return;\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n-    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n+    if (returnValue !\u003d null) {\n+        throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8cce40469631327e0afdd5d41393248313819270": {
      "type": "Ybodychange",
      "commitMessage": "Add check for ResponseEntity\u003cvoid\u003e with null return value\n\nIssue: SPR-12287\n",
      "commitDate": "2014/10/16 上午5:06",
      "commitName": "8cce40469631327e0afdd5d41393248313819270",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/9/20 上午2:57",
      "commitNameOld": "a9b2a12491aa2259851b93824b7e560b3dbd1902",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 26.09,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    if (returnValue \u003d\u003d null \u0026\u0026 Void.class.equals(returnValueClass)) {\n        return;\n    }\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 115,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,46 +1,49 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n+    if (returnValue \u003d\u003d null \u0026\u0026 Void.class.equals(returnValueClass)) {\n+        return;\n+    }\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 if (returnValue !\u003d null) {\n                     ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b2a12491aa2259851b93824b7e560b3dbd1902": {
      "type": "Ybodychange",
      "commitMessage": "Allow ResponseBodyAdvice to modify null return values\n\nThis change defers determination of whether to invoke a message\nconverter in case of a null @ResponseBody value (or ResponseEntity with\na null body) until after the invocation of the ResponseBodyAdvice\nchain. This allows a ResponseBodyAdvice to handle null values\npotentially turning them into non-null value.s\n\nIssue: SPR-12152\n",
      "commitDate": "2014/9/20 上午2:57",
      "commitName": "a9b2a12491aa2259851b93824b7e560b3dbd1902",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/5/31 上午5:02",
      "commitNameOld": "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 111.91,
      "commitsBetweenForRepo": 627,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                if (returnValue !\u003d null) {\n                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 115,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,44 +1,46 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n+    Class\u003c?\u003e returnValueClass \u003d getReturnValueType(returnValue, returnType);\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n-                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                if (returnValue !\u003d null) {\n+                    ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                    }\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9d0ebd730953ef693edf275b57cfeeb9bf15af9": {
      "type": "Ybodychange",
      "commitMessage": "Rename ResponseBodyInterceptor to ResponseBodyAdvice\n\nIssue: SPR-10859\n",
      "commitDate": "2014/5/31 上午5:02",
      "commitName": "c9d0ebd730953ef693edf275b57cfeeb9bf15af9",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/5/31 上午5:02",
      "commitNameOld": "2655c507e041fb3c245d550b33ba7f1b21fc341e",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 111,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,44 +1,44 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d this.interceptorChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n+                returnValue \u003d this.adviceChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2655c507e041fb3c245d550b33ba7f1b21fc341e": {
      "type": "Ybodychange",
      "commitMessage": "Parameterize ResponseBodyInterceptor on the type level\n\nIssue: SPR-10859\n",
      "commitDate": "2014/5/31 上午5:02",
      "commitName": "2655c507e041fb3c245d550b33ba7f1b21fc341e",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/5/20 上午3:47",
      "commitNameOld": "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 11.05,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.interceptorChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 112,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,44 +1,44 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n-                returnValue \u003d this.interceptorChain.invoke(returnValue, selectedMediaType, (Class\u003cHttpMessageConverter\u003cT\u003e\u003e) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n+                returnValue \u003d this.interceptorChain.invoke(returnValue, returnType, selectedMediaType, (Class\u003cHttpMessageConverter\u003c?\u003e\u003e) messageConverter.getClass(), inputMessage, outputMessage);\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096": {
      "type": "Ybodychange",
      "commitMessage": "Refactor @JsonView support w/ ResponseBodyInterceptor\n\nThe newly added support for ResponseBodyInterceptor is a good fit for\nthe (also recently added) support for the Jackson @JsonView annotation.\n\nThis change refactors the original implementation of @JsonView support\nfor @ResponseBody and ResponseEntity controller methods this time\nimplemented as an ResponseBodyInterceptor.\n\nIssue: SPR-7156\n",
      "commitDate": "2014/5/20 上午3:47",
      "commitName": "51fc3b4aaf01a3d8f8f0f9ec98f5e5c1215cc096",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/5/20 上午3:47",
      "commitNameOld": "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.interceptorChain.invoke(returnValue, selectedMediaType, (Class\u003cHttpMessageConverter\u003cT\u003e\u003e) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 111,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,54 +1,44 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n-                MethodParameterHttpMessageConverter\u003cT\u003e c \u003d (MethodParameterHttpMessageConverter\u003cT\u003e) messageConverter;\n-                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n-                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n-                    if (logger.isDebugEnabled()) {\n-                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n-                    }\n-                    return;\n-                }\n-            }\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 returnValue \u003d this.interceptorChain.invoke(returnValue, selectedMediaType, (Class\u003cHttpMessageConverter\u003cT\u003e\u003e) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "96b18c8dc22c0c57605a594b21ceec84ec16ee37": {
      "type": "Ybodychange",
      "commitMessage": "Add ResponseBodyInterceptor\n\nThis change introduces a new ResponseBodyInterceptor interface that can\nbe used to modify the response after @ResponseBody or ResponseEntity\nmethods but before the body is actually written to the response with the\nselected HttpMessageConverter.\n\nThe RequestMappingHandlerAdapter and ExceptionHandlerExceptionResolver\neach have a property to configure such interceptors. In addition both\nRequestMappingHandlerAdapter and ExceptionHandlerExceptionResolver\ndetect if any @ControllerAdvice bean implements ResponseBodyInterceptor\nand use it accordingly.\n\nIssue: SPR-10859\n",
      "commitDate": "2014/5/20 上午3:47",
      "commitName": "96b18c8dc22c0c57605a594b21ceec84ec16ee37",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/5/16 上午11:03",
      "commitNameOld": "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n                MethodParameterHttpMessageConverter\u003cT\u003e c \u003d (MethodParameterHttpMessageConverter\u003cT\u003e) messageConverter;\n                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                    return;\n                }\n            }\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                returnValue \u003d this.interceptorChain.invoke(returnValue, selectedMediaType, (Class\u003cHttpMessageConverter\u003cT\u003e\u003e) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 112,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,53 +1,54 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n                 MethodParameterHttpMessageConverter\u003cT\u003e c \u003d (MethodParameterHttpMessageConverter\u003cT\u003e) messageConverter;\n                 if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n                     c.write(returnValue, selectedMediaType, outputMessage, returnType);\n                     if (logger.isDebugEnabled()) {\n                         logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                     }\n                     return;\n                 }\n             }\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n+                returnValue \u003d this.interceptorChain.invoke(returnValue, selectedMediaType, (Class\u003cHttpMessageConverter\u003cT\u003e\u003e) messageConverter.getClass(), returnType, inputMessage, outputMessage);\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2": {
      "type": "Ybodychange",
      "commitMessage": "Add support for Jackson serialization views\n\nSpring MVC now supports Jackon\u0027s serialization views for rendering\ndifferent subsets of the same POJO from different controller\nmethods (e.g. detailed page vs summary view).\n\nIssue: SPR-7156\n",
      "commitDate": "2014/5/16 上午11:03",
      "commitName": "be0b69cbf1377e3fa8d8abc94f24274f4d0945b2",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2014/4/24 上午5:03",
      "commitNameOld": "ec7d80b8519332ffb5f0595dddc9ef52de532730",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 22.25,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n                MethodParameterHttpMessageConverter\u003cT\u003e c \u003d (MethodParameterHttpMessageConverter\u003cT\u003e) messageConverter;\n                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                    }\n                    return;\n                }\n            }\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 104,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,43 +1,53 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType requestedType : requestedMediaTypes) {\n         for (MediaType producibleType : producibleMediaTypes) {\n             if (requestedType.isCompatibleWith(producibleType)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n+            if (messageConverter instanceof MethodParameterHttpMessageConverter) {\n+                MethodParameterHttpMessageConverter\u003cT\u003e c \u003d (MethodParameterHttpMessageConverter\u003cT\u003e) messageConverter;\n+                if (c.canWrite(returnValueClass, selectedMediaType, returnType)) {\n+                    c.write(returnValue, selectedMediaType, outputMessage, returnType);\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n+                    }\n+                    return;\n+                }\n+            }\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ec7d80b8519332ffb5f0595dddc9ef52de532730": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2014/4/24 上午5:03",
      "commitName": "ec7d80b8519332ffb5f0595dddc9ef52de532730",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/1/22 上午1:34",
      "commitNameOld": "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 457.15,
      "commitsBetweenForRepo": 2032,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType requestedType : requestedMediaTypes) {\n        for (MediaType producibleType : producibleMediaTypes) {\n            if (requestedType.isCompatibleWith(producibleType)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 103,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,43 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n-    for (MediaType r : requestedMediaTypes) {\n-        for (MediaType p : producibleMediaTypes) {\n-            if (r.isCompatibleWith(p)) {\n-                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n+    for (MediaType requestedType : requestedMediaTypes) {\n+        for (MediaType producibleType : producibleMediaTypes) {\n+            if (requestedType.isCompatibleWith(producibleType)) {\n+                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n-        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n+        for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n-    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+    throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa": {
      "type": "Ybodychange",
      "commitMessage": "Fix exception message about producible media types\n\nIssue: SPR-10175\n",
      "commitDate": "2013/1/22 上午1:34",
      "commitName": "e4fcad9f936ba492f28ec5f0421eea4b3f76f8aa",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2012/12/29 上午3:49",
      "commitNameOld": "2cf45bad860f560d3a5806eb23ffe1669e907673",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 23.91,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 105,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,43 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType r : requestedMediaTypes) {\n         for (MediaType p : producibleMediaTypes) {\n             if (r.isCompatibleWith(p)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n-        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+        throw new HttpMediaTypeNotAcceptableException(producibleMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d": {
      "type": "Ybodychange",
      "commitMessage": "Fix NPE in AbstractMessageConverterMethodProcessor\n\nIssue: SPR-9868\n",
      "commitDate": "2012/10/10 下午9:00",
      "commitName": "d4fa5c0331e5a8008dae2f6f0ba157bdddaf122d",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2012/6/22 下午11:55",
      "commitNameOld": "f05e2bc56f8e03466977d73a5e99c37651248803",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 109.88,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 105,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,43 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n     List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType r : requestedMediaTypes) {\n         for (MediaType p : producibleMediaTypes) {\n             if (r.isCompatibleWith(p)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n-    selectedMediaType \u003d selectedMediaType.removeQualityValue();\n     if (selectedMediaType !\u003d null) {\n+        selectedMediaType \u003d selectedMediaType.removeQualityValue();\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f05e2bc56f8e03466977d73a5e99c37651248803": {
      "type": "Ybodychange",
      "commitMessage": "Add abstractions for content negotiation\n\nIntroduced ContentNeogtiationStrategy for resolving the requested\nmedia types from an incoming request. The available implementations\nare based on path extension, request parameter, \u0027Accept\u0027 header,\nand a fixed default content type. The logic for these implementations\nis based on equivalent options, previously available only in the\nContentNegotiatingViewResolver.\n\nAlso in this commit is ContentNegotiationManager, the central class to\nuse when configuring content negotiation options. It accepts one or\nmore ContentNeogtiationStrategy instances and delegates to them.\n\nThe ContentNeogiationManager can now be used to configure the\nfollowing classes:\n\n- RequestMappingHandlerMappingm\n- RequestMappingHandlerAdapter\n- ExceptionHandlerExceptionResolver\n- ContentNegotiatingViewResolver\n\nIssue: SPR-8410, SPR-8417, SPR-8418,SPR-8416, SPR-8419,SPR-7722\n",
      "commitDate": "2012/6/22 下午11:55",
      "commitName": "f05e2bc56f8e03466977d73a5e99c37651248803",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2012/5/12 上午2:43",
      "commitNameOld": "982cb2f258a5be1173115044d379f54702dc8c5b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 41.88,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType r : requestedMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (r.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    selectedMediaType \u003d selectedMediaType.removeQualityValue();\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 105,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,42 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n-    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n+    HttpServletRequest servletRequest \u003d inputMessage.getServletRequest();\n+    List\u003cMediaType\u003e requestedMediaTypes \u003d getAcceptableMediaTypes(servletRequest);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(servletRequest, returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n-    for (MediaType a : acceptableMediaTypes) {\n+    for (MediaType r : requestedMediaTypes) {\n         for (MediaType p : producibleMediaTypes) {\n-            if (a.isCompatibleWith(p)) {\n-                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n+            if (r.isCompatibleWith(p)) {\n+                compatibleMediaTypes.add(getMostSpecificMediaType(r, p));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     selectedMediaType \u003d selectedMediaType.removeQualityValue();\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "982cb2f258a5be1173115044d379f54702dc8c5b": {
      "type": "Ybodychange",
      "commitMessage": "Fix content negotiation issue with sort by q-value\n\nBefore this fix the q-value of media types in the Accept header were\nignored when using the new RequestMappingHandlerAdapter in combination\nwith @ResponseBody and HttpMessageConverters.\n\nIssue: SPR-9160\n",
      "commitDate": "2012/5/12 上午2:43",
      "commitName": "982cb2f258a5be1173115044d379f54702dc8c5b",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2012/4/3 上午5:36",
      "commitNameOld": "ca8b98e94724cd9a2008deb4fe1280aaace6ca8b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 38.88,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    selectedMediaType \u003d selectedMediaType.removeQualityValue();\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 95,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,41 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n     List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType a : acceptableMediaTypes) {\n         for (MediaType p : producibleMediaTypes) {\n             if (a.isCompatibleWith(p)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n-    MediaType.sortBySpecificity(mediaTypes);\n+    MediaType.sortBySpecificityAndQuality(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n+    selectedMediaType \u003d selectedMediaType.removeQualityValue();\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 96,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
        "newPath": "spring-webmvc/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java"
      }
    },
    "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54": {
      "type": "Yfilerename",
      "commitMessage": "overhaul of support package arrangements for handler method processing; added missing package-info files\n",
      "commitDate": "2011/12/13 上午7:20",
      "commitName": "1c45c51fe10bd3739d4b4c938a288ee3ebbf0f54",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/12/13 上午3:20",
      "commitNameOld": "2065b788c4961e09cbafc4f52d91177db07b9285",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 96,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
        "newPath": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/AbstractMessageConverterMethodProcessor.java"
      }
    },
    "c5833b192e3f3a280f8c63a9c45ca96776415a6b": {
      "type": "Ybodychange",
      "commitMessage": "SPR-7353 Use canWrite to narrow down list of producible types\n",
      "commitDate": "2011/5/25 上午1:22",
      "commitName": "c5833b192e3f3a280f8c63a9c45ca96776415a6b",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2011/5/21 上午1:02",
      "commitNameOld": "5fa7f24794cc23cd0a803d8d49024d34f7df328b",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 161,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,40 +1,41 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Class\u003c?\u003e returnValueClass \u003d returnValue.getClass();\n     List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n-    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest(), returnValueClass);\n     Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n     for (MediaType a : acceptableMediaTypes) {\n         for (MediaType p : producibleMediaTypes) {\n             if (a.isCompatibleWith(p)) {\n                 compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n             }\n         }\n     }\n     if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n-            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+            if (messageConverter.canWrite(returnValueClass, selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5fa7f24794cc23cd0a803d8d49024d34f7df328b": {
      "type": "Ybodychange",
      "commitMessage": "SPR-7353 Respect \u0027produces\u0027 condition in ContentNegotiatingViewResolver, improve selection of more specific media type in a pair\n",
      "commitDate": "2011/5/21 上午1:02",
      "commitName": "5fa7f24794cc23cd0a803d8d49024d34f7df328b",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2011/5/18 下午7:34",
      "commitNameOld": "1eaca6572091c014379e453299773e880a7766b9",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n    for (MediaType a : acceptableMediaTypes) {\n        for (MediaType p : producibleMediaTypes) {\n            if (a.isCompatibleWith(p)) {\n                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n            }\n        }\n    }\n    if (compatibleMediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 161,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
      "diff": "@@ -1,39 +1,40 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n-    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n-    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n-        for (MediaType producibleMediaType : producibleMediaTypes) {\n-            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n-                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+    List\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    List\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n+    Set\u003cMediaType\u003e compatibleMediaTypes \u003d new LinkedHashSet\u003cMediaType\u003e();\n+    for (MediaType a : acceptableMediaTypes) {\n+        for (MediaType p : producibleMediaTypes) {\n+            if (a.isCompatibleWith(p)) {\n+                compatibleMediaTypes.add(getMostSpecificMediaType(a, p));\n             }\n         }\n     }\n-    if (mediaTypes.isEmpty()) {\n+    if (compatibleMediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n+    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e(compatibleMediaTypes);\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eaca6572091c014379e453299773e880a7766b9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
      "commitDate": "2011/5/18 下午7:34",
      "commitName": "1eaca6572091c014379e453299773e880a7766b9",
      "commitAuthor": "Arjen Poutsma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
          "commitDate": "2011/5/18 下午7:34",
          "commitName": "1eaca6572091c014379e453299773e880a7766b9",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2011/5/17 下午9:02",
          "commitNameOld": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 156,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,37 +1,39 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n+    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage, producibleMediaTypes-Set\u003cMediaType\u003e]",
            "newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-ServletServerHttpRequest, outputMessage-ServletServerHttpResponse]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
          "commitDate": "2011/5/18 下午7:34",
          "commitName": "1eaca6572091c014379e453299773e880a7766b9",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2011/5/17 下午9:02",
          "commitNameOld": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 156,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,37 +1,39 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n+    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "@RequestMapping.consumes() and produces() now default to an empty array, instead of */*\n",
          "commitDate": "2011/5/18 下午7:34",
          "commitName": "1eaca6572091c014379e453299773e880a7766b9",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2011/5/17 下午9:02",
          "commitNameOld": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 156,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n",
          "diff": "@@ -1,37 +1,39 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(inputMessage.getServletRequest());\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n+    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     }\n     throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Writes the given return type to the given output message.\n\n@param returnValue the value to write to the output message\n@param returnType the type of the value\n@param inputMessage the input messages. Used to inspect the {@code Accept} header.\n@param outputMessage the output message to write to\n@throws IOException thrown in case of I/O errors\n@throws HttpMediaTypeNotAcceptableException thrown when the conditions indicated by {@code Accept} header on\nthe request cannot be met by the message converters\n"
          }
        }
      ]
    },
    "af1dfd357743e6f4d5b9589ddb584f472a699e41": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
      "commitDate": "2011/5/17 下午9:02",
      "commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
      "commitAuthor": "Rossen Stoyanchev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
          "commitDate": "2011/5/17 下午9:02",
          "commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2011/5/17 下午8:22",
          "commitNameOld": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 155,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,40 +1,37 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n-    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n+    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n-    } else {\n-        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n+    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]",
            "newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage, producibleMediaTypes-Set\u003cMediaType\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Use request attribute to check producible media types when writing to the response body\n",
          "commitDate": "2011/5/17 下午9:02",
          "commitName": "af1dfd357743e6f4d5b9589ddb584f472a699e41",
          "commitAuthor": "Rossen Stoyanchev",
          "commitDateOld": "2011/5/17 下午8:22",
          "commitNameOld": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 155,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,40 +1,37 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n-    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage, Set\u003cMediaType\u003e producibleMediaTypes) throws IOException, HttpMediaTypeNotAcceptableException {\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n+    for (MediaType acceptableMediaType : getAcceptableMediaTypes(inputMessage)) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n             break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n-    } else {\n-        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n+    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235": {
      "type": "Ybodychange",
      "commitMessage": "minor fix.\n",
      "commitDate": "2011/5/17 下午8:22",
      "commitName": "1bbdb0d2ff3f25f3d1e3d43d9fa5d6dbb7da6235",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2011/5/17 下午5:45",
      "commitNameOld": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n            break;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    } else {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n}",
      "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 132,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,40 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n     Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n     Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n     List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n     for (MediaType acceptableMediaType : acceptableMediaTypes) {\n         for (MediaType producibleMediaType : producibleMediaTypes) {\n             if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                 mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n             }\n         }\n     }\n     if (mediaTypes.isEmpty()) {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n     MediaType.sortBySpecificity(mediaTypes);\n     MediaType selectedMediaType \u003d null;\n     for (MediaType mediaType : mediaTypes) {\n         if (mediaType.isConcrete()) {\n             selectedMediaType \u003d mediaType;\n             break;\n         } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n             selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+            break;\n         }\n     }\n     if (selectedMediaType !\u003d null) {\n         for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n             if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                 ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n     } else {\n         throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad2e0d45875651d9a707b514dd3966fa81a9048c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
      "commitDate": "2011/5/17 下午5:45",
      "commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
      "commitAuthor": "Arjen Poutsma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
          "commitDate": "2011/5/17 下午5:45",
          "commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2011/4/14 上午7:15",
          "commitNameOld": "aa065e83100ace913de9f46ff38aeb84a4d85229",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 33.44,
          "commitsBetweenForRepo": 85,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    } else {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 132,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,39 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    List\u003cMediaType\u003e acceptedMediaTypes \u003d getAcceptedMediaTypes(inputMessage);\n-    List\u003cMediaType\u003e allSupportedMediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    if (this.messageConverters !\u003d null) {\n-        for (MediaType acceptedMediaType : acceptedMediaTypes) {\n-            for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-                if (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n-                    continue;\n-                }\n-                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n+    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n+    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n+        for (MediaType producibleMediaType : producibleMediaTypes) {\n+            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n+                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+            }\n+        }\n+    }\n+    if (mediaTypes.isEmpty()) {\n+        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+    }\n+    MediaType.sortBySpecificity(mediaTypes);\n+    MediaType selectedMediaType \u003d null;\n+    for (MediaType mediaType : mediaTypes) {\n+        if (mediaType.isConcrete()) {\n+            selectedMediaType \u003d mediaType;\n+            break;\n+        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+        }\n+    }\n+    if (selectedMediaType !\u003d null) {\n+        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n+            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n-                    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n-                    if (contentType \u003d\u003d null) {\n-                        contentType \u003d acceptedMediaType;\n-                    }\n-                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" + messageConverter + \"]\");\n+                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n-        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n-            allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n-        }\n+    } else {\n+        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n-    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[returnValue-T, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]",
            "newValue": "[returnValue-T, returnType-MethodParameter, inputMessage-HttpInputMessage, outputMessage-HttpOutputMessage]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "SPR-7353 - @ResponseBody and returned HttpEntity now respect @RequestMapping.produces()\n\n",
          "commitDate": "2011/5/17 下午5:45",
          "commitName": "ad2e0d45875651d9a707b514dd3966fa81a9048c",
          "commitAuthor": "Arjen Poutsma",
          "commitDateOld": "2011/4/14 上午7:15",
          "commitNameOld": "aa065e83100ace913de9f46ff38aeb84a4d85229",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 33.44,
          "commitsBetweenForRepo": 85,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n        for (MediaType producibleMediaType : producibleMediaTypes) {\n            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n            }\n        }\n    }\n    if (mediaTypes.isEmpty()) {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n    MediaType.sortBySpecificity(mediaTypes);\n    MediaType selectedMediaType \u003d null;\n    for (MediaType mediaType : mediaTypes) {\n        if (mediaType.isConcrete()) {\n            selectedMediaType \u003d mediaType;\n            break;\n        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n        }\n    }\n    if (selectedMediaType !\u003d null) {\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n    } else {\n        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n    }\n}",
          "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
          "functionStartLine": 132,
          "functionName": "writeWithMessageConverters",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,39 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e void writeWithMessageConverters(T returnValue, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n-    List\u003cMediaType\u003e acceptedMediaTypes \u003d getAcceptedMediaTypes(inputMessage);\n-    List\u003cMediaType\u003e allSupportedMediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n-    if (this.messageConverters !\u003d null) {\n-        for (MediaType acceptedMediaType : acceptedMediaTypes) {\n-            for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n-                if (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n-                    continue;\n-                }\n-                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, MethodParameter returnType, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    Set\u003cMediaType\u003e producibleMediaTypes \u003d getProducibleMediaTypes(returnType.getMethod(), returnValue.getClass());\n+    Set\u003cMediaType\u003e acceptableMediaTypes \u003d getAcceptableMediaTypes(inputMessage);\n+    List\u003cMediaType\u003e mediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n+    for (MediaType acceptableMediaType : acceptableMediaTypes) {\n+        for (MediaType producibleMediaType : producibleMediaTypes) {\n+            if (acceptableMediaType.isCompatibleWith(producibleMediaType)) {\n+                mediaTypes.add(getMostSpecificMediaType(acceptableMediaType, producibleMediaType));\n+            }\n+        }\n+    }\n+    if (mediaTypes.isEmpty()) {\n+        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+    }\n+    MediaType.sortBySpecificity(mediaTypes);\n+    MediaType selectedMediaType \u003d null;\n+    for (MediaType mediaType : mediaTypes) {\n+        if (mediaType.isConcrete()) {\n+            selectedMediaType \u003d mediaType;\n+            break;\n+        } else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {\n+            selectedMediaType \u003d MediaType.APPLICATION_OCTET_STREAM;\n+        }\n+    }\n+    if (selectedMediaType !\u003d null) {\n+        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n+            if (messageConverter.canWrite(returnValue.getClass(), selectedMediaType)) {\n+                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, selectedMediaType, outputMessage);\n                 if (logger.isDebugEnabled()) {\n-                    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n-                    if (contentType \u003d\u003d null) {\n-                        contentType \u003d acceptedMediaType;\n-                    }\n-                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" + messageConverter + \"]\");\n+                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + selectedMediaType + \"\\\" using [\" + messageConverter + \"]\");\n                 }\n                 return;\n             }\n         }\n-        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n-            allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n-        }\n+    } else {\n+        throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n     }\n-    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "acc75aa4b898a34dce42748df5b54624f8b3e9f2": {
      "type": "Yintroduced",
      "commitMessage": "SPR-8215 Move HandlerMethod code into trunk\n",
      "commitDate": "2011/4/6 下午7:30",
      "commitName": "acc75aa4b898a34dce42748df5b54624f8b3e9f2",
      "commitAuthor": "Rossen Stoyanchev",
      "diff": "@@ -0,0 +1,27 @@\n+@SuppressWarnings(\"unchecked\")\n+protected \u003cT\u003e void writeWithMessageConverters(T returnValue, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n+    List\u003cMediaType\u003e acceptedMediaTypes \u003d getAcceptedMediaTypes(inputMessage);\n+    List\u003cMediaType\u003e allSupportedMediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n+    if (this.messageConverters !\u003d null) {\n+        for (MediaType acceptedMediaType : acceptedMediaTypes) {\n+            for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n+                if (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n+                    continue;\n+                }\n+                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n+                if (logger.isDebugEnabled()) {\n+                    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n+                    if (contentType \u003d\u003d null) {\n+                        contentType \u003d acceptedMediaType;\n+                    }\n+                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" + messageConverter + \"]\");\n+                }\n+                return;\n+            }\n+        }\n+        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n+            allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n+        }\n+    }\n+    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n+}\n\\ No newline at end of file\n",
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e void writeWithMessageConverters(T returnValue, HttpInputMessage inputMessage, HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {\n    List\u003cMediaType\u003e acceptedMediaTypes \u003d getAcceptedMediaTypes(inputMessage);\n    List\u003cMediaType\u003e allSupportedMediaTypes \u003d new ArrayList\u003cMediaType\u003e();\n    if (this.messageConverters !\u003d null) {\n        for (MediaType acceptedMediaType : acceptedMediaTypes) {\n            for (HttpMessageConverter\u003c?\u003e messageConverter : this.messageConverters) {\n                if (!messageConverter.canWrite(returnValue.getClass(), acceptedMediaType)) {\n                    continue;\n                }\n                ((HttpMessageConverter\u003cT\u003e) messageConverter).write(returnValue, acceptedMediaType, outputMessage);\n                if (logger.isDebugEnabled()) {\n                    MediaType contentType \u003d outputMessage.getHeaders().getContentType();\n                    if (contentType \u003d\u003d null) {\n                        contentType \u003d acceptedMediaType;\n                    }\n                    logger.debug(\"Written [\" + returnValue + \"] as \\\"\" + contentType + \"\\\" using [\" + messageConverter + \"]\");\n                }\n                return;\n            }\n        }\n        for (HttpMessageConverter\u003c?\u003e messageConverter : messageConverters) {\n            allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n        }\n    }\n    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n}",
      "path": "org.springframework.web.servlet/src/main/java/org/springframework/web/servlet/mvc/method/annotation/support/AbstractMessageConverterMethodProcessor.java",
      "functionStartLine": 103,
      "functionName": "writeWithMessageConverters",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": ""
    }
  }
}