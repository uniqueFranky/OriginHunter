{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConfigurationClassPostProcessor.java",
  "functionName": "processConfigBeanDefinitions",
  "functionId": "processConfigBeanDefinitions___registry-BeanDefinitionRegistry",
  "sourceFilePath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
  "functionAnnotation": "",
  "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
  "functionStartLine": 261,
  "functionEndLine": 362,
  "numCommitsSeen": 215,
  "timeTaken": 7014,
  "changeHistory": [
    "4fef1fe820627e6462413f4c4b658d24146367a2",
    "139dc1d373cc6e32ee6b516504064a2c87e0008a",
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
    "fc64b8040f7c76f2bc85387cf944436424ce408c",
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
    "7818c650ba3ad567cff2975b408509679d03e663",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
    "abc343f4076d45172587197480c41f79c23f3aac",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
    "71c6eb2bb594f29803b6ec4a50de875def98be86",
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
    "eed1a323d10de122a08db26192dc602f9fb173f8",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b",
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
    "239ce1466ce118294f5c7b8e842a80815fd813de",
    "7c7fdb07363791fb3c72f4946839f4c166196ebe",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b",
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
    "0a42c80c1151380f7f492ec75de5648cfe62d250",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "4520ea8690fa8769a2d45658883eac51ea2453ed",
    "6fcea8b99da45f287149796ef2598f0d71758793",
    "57206db15271f865b542264c74980e6cbb4681fd",
    "c8bc54e0ccad49f0785856f911349283619eb8ba",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552",
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
    "0a4463fb71e6901a943a5bafc9d1957da2229333",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
    "a6124793fc44779b569fbbba6fd4ec8804b56558",
    "cea8f7f69e8939d4d20073862890f0b1c1824499",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
    "14bd47551900ced88eeacf2a5f63c187ff72028c",
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
    "1697932c57af5389fe07971e91866980e966403f",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
    "ef02c61e581dcd1f3cf110608da72ed133777d62",
    "b8f712621d56b2d862338a34d52839583dc1a80a",
    "2e7e98248724f5f4fc054617765053e7d7b978cd",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
    "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39"
  ],
  "changeHistoryShort": {
    "4fef1fe820627e6462413f4c4b658d24146367a2": "Ybodychange",
    "139dc1d373cc6e32ee6b516504064a2c87e0008a": "Ybodychange",
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668": "Ybodychange",
    "fc64b8040f7c76f2bc85387cf944436424ce408c": "Ybodychange",
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3": "Ybodychange",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": "Ybodychange",
    "7818c650ba3ad567cff2975b408509679d03e663": "Ybodychange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": "Ybodychange",
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d": "Ybodychange",
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed": "Ybodychange",
    "abc343f4076d45172587197480c41f79c23f3aac": "Ybodychange",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": "Ybodychange",
    "71c6eb2bb594f29803b6ec4a50de875def98be86": "Ybodychange",
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0": "Ybodychange",
    "eed1a323d10de122a08db26192dc602f9fb173f8": "Ybodychange",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": "Ybodychange",
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50": "Ybodychange",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": "Ybodychange",
    "239ce1466ce118294f5c7b8e842a80815fd813de": "Ybodychange",
    "7c7fdb07363791fb3c72f4946839f4c166196ebe": "Ybodychange",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": "Ybodychange",
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6": "Ybodychange",
    "0a42c80c1151380f7f492ec75de5648cfe62d250": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "4520ea8690fa8769a2d45658883eac51ea2453ed": "Ymultichange(Yparameterchange,Ybodychange)",
    "6fcea8b99da45f287149796ef2598f0d71758793": "Ymultichange(Yparameterchange,Ybodychange)",
    "57206db15271f865b542264c74980e6cbb4681fd": "Ybodychange",
    "c8bc54e0ccad49f0785856f911349283619eb8ba": "Ybodychange",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": "Ybodychange",
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da": "Ybodychange",
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4": "Ymultichange(Yparameterchange,Ybodychange)",
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": "Ymultichange(Yparameterchange,Ybodychange)",
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca": "Ybodychange",
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694": "Ybodychange",
    "0a4463fb71e6901a943a5bafc9d1957da2229333": "Ybodychange",
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": "Ybodychange",
    "a6124793fc44779b569fbbba6fd4ec8804b56558": "Ymodifierchange",
    "cea8f7f69e8939d4d20073862890f0b1c1824499": "Ymodifierchange",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": "Ybodychange",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": "Ybodychange",
    "14bd47551900ced88eeacf2a5f63c187ff72028c": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6": "Ybodychange",
    "1697932c57af5389fe07971e91866980e966403f": "Yfilerename",
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": "Yfilerename",
    "ef02c61e581dcd1f3cf110608da72ed133777d62": "Yfilerename",
    "b8f712621d56b2d862338a34d52839583dc1a80a": "Ybodychange",
    "2e7e98248724f5f4fc054617765053e7d7b978cd": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": "Ybodychange",
    "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf": "Ybodychange",
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4fef1fe820627e6462413f4c4b658d24146367a2": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2018/3/17 上午1:49",
      "commitName": "4fef1fe820627e6462413f4c4b658d24146367a2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/3/9 上午1:11",
      "commitNameOld": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.03,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -\u003e {\n        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return Integer.compare(i1, i2);\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    if (this.environment \u003d\u003d null) {\n        this.environment \u003d new StandardEnvironment();\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,74 +1,74 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     configCandidates.sort((bd1, bd2) -\u003e {\n         int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n         int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n+        return Integer.compare(i1, i2);\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             if (generator !\u003d null) {\n                 this.componentScanBeanNameGenerator \u003d generator;\n                 this.importBeanNameGenerator \u003d generator;\n             }\n         }\n     }\n     if (this.environment \u003d\u003d null) {\n         this.environment \u003d new StandardEnvironment();\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n         sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "139dc1d373cc6e32ee6b516504064a2c87e0008a": {
      "type": "Ybodychange",
      "commitMessage": "Polishing (collapsed if checks, consistent downcasts, refined javadoc)\n",
      "commitDate": "2018/3/9 上午1:11",
      "commitName": "139dc1d373cc6e32ee6b516504064a2c87e0008a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/6/30 上午7:54",
      "commitNameOld": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 251.72,
      "commitsBetweenForRepo": 1211,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -\u003e {\n        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    if (this.environment \u003d\u003d null) {\n        this.environment \u003d new StandardEnvironment();\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,76 +1,74 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     configCandidates.sort((bd1, bd2) -\u003e {\n         int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n         int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n         return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             if (generator !\u003d null) {\n                 this.componentScanBeanNameGenerator \u003d generator;\n                 this.importBeanNameGenerator \u003d generator;\n             }\n         }\n     }\n     if (this.environment \u003d\u003d null) {\n         this.environment \u003d new StandardEnvironment();\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n-    if (sbr !\u003d null) {\n-        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n-        }\n+    if (sbr !\u003d null \u0026\u0026 !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668": {
      "type": "Ybodychange",
      "commitMessage": "@Nullable all the way: null-safety at field level\n\nThis commits extends nullability declarations to the field level, formalizing the interaction between methods and their underlying fields and therefore avoiding any nullability mismatch.\n\nIssue: SPR-15720\n",
      "commitDate": "2017/6/30 上午7:54",
      "commitName": "cc74a2891a4d2a4c7bcec059f20c35aa80bcf668",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/6/13 下午3:42",
      "commitNameOld": "fc64b8040f7c76f2bc85387cf944436424ce408c",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 16.67,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -\u003e {\n        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    if (this.environment \u003d\u003d null) {\n        this.environment \u003d new StandardEnvironment();\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 262,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,73 +1,76 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     configCandidates.sort((bd1, bd2) -\u003e {\n         int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n         int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n         return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             if (generator !\u003d null) {\n                 this.componentScanBeanNameGenerator \u003d generator;\n                 this.importBeanNameGenerator \u003d generator;\n             }\n         }\n     }\n+    if (this.environment \u003d\u003d null) {\n+        this.environment \u003d new StandardEnvironment();\n+    }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (sbr !\u003d null) {\n         if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc64b8040f7c76f2bc85387cf944436424ce408c": {
      "type": "Ybodychange",
      "commitMessage": "Polish \"Replace relevant code with lambda\"\n\nCloses gh-1454\n",
      "commitDate": "2017/6/13 下午3:42",
      "commitName": "fc64b8040f7c76f2bc85387cf944436424ce408c",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2017/6/13 下午2:55",
      "commitNameOld": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
      "commitAuthorOld": "diguage",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    configCandidates.sort((bd1, bd2) -\u003e {\n        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 258,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,73 +1,73 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n-    Collections.sort(configCandidates, (bd1, bd2) -\u003e {\n+    configCandidates.sort((bd1, bd2) -\u003e {\n         int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n         int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n         return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             if (generator !\u003d null) {\n                 this.componentScanBeanNameGenerator \u003d generator;\n                 this.importBeanNameGenerator \u003d generator;\n             }\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (sbr !\u003d null) {\n         if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3": {
      "type": "Ybodychange",
      "commitMessage": "Replace relevant code with lambda\n\nSee gh-1454\n",
      "commitDate": "2017/6/13 下午2:55",
      "commitName": "4b1478d830f3cdbc4eb0d50d84f152d7900f30c3",
      "commitAuthor": "diguage",
      "commitDateOld": "2017/6/7 下午8:19",
      "commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 5.78,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, (bd1, bd2) -\u003e {\n        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 260,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,77 +1,73 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n-    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n-\n-        @Override\n-        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n-            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n-            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n-            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n-        }\n+    Collections.sort(configCandidates, (bd1, bd2) -\u003e {\n+        int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+        int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+        return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             if (generator !\u003d null) {\n                 this.componentScanBeanNameGenerator \u003d generator;\n                 this.importBeanNameGenerator \u003d generator;\n             }\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (sbr !\u003d null) {\n         if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/7 下午8:19",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/6/1 上午4:51",
      "commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            if (generator !\u003d null) {\n                this.componentScanBeanNameGenerator \u003d generator;\n                this.importBeanNameGenerator \u003d generator;\n            }\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 260,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,75 +1,77 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \n         @Override\n         public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n             int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n             int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n             return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n         }\n     });\n     SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         sbr \u003d (SingletonBeanRegistry) registry;\n-        if (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+        if (!this.localBeanNameGeneratorSet) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n-            this.componentScanBeanNameGenerator \u003d generator;\n-            this.importBeanNameGenerator \u003d generator;\n+            if (generator !\u003d null) {\n+                this.componentScanBeanNameGenerator \u003d generator;\n+                this.importBeanNameGenerator \u003d generator;\n+            }\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (sbr !\u003d null) {\n         if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2017/4/17 下午9:05",
      "commitName": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/12/30 上午5:39",
      "commitNameOld": "fc629bb508f950fe4a0f62b42395299677f7819e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 108.64,
      "commitsBetweenForRepo": 645,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry sbr \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        sbr \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (sbr !\u003d null) {\n        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 257,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,75 +1,75 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \n         @Override\n         public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n             int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n             int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n             return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n         }\n     });\n-    SingletonBeanRegistry singletonRegistry \u003d null;\n+    SingletonBeanRegistry sbr \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n-        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n-        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+        sbr \u003d (SingletonBeanRegistry) registry;\n+        if (!this.localBeanNameGeneratorSet \u0026\u0026 sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+            BeanNameGenerator generator \u003d (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n-                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n-                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+                    BeanDefinition bd \u003d registry.getBeanDefinition(candidateName);\n+                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(bd.getBeanClassName())) {\n+                        candidates.add(new BeanDefinitionHolder(bd, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n-    if (singletonRegistry !\u003d null) {\n-        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n-            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n+    if (sbr !\u003d null) {\n+        if (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7818c650ba3ad567cff2975b408509679d03e663": {
      "type": "Ybodychange",
      "commitMessage": "Cache ASM metadata at the context level (if supported)\n\nIncludes streamlined ClassPathBeanDefinitionScanner setup.\n\nIssue: SPR-14654\n",
      "commitDate": "2016/12/27 下午8:38",
      "commitName": "7818c650ba3ad567cff2975b408509679d03e663",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/12/20 下午7:16",
      "commitNameOld": "f6b2a212066c97eabdd861044cb72dca78b0f80d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 257,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "",
      "extendedDetails": {}
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016/7/5 下午11:00",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2016/5/2 下午9:19",
      "commitNameOld": "7737c3c7e5e3ffe19e6cc151f1929982f5bba35d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 64.07,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,75 +1,75 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n+    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003c\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \n         @Override\n         public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n             int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n             int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n             return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n         }\n     });\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n-    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n+    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003c\u003e(configCandidates);\n+    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003c\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n-        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n+        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003c\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n-            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n-            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n+            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003c\u003e(Arrays.asList(candidateNames));\n+            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003c\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc": {
      "type": "Ybodychange",
      "commitMessage": "Removed unused fields from ConfigurationClassBeanDefinitionReader\n\nIssue: SPR-11740\nIssue: SPR-13280\n",
      "commitDate": "2015/7/28 下午6:08",
      "commitName": "f0ac2784a4e9602a06bc91c3368f7cf423fc52dc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/3/14 上午1:18",
      "commitNameOld": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 136.7,
      "commitsBetweenForRepo": 821,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,75 +1,75 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n \n         @Override\n         public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n             int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n             int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n             return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n         }\n     });\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n     do {\n         parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n-            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n+            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                         candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!candidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d": {
      "type": "Ybodychange",
      "commitMessage": "@Configuration classes get processed according to their @Order (if applicable)\n\nIssue: SPR-12657\n",
      "commitDate": "2015/3/14 上午1:18",
      "commitName": "f5b4e18209c45c948ab6bce6d166ef17b3f5b25d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/12/2 上午2:16",
      "commitNameOld": "c85686ac78a815d6113371334b8ddcc49f1384ac",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 101.96,
      "commitsBetweenForRepo": 342,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n\n        @Override\n        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n        }\n    });\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    do {\n        parser.parse(candidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        candidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!candidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,65 +1,75 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    List\u003cBeanDefinitionHolder\u003e configCandidates \u003d new ArrayList\u003cBeanDefinitionHolder\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n+    Collections.sort(configCandidates, new Comparator\u003cBeanDefinitionHolder\u003e() {\n+\n+        @Override\n+        public int compare(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2) {\n+            int i1 \u003d ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n+            int i2 \u003d ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n+            return (i1 \u003c i2) ? -1 : (i1 \u003e i2) ? 1 : 0;\n+        }\n+    });\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n+    Set\u003cBeanDefinitionHolder\u003e candidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e(configCandidates);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n     do {\n-        parser.parse(configCandidates);\n+        parser.parse(candidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n-        configCandidates.clear();\n+        candidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n             Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n             for (ConfigurationClass configurationClass : alreadyParsed) {\n                 alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n             }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n-                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+                        candidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n-    } while (!configCandidates.isEmpty());\n+    } while (!candidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4c59d85f690a29c45c644f9c3f13010d5cba84ed": {
      "type": "Ybodychange",
      "commitMessage": "Be defensive adding additional imported configs\n\nRefine the logic introduced in commit 71c6eb2b so that additional\nimported @Configuration classes are not considered as candidates if\nthey have already been parsed.\n\nIssue: SPR-12233\n",
      "commitDate": "2014/9/23 上午6:05",
      "commitName": "4c59d85f690a29c45c644f9c3f13010d5cba84ed",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2014/9/3 下午6:59",
      "commitNameOld": "6563405be5308954394b67608f09af35e7d35b59",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.46,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n            for (ConfigurationClass configurationClass : alreadyParsed) {\n                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n            }\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 266,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,61 +1,65 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n     do {\n         parser.parse(configCandidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         configCandidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n+            Set\u003cString\u003e alreadyParsedClasses \u003d new HashSet\u003cString\u003e();\n+            for (ConfigurationClass configurationClass : alreadyParsed) {\n+                alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n+            }\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n-                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) \u0026\u0026 !alreadyParsedClasses.contains(beanDef.getBeanClassName())) {\n                         configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!configCandidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abc343f4076d45172587197480c41f79c23f3aac": {
      "type": "Ybodychange",
      "commitMessage": "Prevent incorrect ImportAware metdata injection\n\nUpdate ImportRegistry to track all import registrations that occur\nagainst an importing class (rather than just keeping the last). In\naddition, prune imported classes from the registry when a configuration\nclass is removed during the REGISTER_BEAN ConfigurationPhase.\n\nThis update prevents incorrect metadata from being injected into an\nImportAware class which is imported twice by different configurations\nclasses (when one of the configuration classes will be ultimately skipped\ndue to a @Condition).\n\nIssue: SPR-12128\n",
      "commitDate": "2014/9/3 上午11:47",
      "commitName": "abc343f4076d45172587197480c41f79c23f3aac",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2014/8/22 上午4:43",
      "commitNameOld": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 12.29,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n     do {\n         parser.parse(configCandidates);\n         parser.validate();\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n-            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n+            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         configCandidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                         configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!configCandidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": {
      "type": "Ybodychange",
      "commitMessage": "@PropertySource gets parsed as early as possible\n\nOther PropertySources and in particular @ComponentScan can benefit from previously declared property sources on the same configuration class.\n\nIssue: SPR-12110\nIssue: SPR-12111\n",
      "commitDate": "2014/8/22 上午4:43",
      "commitName": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/8/12 下午11:23",
      "commitNameOld": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,76 +1,61 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     String[] candidateNames \u003d registry.getBeanDefinitionNames();\n     for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n-    int propertySourceCount \u003d 0;\n     do {\n         parser.parse(configCandidates);\n         parser.validate();\n-        if (parser.getPropertySourceCount() \u003e propertySourceCount) {\n-            List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-            if (!parsedPropertySources.isEmpty()) {\n-                if (!(this.environment instanceof ConfigurableEnvironment)) {\n-                    logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n-                } else {\n-                    MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-                    for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n-                        envPropertySources.addLast(propertySource);\n-                    }\n-                }\n-            }\n-            propertySourceCount \u003d parser.getPropertySourceCount();\n-        }\n         Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n         configClasses.removeAll(alreadyParsed);\n         if (this.reader \u003d\u003d null) {\n             this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n         }\n         this.reader.loadBeanDefinitions(configClasses);\n         alreadyParsed.addAll(configClasses);\n         configCandidates.clear();\n         if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n             String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n             Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n             for (String candidateName : newCandidateNames) {\n                 if (!oldCandidateNames.contains(candidateName)) {\n                     BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                     if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                         configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                     }\n                 }\n             }\n             candidateNames \u003d newCandidateNames;\n         }\n     } while (!configCandidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71c6eb2bb594f29803b6ec4a50de875def98be86": {
      "type": "Ybodychange",
      "commitMessage": "Additional configuration classes get detected when imported through XML or registrars\n\nIssue: SPR-11430\nIssue: SPR-11723\n",
      "commitDate": "2014/8/12 下午11:23",
      "commitName": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/6/25 下午7:46",
      "commitNameOld": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 48.15,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n    for (String beanName : candidateNames) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n    int propertySourceCount \u003d 0;\n    do {\n        parser.parse(configCandidates);\n        parser.validate();\n        if (parser.getPropertySourceCount() \u003e propertySourceCount) {\n            List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n            if (!parsedPropertySources.isEmpty()) {\n                if (!(this.environment instanceof ConfigurableEnvironment)) {\n                    logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n                } else {\n                    MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n                    for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                        envPropertySources.addLast(propertySource);\n                    }\n                }\n            }\n            propertySourceCount \u003d parser.getPropertySourceCount();\n        }\n        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n        configClasses.removeAll(alreadyParsed);\n        if (this.reader \u003d\u003d null) {\n            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n        }\n        this.reader.loadBeanDefinitions(configClasses);\n        alreadyParsed.addAll(configClasses);\n        configCandidates.clear();\n        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n            for (String candidateName : newCandidateNames) {\n                if (!oldCandidateNames.contains(candidateName)) {\n                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n                    }\n                }\n            }\n            candidateNames \u003d newCandidateNames;\n        }\n    } while (!configCandidates.isEmpty());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 271,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,51 +1,76 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n-    for (String beanName : registry.getBeanDefinitionNames()) {\n+    String[] candidateNames \u003d registry.getBeanDefinitionNames();\n+    for (String beanName : candidateNames) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n             if (logger.isDebugEnabled()) {\n                 logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n             }\n         } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-    parser.parse(configCandidates);\n-    parser.validate();\n-    List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-    if (!parsedPropertySources.isEmpty()) {\n-        if (!(this.environment instanceof ConfigurableEnvironment)) {\n-            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n-        } else {\n-            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-            for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n-                envPropertySources.addLast(propertySource);\n+    Set\u003cConfigurationClass\u003e alreadyParsed \u003d new HashSet\u003cConfigurationClass\u003e(configCandidates.size());\n+    int propertySourceCount \u003d 0;\n+    do {\n+        parser.parse(configCandidates);\n+        parser.validate();\n+        if (parser.getPropertySourceCount() \u003e propertySourceCount) {\n+            List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+            if (!parsedPropertySources.isEmpty()) {\n+                if (!(this.environment instanceof ConfigurableEnvironment)) {\n+                    logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n+                } else {\n+                    MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n+                    for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n+                        envPropertySources.addLast(propertySource);\n+                    }\n+                }\n             }\n+            propertySourceCount \u003d parser.getPropertySourceCount();\n         }\n-    }\n-    if (this.reader \u003d\u003d null) {\n-        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n-    }\n-    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+        Set\u003cConfigurationClass\u003e configClasses \u003d new LinkedHashSet\u003cConfigurationClass\u003e(parser.getConfigurationClasses());\n+        configClasses.removeAll(alreadyParsed);\n+        if (this.reader \u003d\u003d null) {\n+            this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n+        }\n+        this.reader.loadBeanDefinitions(configClasses);\n+        alreadyParsed.addAll(configClasses);\n+        configCandidates.clear();\n+        if (registry.getBeanDefinitionCount() \u003e candidateNames.length) {\n+            String[] newCandidateNames \u003d registry.getBeanDefinitionNames();\n+            Set\u003cString\u003e oldCandidateNames \u003d new HashSet\u003cString\u003e(Arrays.asList(candidateNames));\n+            for (String candidateName : newCandidateNames) {\n+                if (!oldCandidateNames.contains(candidateName)) {\n+                    BeanDefinition beanDef \u003d registry.getBeanDefinition(candidateName);\n+                    if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+                        configCandidates.add(new BeanDefinitionHolder(beanDef, candidateName));\n+                    }\n+                }\n+            }\n+            candidateNames \u003d newCandidateNames;\n+        }\n+    } while (!configCandidates.isEmpty());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6255128bf7a32384f03e985d79b8bb03c3dd8a0": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassPostProcessor skips pre-processed bean definitions now (avoiding side effects in case of multiple CCPPs)\n\nIssue: SPR-11858\n",
      "commitDate": "2014/6/25 下午7:46",
      "commitName": "b6255128bf7a32384f03e985d79b8bb03c3dd8a0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/4/9 下午11:43",
      "commitNameOld": "0041e245a1f80affba828c79fd8db13b0319fb85",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 76.84,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n            }\n        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 270,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,47 +1,51 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef) || ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n+            }\n+        } else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     parser.parse(configCandidates);\n     parser.validate();\n     List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                 envPropertySources.addLast(propertySource);\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eed1a323d10de122a08db26192dc602f9fb173f8": {
      "type": "Ybodychange",
      "commitMessage": "Polishing (along with SPR-10992)\n",
      "commitDate": "2013/11/5 上午6:44",
      "commitName": "eed1a323d10de122a08db26192dc602f9fb173f8",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/10/23 上午2:15",
      "commitNameOld": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 13.19,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 271,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,47 +1,47 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     parser.parse(configCandidates);\n     parser.validate();\n     List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                 envPropertySources.addLast(propertySource);\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n-    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": {
      "type": "Ybodychange",
      "commitMessage": "Add @PropertySources and ignoreResourceNotFound\n\nSupport repeatable @PropertySource annotations in Java 8 and add\n@PropertySources container annotation for Java 6/7. Also add an\nignoreResourceNotFound attribute to @PropertySource allowing missing\nproperty resources to be silently ignored.\n\nThis commit also introduces some generally useful methods to\nAnnotationUtils for working with @Repeatable annotations.\n\nIssue: SPR-8371\n",
      "commitDate": "2013/10/23 上午2:15",
      "commitName": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/8/28 下午6:49",
      "commitNameOld": "bb971cecf15e8c7983cbaf7767851236d132889c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 55.31,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n                envPropertySources.addLast(propertySource);\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 267,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,47 +1,47 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     parser.parse(configCandidates);\n     parser.validate();\n-    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+    List\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-            while (!parsedPropertySources.isEmpty()) {\n-                envPropertySources.addLast(parsedPropertySources.pop());\n+            for (PropertySource\u003c?\u003e propertySource : parsedPropertySources) {\n+                envPropertySources.addLast(propertySource);\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5efe894ee4969a7c3780a2fd4d2ceab695777c50": {
      "type": "Ybodychange",
      "commitMessage": "Not exposing ApplicationContext on ConditionContext anymore\n",
      "commitDate": "2013/8/28 上午6:00",
      "commitName": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/6/21 上午11:21",
      "commitNameOld": "a403e8f8b881c743e5e7a16a26690500595725be",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 67.78,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 268,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,47 +1,47 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry, this.applicationContext);\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     parser.parse(configCandidates);\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n-        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.applicationContext, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n+        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
      "type": "Ybodychange",
      "commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
      "commitDate": "2013/6/13 上午2:45",
      "commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/6/5 上午1:27",
      "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 8.05,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry, this.applicationContext);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.applicationContext, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 265,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,47 +1,47 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry, this.applicationContext);\n     parser.parse(configCandidates);\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n-        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n+        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.applicationContext, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "239ce1466ce118294f5c7b8e842a80815fd813de": {
      "type": "Ybodychange",
      "commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
      "commitDate": "2013/6/5 上午1:27",
      "commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/5/14 上午6:04",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 21.81,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 254,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,51 +1,47 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     parser.parse(configCandidates);\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n-    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n-        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n-            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n-        }\n-    }\n+    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c7fdb07363791fb3c72f4946839f4c166196ebe": {
      "type": "Ybodychange",
      "commitMessage": "Add support for DeferredImportSelector\n\nAdd DeferredImportSelector interface that can be used to select imports\nafter all @Configuration beans have been processed.\n",
      "commitDate": "2013/5/9 上午10:41",
      "commitName": "7c7fdb07363791fb3c72f4946839f4c166196ebe",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/5/9 上午10:41",
      "commitNameOld": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    parser.parse(configCandidates);\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n        }\n    }\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 250,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,62 +1,51 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n-    for (BeanDefinitionHolder holder : configCandidates) {\n-        BeanDefinition bd \u003d holder.getBeanDefinition();\n-        try {\n-            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n-                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n-            } else {\n-                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n-            }\n-        } catch (IOException ex) {\n-            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n-        }\n-    }\n+    parser.parse(configCandidates);\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n         if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n             reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n         }\n     }\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": {
      "type": "Ybodychange",
      "commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the \u0027Condition\u0027 interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
      "commitDate": "2013/5/9 上午10:41",
      "commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/1/2 下午5:33",
      "commitNameOld": "70eaf02b7fab9d8a023ddb50cedcab859e93c245",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 126.71,
      "commitsBetweenForRepo": 540,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n        }\n    }\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 250,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,58 +1,62 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n-    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+    for (ConfigurationClass configurationClass : parser.getConfigurationClasses()) {\n+        if (!ConditionalAnnotationHelper.shouldSkip(configurationClass, registry, this.environment, this.importBeanNameGenerator)) {\n+            reader.loadBeanDefinitionsForConfigurationClass(configurationClass);\n+        }\n+    }\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n     if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n         ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6": {
      "type": "Ybodychange",
      "commitMessage": "Several enhancements with respect to CachingMetadataReaderFactory handling.\n\nAdded \"clearCache()\" method to CachingMetadataReaderFactory, for clearing the metadata cache once not needed anymore - in particular when the MetadataReaderFactory instance is long-lived. Also added \"setMetadataReaderFactory\" method to ClassPathScanningCandidateComponentProvider, analogous to ConfigurationClassPostProcessor.\n",
      "commitDate": "2012/12/12 上午10:29",
      "commitName": "1cb6e3dbb6e5a5f15ec06f4abc297821606ab2a6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/9/24 下午5:26",
      "commitNameOld": "dc4e0683aeccdabfa212d20a5335e81af13cd6d4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 78.71,
      "commitsBetweenForRepo": 393,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 249,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,55 +1,58 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n         if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n             BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n             this.componentScanBeanNameGenerator \u003d generator;\n             this.importBeanNameGenerator \u003d generator;\n         }\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n         this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n         if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n             singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n+    if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n+        ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a42c80c1151380f7f492ec75de5648cfe62d250": {
      "type": "Ybodychange",
      "commitMessage": "@Import\u0027ed configuration classes get properly registered in case of same class name (second try)\n\nIssue: SPR-9243\n",
      "commitDate": "2012/9/11 上午5:16",
      "commitName": "0a42c80c1151380f7f492ec75de5648cfe62d250",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/8/10 上午6:38",
      "commitNameOld": "92500ab9023ae2afd096be9c014423fcd4180c55",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 31.94,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    SingletonBeanRegistry singletonRegistry \u003d null;\n    if (registry instanceof SingletonBeanRegistry) {\n        singletonRegistry \u003d (SingletonBeanRegistry) registry;\n        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n            this.componentScanBeanNameGenerator \u003d generator;\n            this.importBeanNameGenerator \u003d generator;\n        }\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    if (this.reader \u003d\u003d null) {\n        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n    }\n    this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (singletonRegistry !\u003d null) {\n        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n        }\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 246,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,53 +1,55 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     SingletonBeanRegistry singletonRegistry \u003d null;\n     if (registry instanceof SingletonBeanRegistry) {\n         singletonRegistry \u003d (SingletonBeanRegistry) registry;\n-        if (singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n-            this.beanNameGenerator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+        if (!this.localBeanNameGeneratorSet \u0026\u0026 singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) {\n+            BeanNameGenerator generator \u003d (BeanNameGenerator) singletonRegistry.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n+            this.componentScanBeanNameGenerator \u003d generator;\n+            this.importBeanNameGenerator \u003d generator;\n         }\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.beanNameGenerator, registry);\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     if (this.reader \u003d\u003d null) {\n-        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.beanNameGenerator);\n+        this.reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory, this.resourceLoader, this.environment, this.importBeanNameGenerator);\n     }\n     this.reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (singletonRegistry !\u003d null) {\n-        if (!singletonRegistry.containsSingleton(\"importRegistry\")) {\n-            singletonRegistry.registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+        if (!singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n+            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 212,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
        "newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java"
      }
    },
    "4520ea8690fa8769a2d45658883eac51ea2453ed": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
      "commitDate": "2011/5/18 下午4:53",
      "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
          "commitDate": "2011/5/18 下午4:53",
          "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/5/18 上午3:15",
          "commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 215,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,43 +1,43 @@\n-public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n-    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
            "newValue": "[registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert #processConfigBeanDefinitions to 3.0.x API\n\nRevert signature of\nConfigurationClassPostProcessor#processConfigBeanDefinitions to its form\nfound in the 3.0.x line.  Refactorings made during 3.1 development\ncaused otherwise package-private types such as\nConfigurationClassBeanDefinitionReader to escape through this public\nmethod, causing issues for STS as well as being a general design issue.\n\nUpon review, the refactorings could easily be backed out in favor of a\nsimpler approach, and this has been done.\n\nThis also means that ConfigurationClassBeanDefinitionReader can return\nto package-private visibility, and this change has been made as well.\n\nIssue: SPR-8200\n",
          "commitDate": "2011/5/18 下午4:53",
          "commitName": "4520ea8690fa8769a2d45658883eac51ea2453ed",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/5/18 上午3:15",
          "commitNameOld": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.57,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 215,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,43 +1,43 @@\n-public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n-    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+    this.getConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6fcea8b99da45f287149796ef2598f0d71758793": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
      "commitDate": "2011/5/18 上午3:15",
      "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
          "commitDate": "2011/5/18 上午3:15",
          "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/5/12 下午8:27",
          "commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.28,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 216,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,42 +1,43 @@\n-public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]",
            "newValue": "[reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove ConfigurationClassParser from public API\n\nIssue: SPR-8200\n",
          "commitDate": "2011/5/18 上午3:15",
          "commitName": "6fcea8b99da45f287149796ef2598f0d71758793",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/5/12 下午8:27",
          "commitNameOld": "57206db15271f865b542264c74980e6cbb4681fd",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 5.28,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 216,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,42 +1,43 @@\n-public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, registry);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n     if (!parsedPropertySources.isEmpty()) {\n         if (!(this.environment instanceof ConfigurableEnvironment)) {\n             logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n         } else {\n             MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n             while (!parsedPropertySources.isEmpty()) {\n                 envPropertySources.addLast(parsedPropertySources.pop());\n             }\n         }\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "57206db15271f865b542264c74980e6cbb4681fd": {
      "type": "Ybodychange",
      "commitMessage": "Refine ignored @PropertySource log warning\n\nIf the enclosing environment does not implement ConfigurableEnvironment,\nthen @PropertySource annotations are ignored because there is no way to\nadd them to the Environment. Now checking first to see if there are any\n@PropertySource annotations present before issuing the warning.\n\nIssue: SPR-8314\n",
      "commitDate": "2011/5/12 下午8:27",
      "commitName": "57206db15271f865b542264c74980e6cbb4681fd",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/11 下午9:28",
      "commitNameOld": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n    if (!parsedPropertySources.isEmpty()) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n            while (!parsedPropertySources.isEmpty()) {\n                envPropertySources.addLast(parsedPropertySources.pop());\n            }\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 218,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,40 +1,42 @@\n public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    if (!(this.environment instanceof ConfigurableEnvironment)) {\n-        logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n-    } else {\n-        MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n-        Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n-        while (!parsedPropertySources.isEmpty()) {\n-            envPropertySources.addLast(parsedPropertySources.pop());\n+    Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+    if (!parsedPropertySources.isEmpty()) {\n+        if (!(this.environment instanceof ConfigurableEnvironment)) {\n+            logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n+        } else {\n+            MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n+            while (!parsedPropertySources.isEmpty()) {\n+                envPropertySources.addLast(parsedPropertySources.pop());\n+            }\n         }\n     }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8bc54e0ccad49f0785856f911349283619eb8ba": {
      "type": "Ybodychange",
      "commitMessage": "Introduce @PropertySource\n\nAllows a convenient mechanism for contributing a PropertySource to the\nenclosing Spring Environment. See @PropertySource Javadoc for\ncomplete details and PropertySourceAnnotationTests for examples.\n\nIssue: SPR-8314\n",
      "commitDate": "2011/5/11 下午9:28",
      "commitName": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/8 下午9:49",
      "commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    if (!(this.environment instanceof ConfigurableEnvironment)) {\n        logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n    } else {\n        MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n        Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n        while (!parsedPropertySources.isEmpty()) {\n            envPropertySources.addLast(parsedPropertySources.pop());\n        }\n    }\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 218,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,31 +1,40 @@\n public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n+    if (!(this.environment instanceof ConfigurableEnvironment)) {\n+        logger.warn(\"Ignoring @PropertySource annotations. \" + \"Reason: Environment must implement ConfigurableEnvironment\");\n+    } else {\n+        MutablePropertySources envPropertySources \u003d ((ConfigurableEnvironment) this.environment).getPropertySources();\n+        Stack\u003cPropertySource\u003c?\u003e\u003e parsedPropertySources \u003d parser.getPropertySources();\n+        while (!parsedPropertySources.isEmpty()) {\n+            envPropertySources.addLast(parsedPropertySources.pop());\n+        }\n+    }\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": {
      "type": "Ybodychange",
      "commitMessage": "Allow recursive use of @ComponentScan\n\nPrior to this change, @ComponentScan annotations were only processed at\nthe first level of depth.  Now, the set of bean definitions resulting\nfrom each declaration of @ComponentScan is checked for configuration\nclasses that declare @ComponentScan, and recursion is performed as\nnecessary.\n\nCycles between @ComponentScan declarations are detected as well. See\nCircularComponentScanException.\n\nIssue: SPR-8307\n",
      "commitDate": "2011/5/8 下午9:49",
      "commitName": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/7 上午3:05",
      "commitNameOld": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 214,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,31 +1,31 @@\n public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n+        if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n     if (registry instanceof SingletonBeanRegistry) {\n         if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n             ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdb01cbd3795f273b751d0f0a45caa22d07c62da": {
      "type": "Ybodychange",
      "commitMessage": "Introduce ImportAware interface\n\n@Configuration classes may implement ImportAware in order to be injected\nwith the AnnotationMetadata of their @Import\u0027ing class.\n\nIncludes the introduction of a new PriorityOrdered\nImportAwareBeanPostProcessor that handles injection of the\nimporting class metadata.\n",
      "commitDate": "2011/5/7 上午3:05",
      "commitName": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/7 上午3:03",
      "commitNameOld": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n    if (registry instanceof SingletonBeanRegistry) {\n        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n        }\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 213,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,26 +1,31 @@\n public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n+    if (registry instanceof SingletonBeanRegistry) {\n+        if (!((SingletonBeanRegistry) registry).containsSingleton(\"importRegistry\")) {\n+            ((SingletonBeanRegistry) registry).registerSingleton(\"importRegistry\", parser.getImportRegistry());\n+        }\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
      "commitDate": "2011/5/7 上午3:03",
      "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
          "commitDate": "2011/5/7 上午3:03",
          "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/3/15 下午3:09",
          "commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 52.5,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 201,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,27 +1,26 @@\n-public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]",
            "newValue": "[parser-ConfigurationClassParser, reader-ConfigurationClassBeanDefinitionReader, registry-BeanDefinitionRegistry]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Remove \"Feature\" support introduced in 3.1 M1\n\nFeature-related support such as @Feature, @FeatureConfiguration,\nand FeatureSpecification types will be replaced by framework-provided\n@Configuration classes and convenience annotations such as\n@ComponentScan (already exists), @EnableAsync, @EnableScheduling,\n@EnableTransactionManagement and others.\n\nIssue: SPR-8012,SPR-8034,SPR-8039,SPR-8188,SPR-8206,SPR-8223,\nSPR-8225,SPR-8226,SPR-8227\n",
          "commitDate": "2011/5/7 上午3:03",
          "commitName": "111fb71fe1ccb8d3a5e06e61461edd87d6d025f4",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/3/15 下午3:09",
          "commitNameOld": "d471266d44199112b6e030615a395209e5265ec0",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 52.5,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 201,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,27 +1,26 @@\n-public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n+public void processConfigBeanDefinitions(ConfigurationClassParser parser, ConfigurationClassBeanDefinitionReader reader, BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b4fea47d5cff9f3c85e62c233c2fe86b1d616592": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
      "commitDate": "2011/2/8 下午10:42",
      "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011/2/8 下午10:42",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/1/3 下午5:04",
          "commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 36.23,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 380,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,28 +1,27 @@\n-public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[registry-BeanDefinitionRegistry]",
            "newValue": "[registry-BeanDefinitionRegistry, reader-ConfigurationClassBeanDefinitionReader]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Introduce FeatureSpecification support\n\nIntroduce FeatureSpecification interface and implementations\n\n    FeatureSpecification objects decouple the configuration of\n    spring container features from the concern of parsing XML\n    namespaces, allowing for reuse in code-based configuration\n    (see @Feature* annotations below).\n\n    * ComponentScanSpec\n    * TxAnnotationDriven\n    * MvcAnnotationDriven\n    * MvcDefaultServletHandler\n    * MvcResources\n    * MvcViewControllers\n\nRefactor associated BeanDefinitionParsers to delegate to new impls above\n\n    The following BeanDefinitionParser implementations now deal only\n    with the concern of XML parsing.  Validation is handled by their\n    corresponding FeatureSpecification object.  Bean definition creation\n    and registration is handled by their corresponding\n    FeatureSpecificationExecutor type.\n\n    * ComponentScanBeanDefinitionParser\n    * AnnotationDrivenBeanDefinitionParser (tx)\n    * AnnotationDrivenBeanDefinitionParser (mvc)\n    * DefaultServletHandlerBeanDefinitionParser\n    * ResourcesBeanDefinitionParser\n    * ViewControllerBeanDefinitionParser\n\nUpdate AopNamespaceUtils to decouple from XML (DOM API)\n\n    Methods necessary for executing TxAnnotationDriven specification\n    (and eventually, the AspectJAutoProxy specification) have been\n    added that accept boolean arguments for whether to proxy\n    target classes and whether to expose the proxy via threadlocal.\n\n    Methods that accepted and introspected DOM Element objects still\n    exist but have been deprecated.\n\nIntroduce @FeatureConfiguration classes and @Feature methods\n\n    Allow for creation and configuration of FeatureSpecification objects\n    at the user level.  A companion for @Configuration classes allowing\n    for completely code-driven configuration of the Spring container.\n\n    See changes in ConfigurationClassPostProcessor for implementation\n    details.\n\n    See Feature*Tests for usage examples.\n\n    FeatureTestSuite in .integration-tests is a JUnit test suite designed\n    to aggregate all BDP and Feature* related tests for a convenient way\n    to confirm that Feature-related changes don\u0027t break anything.\n    Uncomment this test and execute from Eclipse / IDEA. Due to classpath\n    issues, this cannot be compiled by Ant/Ivy at the command line.\n\nIntroduce @FeatureAnnotation meta-annotation and @ComponentScan impl\n\n    @FeatureAnnotation provides an alternate mechanism for creating\n    and executing FeatureSpecification objects.  See @ComponentScan\n    and its corresponding ComponentScanAnnotationParser implementation\n    for details.  See ComponentScanAnnotationIntegrationTests for usage\n    examples\n\nIntroduce Default[Formatting]ConversionService implementations\n\n    Allows for convenient instantiation of ConversionService objects\n    containing defaults appropriate for most environments.  Replaces\n    similar support originally in ConversionServiceFactory (which is now\n    deprecated). This change was justified by the need to avoid use\n    of FactoryBeans in @Configuration classes (such as\n    FormattingConversionServiceFactoryBean). It is strongly preferred\n    that users simply instantiate and configure the objects that underlie\n    our FactoryBeans. In the case of the ConversionService types, the\n    easiest way to do this is to create Default* subtypes. This also\n    follows convention with the rest of the framework.\n\nMinor updates to util classes\n\n    All in service of changes above. See diffs for self-explanatory\n    details.\n\n    * BeanUtils\n    * ObjectUtils\n    * ReflectionUtils\n",
          "commitDate": "2011/2/8 下午10:42",
          "commitName": "b4fea47d5cff9f3c85e62c233c2fe86b1d616592",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2011/1/3 下午5:04",
          "commitNameOld": "b3ff9be78f62ff1d13ab874a4772f8fc6d189eb4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 36.23,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 380,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,28 +1,27 @@\n-public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(BeanDefinitionRegistry registry, ConfigurationClassBeanDefinitionReader reader) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "f480333d31d8307b8c96409e7bb4f06ec0cab0ca": {
      "type": "Ybodychange",
      "commitMessage": "Merge 3.1.0 development branch into trunk\n\nBranch in question is \u0027env\u0027 branch from git://git.springsource.org/sandbox/cbeams.git; merged into\ngit-svn repository with:\n\n    git merge -s recursive -Xtheirs --no-commit env\n\nNo merge conflicts, but did need to\n\n    git rm spring-build\n\nprior to committing.\n\nWith this change, Spring 3.1.0 development is now happening on SVN\ntrunk. Further commits to the 3.0.x line will happen in an as-yet\nuncreated SVN branch.  3.1.0 snapshots will be available\nper the usual nightly CI build from trunk.\n",
      "commitDate": "2010/10/26 上午3:48",
      "commitName": "f480333d31d8307b8c96409e7bb4f06ec0cab0ca",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2010/6/8 上午6:36",
      "commitNameOld": "8446fd1b26719fd8ea9e8a8d8258ceec9f27b9ed",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 139.88,
      "commitsBetweenForRepo": 376,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 178,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,28 +1,28 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n     reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fbd797e50b2f1c5b0dfef944ee218d826f1a0694": {
      "type": "Ybodychange",
      "commitMessage": "RESOLVED - issue SPR-6779: imported @Configuration classes do not get enhanced and fail to satisfy scoping requirements\nrefactoring, polishing.\n\n",
      "commitDate": "2010/1/30 上午7:31",
      "commitName": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/11/7 上午8:32",
      "commitNameOld": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 83.96,
      "commitsBetweenForRepo": 508,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 144,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,27 +1,28 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-        if (checkConfigurationClassCandidate(beanDef)) {\n+        if (ConfigurationClassBeanDefinitionReader.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n+    ConfigurationClassBeanDefinitionReader reader \u003d new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.problemReporter, this.metadataReaderFactory);\n+    reader.loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a4463fb71e6901a943a5bafc9d1957da2229333": {
      "type": "Ybodychange",
      "commitMessage": "SPR-6158: Initial implementation and tests for @ImportXml\n\n",
      "commitDate": "2009/11/7 上午8:32",
      "commitName": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/9/24 下午6:45",
      "commitNameOld": "b8c1130eec0732091426908a90db66e4eddeb25c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 43.57,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 154,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,27 +1,27 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (checkConfigurationClassCandidate(beanDef)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n+    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getConfigurationClasses());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cce6e2f4cdfed4233805a32fb82626fa5e901cc0": {
      "type": "Ybodychange",
      "commitMessage": "added SourceExtractor support\n",
      "commitDate": "2009/5/13 上午6:27",
      "commitName": "cce6e2f4cdfed4233805a32fb82626fa5e901cc0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/5/13 上午12:13",
      "commitNameOld": "12d6aa232ab6066e885093e4a70a8386fdf9902d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 154,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,27 +1,27 @@\n public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (checkConfigurationClassCandidate(beanDef)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n-    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n+    new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a6124793fc44779b569fbbba6fd4ec8804b56558": {
      "type": "Ymodifierchange",
      "commitMessage": "polishing\n",
      "commitDate": "2009/5/5 下午5:36",
      "commitName": "a6124793fc44779b569fbbba6fd4ec8804b56558",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/26 下午7:41",
      "commitNameOld": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 126,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,27 +1,27 @@\n-protected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (checkConfigurationClassCandidate(beanDef)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[public]"
      }
    },
    "cea8f7f69e8939d4d20073862890f0b1c1824499": {
      "type": "Ymodifierchange",
      "commitMessage": "custom stereotype annotations can be meta-annotated with @Service, @Controller etc as well; @Scope and @Transactional are now supported as meta-annotations on custom annotations\n",
      "commitDate": "2009/4/26 下午7:41",
      "commitName": "cea8f7f69e8939d4d20073862890f0b1c1824499",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/24 下午7:16",
      "commitNameOld": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 126,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,27 +1,27 @@\n-protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+protected void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (checkConfigurationClassCandidate(beanDef)) {\n             configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configCandidates) {\n         BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n             if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                 parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n             } else {\n                 parser.parse(bd.getBeanClassName(), holder.getBeanName());\n             }\n         } catch (IOException ex) {\n             throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[protected, final]",
        "newValue": "[protected]"
      }
    },
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": {
      "type": "Ybodychange",
      "commitMessage": "@Configuration parsing fully relies on Spring\u0027s MetadataReader abstraction now\n",
      "commitDate": "2009/4/24 下午7:16",
      "commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/22 下午6:46",
      "commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassCandidate(beanDef)) {\n            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configCandidates.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configCandidates) {\n        BeanDefinition bd \u003d holder.getBeanDefinition();\n        try {\n            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n            } else {\n                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n            }\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 124,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,23 +1,27 @@\n protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n-    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    Set\u003cBeanDefinitionHolder\u003e configCandidates \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n-        if (checkConfigurationClassBeanDefinition(beanDef)) {\n-            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        if (checkConfigurationClassCandidate(beanDef)) {\n+            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n-    if (configBeanDefs.isEmpty()) {\n+    if (configCandidates.isEmpty()) {\n         return;\n     }\n     ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n-    for (BeanDefinitionHolder holder : configBeanDefs) {\n-        String beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n+    for (BeanDefinitionHolder holder : configCandidates) {\n+        BeanDefinition bd \u003d holder.getBeanDefinition();\n         try {\n-            parser.parse(beanClassName, holder.getBeanName());\n+            if (bd instanceof AbstractBeanDefinition \u0026\u0026 ((AbstractBeanDefinition) bd).hasBeanClass()) {\n+                parser.parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());\n+            } else {\n+                parser.parse(bd.getBeanClassName(), holder.getBeanName());\n+            }\n         } catch (IOException ex) {\n-            throw new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+            throw new BeanDefinitionStoreException(\"Failed to load bean class: \" + bd.getBeanClassName(), ex);\n         }\n     }\n     parser.validate();\n     new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
      "type": "Ybodychange",
      "commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
      "commitDate": "2009/4/22 下午6:46",
      "commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/20 上午7:45",
      "commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        String beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n        try {\n            parser.parse(beanClassName, holder.getBeanName());\n        } catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n        }\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
      "functionStartLine": 124,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
      "diff": "@@ -1,18 +1,23 @@\n protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n     Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n     for (String beanName : registry.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n         if (checkConfigurationClassBeanDefinition(beanDef)) {\n             configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n         }\n     }\n     if (configBeanDefs.isEmpty()) {\n         return;\n     }\n-    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter);\n     for (BeanDefinitionHolder holder : configBeanDefs) {\n-        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+        String beanClassName \u003d holder.getBeanDefinition().getBeanClassName();\n+        try {\n+            parser.parse(beanClassName, holder.getBeanName());\n+        } catch (IOException ex) {\n+            throw new BeanDefinitionStoreException(\"Failed to load bean class [\" + beanClassName + \"]\", ex);\n+        }\n     }\n     parser.validate();\n     new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14bd47551900ced88eeacf2a5f63c187ff72028c": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ybodychange,Ydocchange,Yparameterchange)",
      "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
      "commitDate": "2009/4/20 上午7:45",
      "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009/4/20 上午7:45",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/4/20 上午6:28",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,14 +1,18 @@\n-protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n-    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-        return configBeanDefs;\n-    ConfigurationClassParser parser \u003d createConfigurationParser();\n-    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n-        String className \u003d beanDef.getBeanClassName();\n-        parser.parse(className, beanName);\n+protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    for (String beanName : registry.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+        if (checkConfigurationClassBeanDefinition(beanDef)) {\n+            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        }\n     }\n-    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    configModel.validate(problemReporter);\n-    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    if (configBeanDefs.isEmpty()) {\n+        return;\n+    }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    for (BeanDefinitionHolder holder : configBeanDefs) {\n+        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    }\n+    parser.validate();\n+    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java",
            "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
            "oldMethodName": "processConfigBeanDefinitions",
            "newMethodName": "processConfigBeanDefinitions"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009/4/20 上午7:45",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/4/20 上午6:28",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,14 +1,18 @@\n-protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n-    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-        return configBeanDefs;\n-    ConfigurationClassParser parser \u003d createConfigurationParser();\n-    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n-        String className \u003d beanDef.getBeanClassName();\n-        parser.parse(className, beanName);\n+protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    for (String beanName : registry.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+        if (checkConfigurationClassBeanDefinition(beanDef)) {\n+            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        }\n     }\n-    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    configModel.validate(problemReporter);\n-    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    if (configBeanDefs.isEmpty()) {\n+        return;\n+    }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    for (BeanDefinitionHolder holder : configBeanDefs) {\n+        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    }\n+    parser.validate();\n+    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "BeanDefinitionRegistry",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009/4/20 上午7:45",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/4/20 上午6:28",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,14 +1,18 @@\n-protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n-    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-        return configBeanDefs;\n-    ConfigurationClassParser parser \u003d createConfigurationParser();\n-    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n-        String className \u003d beanDef.getBeanClassName();\n-        parser.parse(className, beanName);\n+protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    for (String beanName : registry.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+        if (checkConfigurationClassBeanDefinition(beanDef)) {\n+            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        }\n     }\n-    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    configModel.validate(problemReporter);\n-    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    if (configBeanDefs.isEmpty()) {\n+        return;\n+    }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    for (BeanDefinitionHolder holder : configBeanDefs) {\n+        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    }\n+    parser.validate();\n+    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009/4/20 上午7:45",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/4/20 上午6:28",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,14 +1,18 @@\n-protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n-    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-        return configBeanDefs;\n-    ConfigurationClassParser parser \u003d createConfigurationParser();\n-    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n-        String className \u003d beanDef.getBeanClassName();\n-        parser.parse(className, beanName);\n+protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    for (String beanName : registry.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+        if (checkConfigurationClassBeanDefinition(beanDef)) {\n+            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        }\n     }\n-    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    configModel.validate(problemReporter);\n-    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    if (configBeanDefs.isEmpty()) {\n+        return;\n+    }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    for (BeanDefinitionHolder holder : configBeanDefs) {\n+        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    }\n+    parser.validate();\n+    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
            "newValue": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
          "commitDate": "2009/4/20 上午7:45",
          "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/4/20 上午6:28",
          "commitNameOld": "736169aa2a46f489cd8e75cf4d61cef997fc456f",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 0.05,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n    for (String beanName : registry.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n        if (checkConfigurationClassBeanDefinition(beanDef)) {\n            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n        }\n    }\n    if (configBeanDefs.isEmpty()) {\n        return;\n    }\n    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n    for (BeanDefinitionHolder holder : configBeanDefs) {\n        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n    }\n    parser.validate();\n    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n}",
          "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassPostProcessor.java",
          "functionStartLine": 120,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a configuration model based on the registry of\n{@link Configuration} classes.\n",
          "diff": "@@ -1,14 +1,18 @@\n-protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n-    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n-    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n-        return configBeanDefs;\n-    ConfigurationClassParser parser \u003d createConfigurationParser();\n-    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n-        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n-        String className \u003d beanDef.getBeanClassName();\n-        parser.parse(className, beanName);\n+protected final void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n+    Set\u003cBeanDefinitionHolder\u003e configBeanDefs \u003d new LinkedHashSet\u003cBeanDefinitionHolder\u003e();\n+    for (String beanName : registry.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d registry.getBeanDefinition(beanName);\n+        if (checkConfigurationClassBeanDefinition(beanDef)) {\n+            configBeanDefs.add(new BeanDefinitionHolder(beanDef, beanName));\n+        }\n     }\n-    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    configModel.validate(problemReporter);\n-    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n+    if (configBeanDefs.isEmpty()) {\n+        return;\n+    }\n+    ConfigurationClassParser parser \u003d new ConfigurationClassParser(this.problemReporter, this.beanClassLoader);\n+    for (BeanDefinitionHolder holder : configBeanDefs) {\n+        parser.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    }\n+    parser.validate();\n+    new ConfigurationClassBeanDefinitionReader(registry).loadBeanDefinitions(parser.getModel());\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[registry-BeanDefinitionRegistry]"
          }
        }
      ]
    },
    "cc713ad5241a90bc66b96364b91e5439f1ae6cb6": {
      "type": "Ybodychange",
      "commitMessage": "RESOLVED - issue SPR-5600: Make naming of @Configuration class processing-related artifacts consistent\n",
      "commitDate": "2009/3/30 下午11:26",
      "commitName": "cc713ad5241a90bc66b96364b91e5439f1ae6cb6",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/27 下午12:57",
      "commitNameOld": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationClassParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 97,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
      "diff": "@@ -1,14 +1,14 @@\n protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n-    ConfigurationParser parser \u003d createConfigurationParser();\n+    ConfigurationClassParser parser \u003d createConfigurationParser();\n     for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n         String className \u003d beanDef.getBeanClassName();\n         parser.parse(className, beanName);\n     }\n     ConfigurationModel configModel \u003d parser.getConfigurationModel();\n     configModel.validate(problemReporter);\n     return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1697932c57af5389fe07971e91866980e966403f": {
      "type": "Yfilerename",
      "commitMessage": "consolidated context.annotation.support -\u003e context.annotation\n\n",
      "commitDate": "2009/3/27 下午12:57",
      "commitName": "1697932c57af5389fe07971e91866980e966403f",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/27 上午11:10",
      "commitNameOld": "2c0c523d7099ed1ad77864242f25d30e218b2a95",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 97,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/AbstractConfigurationClassProcessor.java"
      }
    },
    "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7": {
      "type": "Yfilerename",
      "commitMessage": "+ Moving .config.java module -\u003e .context\n\n",
      "commitDate": "2009/3/23 下午12:48",
      "commitName": "cd50e456457ecac48f61e2da991b6fd5dc0c6ee7",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/23 下午12:25",
      "commitNameOld": "63b5c48461f69cc611f4378d52f46197998334db",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 98,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
        "newPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java"
      }
    },
    "ef02c61e581dcd1f3cf110608da72ed133777d62": {
      "type": "Yfilerename",
      "commitMessage": "+ Repackaged src and test from .config.java.* -\u003e .context.annotation.*\n\n",
      "commitDate": "2009/3/23 下午12:23",
      "commitName": "ef02c61e581dcd1f3cf110608da72ed133777d62",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/23 下午12:14",
      "commitNameOld": "3f196517f99b7a7148e68531d1fa1b475ff81939",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 98,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
        "newPath": "org.springframework.config.java/src/main/java/org/springframework/context/annotation/support/AbstractConfigurationClassProcessor.java"
      }
    },
    "b8f712621d56b2d862338a34d52839583dc1a80a": {
      "type": "Ybodychange",
      "commitMessage": "+ Added isCglibClassName() to AopUtils for checking bean class names before classloading\n+ Added tests for @Aspect support in @Configuration classes\n+ Added tests for @Inherited @Configuration behavior\n\n",
      "commitDate": "2009/3/23 上午11:59",
      "commitName": "b8f712621d56b2d862338a34d52839583dc1a80a",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/8 上午5:41",
      "commitNameOld": "dc191bec2dfceb7ee052ac238c84eb564d27e1ee",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 15.26,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    configModel.validate(problemReporter);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 98,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
      "diff": "@@ -1,14 +1,14 @@\n protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n     ConfigurationParser parser \u003d createConfigurationParser();\n     for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n         BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n         String className \u003d beanDef.getBeanClassName();\n         parser.parse(className, beanName);\n     }\n     ConfigurationModel configModel \u003d parser.getConfigurationModel();\n-    validateModel(configModel);\n+    configModel.validate(problemReporter);\n     return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e7e98248724f5f4fc054617765053e7d7b978cd": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "+ Renamed Scopes -\u003e StandardScopes\n+ Renamed ConfigurationPostProcessor -\u003e ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
      "commitDate": "2009/3/6 下午2:55",
      "commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
      "commitAuthor": "Chris Beams",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "+ Renamed Scopes -\u003e StandardScopes\n+ Renamed ConfigurationPostProcessor -\u003e ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
          "commitDate": "2009/3/6 下午2:55",
          "commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009/3/6 上午11:12",
          "commitNameOld": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    validateModel(configModel);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
          "functionStartLine": 83,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
          "diff": "@@ -1,8 +1,14 @@\n-protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n-    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n+    ConfigurationParser parser \u003d createConfigurationParser();\n+    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n+        String className \u003d beanDef.getBeanClassName();\n+        parser.parse(className, beanName);\n+    }\n+    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n     validateModel(configModel);\n-    return renderModelAsBeanDefinitions(configModel);\n+    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[protected, final]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "+ Renamed Scopes -\u003e StandardScopes\n+ Renamed ConfigurationPostProcessor -\u003e ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
          "commitDate": "2009/3/6 下午2:55",
          "commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009/3/6 上午11:12",
          "commitNameOld": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    validateModel(configModel);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
          "functionStartLine": 83,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
          "diff": "@@ -1,8 +1,14 @@\n-protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n-    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n+    ConfigurationParser parser \u003d createConfigurationParser();\n+    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n+        String className \u003d beanDef.getBeanClassName();\n+        parser.parse(className, beanName);\n+    }\n+    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n     validateModel(configModel);\n-    return renderModelAsBeanDefinitions(configModel);\n+    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "+ Renamed Scopes -\u003e StandardScopes\n+ Renamed ConfigurationPostProcessor -\u003e ConfigurationClassPostProcessor\n+ JavaDoc and polish for AbstractConfigurationClassProcessor\n\n",
          "commitDate": "2009/3/6 下午2:55",
          "commitName": "2e7e98248724f5f4fc054617765053e7d7b978cd",
          "commitAuthor": "Chris Beams",
          "commitDateOld": "2009/3/6 上午11:12",
          "commitNameOld": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
          "commitAuthorOld": "Chris Beams",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationParser parser \u003d createConfigurationParser();\n    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n        String className \u003d beanDef.getBeanClassName();\n        parser.parse(className, beanName);\n    }\n    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n    validateModel(configModel);\n    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n}",
          "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
          "functionStartLine": 83,
          "functionName": "processConfigBeanDefinitions",
          "functionAnnotation": "",
          "functionDoc": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n",
          "diff": "@@ -1,8 +1,14 @@\n-protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+protected final BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n-    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n+    ConfigurationParser parser \u003d createConfigurationParser();\n+    for (String beanName : configBeanDefs.getBeanDefinitionNames()) {\n+        BeanDefinition beanDef \u003d configBeanDefs.getBeanDefinition(beanName);\n+        String className \u003d beanDef.getBeanClassName();\n+        parser.parse(className, beanName);\n+    }\n+    ConfigurationModel configModel \u003d parser.getConfigurationModel();\n     validateModel(configModel);\n-    return renderModelAsBeanDefinitions(configModel);\n+    return new ConfigurationModelBeanDefinitionReader().loadBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Build and validate a {@link ConfigurationModel} based on the registry of\n{@link Configuration} classes provided by {@link #getConfigurationBeanDefinitions},\nthen, based on the content of that model, create and register bean definitions\nagainst a new {@link BeanDefinitionRegistry}, then return the registry.\n\n@return registry containing one bean definition per {@link Bean} method declared\nwithin the Configuration classes\n"
          }
        }
      ]
    },
    "b985011b24cb40671ad6d2b8cc34fbea763ed7a4": {
      "type": "Ybodychange",
      "commitMessage": "+ Fleshed out, documented, tested and polished the ConfigurationPostProcessor implementation\n+ Removed @FactoryMethod indirection and extension point in favor of direct processing of @Bean annotations\n\n",
      "commitDate": "2009/3/6 上午11:12",
      "commitName": "b985011b24cb40671ad6d2b8cc34fbea763ed7a4",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/6 上午8:38",
      "commitNameOld": "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 17,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,10 +1,8 @@\n protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n-    if (Package.getPackage(CGLIB_PACKAGE) \u003d\u003d null)\n-        throw new RuntimeException(\"CGLIB is required to process @Configuration classes. \" + \"Either add CGLIB v2.2.3 to the classpath or remove the following \" + \"@Configuration bean definitions: [\" + arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n     ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n     validateModel(configModel);\n     return renderModelAsBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf": {
      "type": "Ybodychange",
      "commitMessage": "Initial work to ensure CGLIB classes are not eagerly loaded (CGLIB should only be required if Spring users wish to process @Configuration classes)\n",
      "commitDate": "2009/3/6 上午8:38",
      "commitName": "43b2a40343be4d4a2ad12cf4dbdc0a76ddeaedbf",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/3/6 上午4:08",
      "commitNameOld": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    if (Package.getPackage(CGLIB_PACKAGE) \u003d\u003d null)\n        throw new RuntimeException(\"CGLIB is required to process @Configuration classes. \" + \"Either add CGLIB v2.2.3 to the classpath or remove the following \" + \"@Configuration bean definitions: [\" + arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 20,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,8 +1,10 @@\n protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n     BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n     if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n         return configBeanDefs;\n+    if (Package.getPackage(CGLIB_PACKAGE) \u003d\u003d null)\n+        throw new RuntimeException(\"CGLIB is required to process @Configuration classes. \" + \"Either add CGLIB v2.2.3 to the classpath or remove the following \" + \"@Configuration bean definitions: [\" + arrayToCommaDelimitedString(configBeanDefs.getBeanDefinitionNames()) + \"]\");\n     ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n     validateModel(configModel);\n     return renderModelAsBeanDefinitions(configModel);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39": {
      "type": "Yintroduced",
      "commitMessage": "+ Adding POC tooling integration points, namely AbstractConfigurationPostProcessor and allowing for tooling-specified ClassLoader for use with ASM parsing\n+ Eliminated ModelMethod in favor of BeanMethod throughout\n\n\n",
      "commitDate": "2009/3/6 上午4:08",
      "commitName": "eaf3a7cec49e3a6e8ed828dbb69b9a9b007b0b39",
      "commitAuthor": "Chris Beams",
      "diff": "@@ -0,0 +1,8 @@\n+protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n+    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n+    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n+        return configBeanDefs;\n+    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n+    validateModel(configModel);\n+    return renderModelAsBeanDefinitions(configModel);\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected BeanDefinitionRegistry processConfigBeanDefinitions() {\n    BeanDefinitionRegistry configBeanDefs \u003d getConfigurationBeanDefinitions(false);\n    if (configBeanDefs.getBeanDefinitionCount() \u003d\u003d 0)\n        return configBeanDefs;\n    ConfigurationModel configModel \u003d createConfigurationModelFor(configBeanDefs);\n    validateModel(configModel);\n    return renderModelAsBeanDefinitions(configModel);\n}",
      "path": "org.springframework.config.java/src/main/java/org/springframework/config/java/support/AbstractConfigurationClassProcessor.java",
      "functionStartLine": 16,
      "functionName": "processConfigBeanDefinitions",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}