{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "AnnotationBinder.java",
  "functionName": "bindClass",
  "functionId": "bindClass___clazzToProcess-XClass__inheritanceStatePerClass-Map__XClass,InheritanceState____context-MetadataBuildingContext",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
  "functionAnnotation": "",
  "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is a configuration error\n",
  "functionStartLine": 524,
  "functionEndLine": 834,
  "numCommitsSeen": 224,
  "timeTaken": 8265,
  "changeHistory": [
    "ebca36a76851c9b0b7ea406e1b1428225891de2f",
    "8f889e95d76f47945c9ec072fd08cb045767578c",
    "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
    "59c3baae3271247bed516fe50952b65be1a27e5b",
    "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
    "aeb3aee62603f4e3613ed4037f2727c817a11016",
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
    "87e3f0fd28d7229b0a35032292ff32f542c22010",
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca",
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
    "09547a9051dd0ed851d8d6c5bd90841a93db2604",
    "1569e6194b45038a210984d73d25079dd1482b3f",
    "c47352058541e14e0b80d38f94c65d939d5394f5",
    "129c0f13482b99e2705f0e234b6bc0572a95c271",
    "a351c520205d18f18bc1c47091b4a62629f19de1",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "bf7607e24495af5133165ae6ed6b85feecf59148",
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
    "421789ddcd906e806bf901fea9d9e713daebd51a",
    "422ecc653a7d78ee0464478750a076710b697849",
    "153ad753e19b1f71665e6cfcbd903fb1ced889db",
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
    "252299cfee96892b71b3bd3e200181089e350e27",
    "5ee9ba361c96c29b06542720cb8b01e1034d8544",
    "d00f7efb308fab613b4918f9b8831f07602c6bd0",
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
    "2dd470af1f453e54643d55b2c81ec5a7324952b1",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
    "025b3cc14180d0459856bc45a6cac7acce3e1265",
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
    "c7c6981a558e35f01ff8d27938e98aa83896765c",
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
    "2176af11442c702aefa1900cdba4c32e6338b620",
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
    "88caf4d9586e988675254c268f4e145d272a9499",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e",
    "7337743c93574823424ed6c399cfcf6bd75614f8"
  ],
  "changeHistoryShort": {
    "ebca36a76851c9b0b7ea406e1b1428225891de2f": "Ybodychange",
    "8f889e95d76f47945c9ec072fd08cb045767578c": "Ybodychange",
    "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d": "Ydocchange",
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e": "Ybodychange",
    "59c3baae3271247bed516fe50952b65be1a27e5b": "Ybodychange",
    "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c": "Ydocchange",
    "aeb3aee62603f4e3613ed4037f2727c817a11016": "Ybodychange",
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021": "Ybodychange",
    "87e3f0fd28d7229b0a35032292ff32f542c22010": "Ydocchange",
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": "Ybodychange",
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc": "Ybodychange",
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a": "Ybodychange",
    "09547a9051dd0ed851d8d6c5bd90841a93db2604": "Ybodychange",
    "1569e6194b45038a210984d73d25079dd1482b3f": "Ybodychange",
    "c47352058541e14e0b80d38f94c65d939d5394f5": "Ybodychange",
    "129c0f13482b99e2705f0e234b6bc0572a95c271": "Ybodychange",
    "a351c520205d18f18bc1c47091b4a62629f19de1": "Ybodychange",
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "bf7607e24495af5133165ae6ed6b85feecf59148": "Ybodychange",
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185": "Ybodychange",
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": "Yparameterchange",
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": "Yfilerename",
    "421789ddcd906e806bf901fea9d9e713daebd51a": "Ybodychange",
    "422ecc653a7d78ee0464478750a076710b697849": "Ybodychange",
    "153ad753e19b1f71665e6cfcbd903fb1ced889db": "Ymultichange(Ybodychange,Ydocchange)",
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08": "Ybodychange",
    "252299cfee96892b71b3bd3e200181089e350e27": "Ybodychange",
    "5ee9ba361c96c29b06542720cb8b01e1034d8544": "Ybodychange",
    "d00f7efb308fab613b4918f9b8831f07602c6bd0": "Ybodychange",
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26": "Ybodychange",
    "2dd470af1f453e54643d55b2c81ec5a7324952b1": "Ybodychange",
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": "Ymultichange(Ybodychange,Ydocchange)",
    "025b3cc14180d0459856bc45a6cac7acce3e1265": "Ybodychange",
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489": "Ybodychange",
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed": "Ybodychange",
    "c7c6981a558e35f01ff8d27938e98aa83896765c": "Ybodychange",
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034": "Ybodychange",
    "2176af11442c702aefa1900cdba4c32e6338b620": "Ybodychange",
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4": "Ybodychange",
    "88caf4d9586e988675254c268f4e145d272a9499": "Ybodychange",
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": "Yfilerename",
    "7337743c93574823424ed6c399cfcf6bd75614f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ebca36a76851c9b0b7ea406e1b1428225891de2f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12654 - Throw MappingException if both @Inheritance and @AttributeOverride are used\n",
      "commitDate": "2018/6/20 下午10:03",
      "commitName": "ebca36a76851c9b0b7ea406e1b1428225891de2f",
      "commitAuthor": "Vlad Mihalcea",
      "commitDateOld": "2018/4/16 下午10:47",
      "commitNameOld": "6cefa865b0635a71eb85e20f6255491439ecb6da",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 64.97,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    if (superEntity !\u003d null \u0026\u0026 (clazzToProcess.getAnnotation(AttributeOverride.class) !\u003d null || clazzToProcess.getAnnotation(AttributeOverrides.class) !\u003d null)) {\n        throw new AnnotationException(\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" + clazzToProcess.getName());\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 524,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is a configuration error\n",
      "diff": "@@ -1,147 +1,150 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n+    if (superEntity !\u003d null \u0026\u0026 (clazzToProcess.getAnnotation(AttributeOverride.class) !\u003d null || clazzToProcess.getAnnotation(AttributeOverrides.class) !\u003d null)) {\n+        throw new AnnotationException(\"An entity annotated with @Inheritance cannot use @AttributeOverride or @AttributeOverrides: \" + clazzToProcess.getName());\n+    }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     applyCacheSettings(entityBinder, clazzToProcess, context);\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             } else {\n                 final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                 final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                 if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                 }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8f889e95d76f47945c9ec072fd08cb045767578c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12444 - Introduce BootstrapContext\nHHH-12443 - Introduce TypeConfiguration\n",
      "commitDate": "2018/3/29 上午6:43",
      "commitName": "8f889e95d76f47945c9ec072fd08cb045767578c",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2018/3/14 下午8:17",
      "commitNameOld": "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
      "commitAuthorOld": "Roland Illig",
      "daysBetweenCommits": 14.43,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 520,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is a configuration error\n",
      "diff": "@@ -1,147 +1,147 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n-    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n+    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003c\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     applyCacheSettings(entityBinder, clazzToProcess, context);\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n+            SimpleValue key \u003d new DependantValue(context, jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             } else {\n                 final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                 final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                 if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                 }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d": {
      "type": "Ydocchange",
      "commitMessage": "HHH-12388 - User Guide and Javadoc typo fixes\n\nFix a/an grammar in code and documentation, and other typos\n",
      "commitDate": "2018/3/14 下午8:17",
      "commitName": "8b11d5ecf9a71ae70e3f7c837ed3de1b55ec096d",
      "commitAuthor": "Roland Illig",
      "commitDateOld": "2017/12/14 上午1:42",
      "commitNameOld": "37df2bac74164934c1280d3f0f72432889581d8c",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 90.77,
      "commitsBetweenForRepo": 261,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 522,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is a configuration error\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
        "newValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is a configuration error\n"
      }
    },
    "b1a9c816a7e1159d6ae75898a8f455e425f94d4e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12157 - TableGenerator defined on one class is not visible on another\n\n(cherry picked from commit 8ae3dc4078597c69588ca8237591f1eab64c6bd7)\n",
      "commitDate": "2017/12/13 下午11:38",
      "commitName": "b1a9c816a7e1159d6ae75898a8f455e425f94d4e",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2017/12/13 下午8:19",
      "commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 522,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,147 +1,147 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     applyCacheSettings(entityBinder, clazzToProcess, context);\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             } else {\n                 final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                 final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                 if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                 }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n-    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n+    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n-    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n+    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003c\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59c3baae3271247bed516fe50952b65be1a27e5b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
      "commitDate": "2017/12/13 下午8:19",
      "commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017/12/13 下午8:19",
      "commitNameOld": "6818275376639c2a0d64674c4bd0320d64e86d89",
      "commitAuthorOld": "Andrea Boriero",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    applyCacheSettings(entityBinder, clazzToProcess, context);\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 523,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,148 +1,147 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n-    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n-    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n+    applyCacheSettings(entityBinder, clazzToProcess, context);\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             } else {\n                 final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                 final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                 if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                     key.setForeignKeyName(\"none\");\n                 } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                 }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c": {
      "type": "Ydocchange",
      "commitMessage": "HHH-11646 revert errant after -\u003e afterQuery search and replace\n",
      "commitDate": "2017/5/3 下午4:54",
      "commitName": "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
      "commitAuthor": "Richard Bradley",
      "commitDateOld": "2017/3/14 上午5:59",
      "commitNameOld": "12a1b3c225b61a99b141bd89a9f56235ac09ce62",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 50.45,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound afterQuery its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
        "newValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n"
      }
    },
    "aeb3aee62603f4e3613ed4037f2727c817a11016": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11180 - JPA @ForeignKey still not consistently applied from annotation binding\n\n- Fix ForeignKey support for PrimaryKeyJoinColumn / PrimaryKeyJoinColumns\n- Fix ForeignKey support for JoinColumn / JoinColumns\n- Fix ForeignKey support for JoinTable when applying value NO_CONSTRAINT.\n- Fix ForeignKey support for MapKeyJoinColumn / MapKeyJoinColumns\n- Fix ForeignKey support for AssociationOverride / AssociationOverrides\n",
      "commitDate": "2017/2/15 下午8:08",
      "commitName": "aeb3aee62603f4e3613ed4037f2727c817a11016",
      "commitAuthor": "Christian Beikov",
      "commitDateOld": "2016/12/6 下午8:50",
      "commitNameOld": "b1c7615904e7dd3c03bbe77af8bda2fbce6a3624",
      "commitAuthorOld": "Vlad Mihalcea",
      "daysBetweenCommits": 70.97,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n                    key.setForeignKeyName(\"none\");\n                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound afterQuery its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,141 +1,148 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             } else {\n                 final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n-                if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n+                final PrimaryKeyJoinColumns pkJoinColumns \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumns.class);\n+                if (pkJoinColumns !\u003d null \u0026\u0026 pkJoinColumns.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n+                    key.setForeignKeyName(\"none\");\n+                } else if (pkJoinColumns !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumns.foreignKey().name())) {\n+                    key.setForeignKeyName(pkJoinColumns.foreignKey().name());\n+                } else if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey().value() \u003d\u003d ConstraintMode.NO_CONSTRAINT) {\n+                    key.setForeignKeyName(\"none\");\n+                } else if (pkJoinColumn !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                     key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                 }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10352 - Fix HBM2DDL does not use described name for foreign key in join inheritance\n",
      "commitDate": "2016/6/14 上午7:58",
      "commitName": "2ea122aedd0c32e5ab1c68e90dd8dd4ed33d2021",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2016/6/7 下午4:36",
      "commitNameOld": "78de650efec58367a4196eb41c1d5f99b291f036",
      "commitAuthorOld": "Matthias Kurz",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            } else {\n                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n                if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n                }\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound afterQuery its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,136 +1,141 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n+            } else {\n+                final PrimaryKeyJoinColumn pkJoinColumn \u003d clazzToProcess.getAnnotation(PrimaryKeyJoinColumn.class);\n+                if (pkJoinColumn !\u003d null \u0026\u0026 pkJoinColumn.foreignKey() !\u003d null \u0026\u0026 !StringHelper.isEmpty(pkJoinColumn.foreignKey().name())) {\n+                    key.setForeignKeyName(pkJoinColumn.foreignKey().name());\n+                }\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87e3f0fd28d7229b0a35032292ff32f542c22010": {
      "type": "Ydocchange",
      "commitMessage": "HHH-10664 - Prep 6.0 feature branch - merge hibernate-entitymanager into hibernate-core (first sucessful full compile of consolidated hibernate-core)\n",
      "commitDate": "2016/5/7 上午2:12",
      "commitName": "87e3f0fd28d7229b0a35032292ff32f542c22010",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016/3/30 下午10:55",
      "commitNameOld": "de6d80a67bedb3545f9c16b41cb4e81ff3821e4f",
      "commitAuthorOld": "Dominique Toupin",
      "daysBetweenCommits": 37.14,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 484,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound afterQuery its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
        "newValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound afterQuery its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n"
      }
    },
    "9e063ffa2577f06d98a9e912bb16d20424df8d6d": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9837 - Remove reliance during annotation binding on org.hibernate.internal.util.ClassLoaderHelper\nHHH-9841 - Redesign org.hibernate.property.PropertyAccessorFactory\n",
      "commitDate": "2015/6/5 上午3:12",
      "commitName": "9e063ffa2577f06d98a9e912bb16d20424df8d6d",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2015/5/19 下午12:25",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 16.62,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 482,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,136 +1,136 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, context);\n         bindTypeDefs(clazzToProcess, context);\n         bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n-    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n+    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity, context);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, context);\n     bindFilterDefs(clazzToProcess, context);\n     bindTypeDefs(clazzToProcess, context);\n     bindFetchProfiles(clazzToProcess, context);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             LOG.invalidTableAnnotation(clazzToProcess.getName());\n         }\n         if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n             entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n             SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n             context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n             context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                     bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     context.getMetadataCollector().addEntityBinding(persistentClass);\n     context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9caca0ce37d5a2763d476c6fa2471addcca710ca": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
      "commitDate": "2015/3/11 上午5:53",
      "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
      "commitAuthor": "Steve Ebersole",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015/3/11 上午5:53",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2014/9/30 下午10:40",
          "commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
          "commitAuthorOld": "Maxim Frolov",
          "daysBetweenCommits": 161.3,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 587,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,131 +1,136 @@\n-public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n+public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n-    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n+    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n-        bindQueries(clazzToProcess, mappings);\n-        bindTypeDefs(clazzToProcess, mappings);\n-        bindFilterDefs(clazzToProcess, mappings);\n+        bindQueries(clazzToProcess, context);\n+        bindTypeDefs(clazzToProcess, context);\n+        bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n-    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n-    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n+    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n-    bindQueries(clazzToProcess, mappings);\n-    bindFilterDefs(clazzToProcess, mappings);\n-    bindTypeDefs(clazzToProcess, mappings);\n-    bindFetchProfiles(clazzToProcess, mappings);\n-    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n+    bindQueries(clazzToProcess, context);\n+    bindFilterDefs(clazzToProcess, context);\n+    bindTypeDefs(clazzToProcess, context);\n+    bindFetchProfiles(clazzToProcess, context);\n+    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n-    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n+    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n-    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n+    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n-    bindFilters(clazzToProcess, entityBinder, mappings);\n+    bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n-        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n-    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n-        LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n+        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n+    } else {\n+        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n+            LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        }\n+        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n+            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n+        }\n     }\n-    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n+    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-            SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n+            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n-            SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n-            mappings.addSecondPass(sp);\n-            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n+            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n+            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n-    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n+    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n-    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n+    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n-    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n+    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n-        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n+        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n-    mappings.addClass(persistentClass);\n-    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n+    context.getMetadataCollector().addEntityBinding(persistentClass);\n+    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-Mappings]",
            "newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, context-MetadataBuildingContext]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015/3/11 上午5:53",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2014/9/30 下午10:40",
          "commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
          "commitAuthorOld": "Maxim Frolov",
          "daysBetweenCommits": 161.3,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 587,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,131 +1,136 @@\n-public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n+public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n-    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n+    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n-        bindQueries(clazzToProcess, mappings);\n-        bindTypeDefs(clazzToProcess, mappings);\n-        bindFilterDefs(clazzToProcess, mappings);\n+        bindQueries(clazzToProcess, context);\n+        bindTypeDefs(clazzToProcess, context);\n+        bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n-    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n-    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n+    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n-    bindQueries(clazzToProcess, mappings);\n-    bindFilterDefs(clazzToProcess, mappings);\n-    bindTypeDefs(clazzToProcess, mappings);\n-    bindFetchProfiles(clazzToProcess, mappings);\n-    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n+    bindQueries(clazzToProcess, context);\n+    bindFilterDefs(clazzToProcess, context);\n+    bindTypeDefs(clazzToProcess, context);\n+    bindFetchProfiles(clazzToProcess, context);\n+    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n-    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n+    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n-    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n+    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n-    bindFilters(clazzToProcess, entityBinder, mappings);\n+    bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n-        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n-    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n-        LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n+        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n+    } else {\n+        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n+            LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        }\n+        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n+            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n+        }\n     }\n-    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n+    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-            SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n+            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n-            SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n-            mappings.addSecondPass(sp);\n-            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n+            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n+            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n-    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n+    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n-    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n+    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n-    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n+    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n-        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n+        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n-    mappings.addClass(persistentClass);\n-    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n+    context.getMetadataCollector().addEntityBinding(persistentClass);\n+    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "HHH-9490 - Migrate from dom4j to jaxb for XML processing;\nHHH-9492 - Migrate to new bootstrap API (MetadataSources, etc);\nHHH-7078 - Split NamingStrategy into ImplicitNamingStrategy/PhysicalNamingStrategy;\nHHH-6005 - Better handling of implicit column naming with @ElementCollection of @Embeddables;\nHHH-9633 - Add tests that explicitly test the \"main\" NamingStrategy impls\n",
          "commitDate": "2015/3/11 上午5:53",
          "commitName": "9caca0ce37d5a2763d476c6fa2471addcca710ca",
          "commitAuthor": "Steve Ebersole",
          "commitDateOld": "2014/9/30 下午10:40",
          "commitNameOld": "83f29d1e1a3d0655d4f402636bc191ff05ad74ea",
          "commitAuthorOld": "Maxim Frolov",
          "daysBetweenCommits": 161.3,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, context);\n        bindTypeDefs(clazzToProcess, context);\n        bindFilterDefs(clazzToProcess, context);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, context);\n    bindFilterDefs(clazzToProcess, context);\n    bindTypeDefs(clazzToProcess, context);\n    bindFetchProfiles(clazzToProcess, context);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, context);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            LOG.invalidTableAnnotation(clazzToProcess.getName());\n        }\n        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    context.getMetadataCollector().addEntityBinding(persistentClass);\n    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
          "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 587,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,131 +1,136 @@\n-public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n+public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, MetadataBuildingContext context) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n-    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n+    AnnotatedClassType classType \u003d context.getMetadataCollector().getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n-        bindQueries(clazzToProcess, mappings);\n-        bindTypeDefs(clazzToProcess, mappings);\n-        bindFilterDefs(clazzToProcess, mappings);\n+        bindQueries(clazzToProcess, context);\n+        bindTypeDefs(clazzToProcess, context);\n+        bindFilterDefs(clazzToProcess, context);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n-    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, context, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n-    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n+    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, context);\n     entityBinder.setInheritanceState(inheritanceState);\n-    bindQueries(clazzToProcess, mappings);\n-    bindFilterDefs(clazzToProcess, mappings);\n-    bindTypeDefs(clazzToProcess, mappings);\n-    bindFetchProfiles(clazzToProcess, mappings);\n-    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n+    bindQueries(clazzToProcess, context);\n+    bindFilterDefs(clazzToProcess, context);\n+    bindTypeDefs(clazzToProcess, context);\n+    bindFetchProfiles(clazzToProcess, context);\n+    BinderHelper.bindAnyMetaDefs(clazzToProcess, context);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n-    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n+    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, context, inheritanceState, superEntity);\n     final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, context, inheritanceState, entityBinder);\n     } else {\n         discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n-    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n+    entityBinder.setCache(determineCacheSettings(clazzToProcess, context));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n-    bindFilters(clazzToProcess, entityBinder, mappings);\n+    bindFilters(clazzToProcess, entityBinder, context);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n-        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n-    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n-        LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        EntityTableXref denormalizedTableXref \u003d inheritanceState.hasDenormalizedTable() ? context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()) : null;\n+        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, denormalizedTableXref);\n+    } else {\n+        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n+            LOG.invalidTableAnnotation(clazzToProcess.getName());\n+        }\n+        if (inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE) {\n+            entityBinder.bindTableForDiscriminatedSubclass(context.getMetadataCollector().getEntityTableXref(superEntity.getEntityName()));\n+        }\n     }\n-    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n+    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, context, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n     final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n     if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             onDeleteAppropriate \u003d true;\n             final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-            SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n+            SimpleValue key \u003d new DependantValue(context.getMetadataCollector(), jsc.getTable(), jsc.getIdentifier());\n             jsc.setKey(key);\n             ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n             if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                 key.setForeignKeyName(fk.name());\n             }\n             if (onDeleteAnn !\u003d null) {\n                 key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n             } else {\n                 key.setCascadeDeleteEnabled(false);\n             }\n-            SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n-            mappings.addSecondPass(sp);\n-            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n+            context.getMetadataCollector().addSecondPass(new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, context));\n+            context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(jsc));\n         }\n         if (isInheritanceRoot) {\n             if (discriminatorColumn !\u003d null) {\n                 if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                     entityBinder.bindDiscriminatorValue();\n                 }\n             }\n         }\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (isInheritanceRoot) {\n             if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n-                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, context);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     }\n-    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n+    HashMap\u003cString, IdentifierGeneratorDefinition\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, context);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n-    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n+    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, context);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n-    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n+    processIdPropertiesIfNotAlready(inheritanceStatePerClass, context, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n-        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n+        context.getMetadataCollector().addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n-    mappings.addClass(persistentClass);\n-    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n+    context.getMetadataCollector().addEntityBinding(persistentClass);\n+    context.getMetadataCollector().addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
            "newValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@throws MappingException in case there is an configuration error\n"
          }
        }
      ]
    },
    "5329bba1ea724eabf5783c71e5127b8f84ad0fcc": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6911 - Write DiscriminatorValue to DiscriminatorColumn when combined with InheritanceType#JOINED\n",
      "commitDate": "2013/12/13 下午2:57",
      "commitName": "5329bba1ea724eabf5783c71e5127b8f84ad0fcc",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/12/11 上午9:33",
      "commitNameOld": "637c8b4b08fab8c07406371a19c2674f67eb705d",
      "commitAuthorOld": "Brett Meyer",
      "daysBetweenCommits": 2.23,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    final Ejb3DiscriminatorColumn discriminatorColumn;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    } else {\n        discriminatorColumn \u003d null;\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            onDeleteAppropriate \u003d true;\n            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n            SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n            jsc.setKey(key);\n            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n                key.setForeignKeyName(fk.name());\n            }\n            if (onDeleteAnn !\u003d null) {\n                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n            } else {\n                key.setCascadeDeleteEnabled(false);\n            }\n            SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n            mappings.addSecondPass(sp);\n            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n        }\n        if (isInheritanceRoot) {\n            if (discriminatorColumn !\u003d null) {\n                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                    entityBinder.bindDiscriminatorValue();\n                }\n            }\n        }\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (isInheritanceRoot) {\n            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 574,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,115 +1,131 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n-    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n+    final Ejb3DiscriminatorColumn discriminatorColumn;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+        discriminatorColumn \u003d processSingleTableDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+    } else if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n+        discriminatorColumn \u003d processJoinedDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n+    } else {\n+        discriminatorColumn \u003d null;\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     bindFilters(clazzToProcess, entityBinder, mappings);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n-    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n-        onDeleteAppropriate \u003d true;\n-        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n-        jsc.setKey(key);\n-        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n-        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n-            key.setForeignKeyName(fk.name());\n+    final boolean isInheritanceRoot \u003d !inheritanceState.hasParents();\n+    final boolean hasSubclasses \u003d inheritanceState.hasSiblings();\n+    if (InheritanceType.JOINED.equals(inheritanceState.getType())) {\n+        if (inheritanceState.hasParents()) {\n+            onDeleteAppropriate \u003d true;\n+            final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n+            SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n+            jsc.setKey(key);\n+            ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n+            if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n+                key.setForeignKeyName(fk.name());\n+            }\n+            if (onDeleteAnn !\u003d null) {\n+                key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n+            } else {\n+                key.setCascadeDeleteEnabled(false);\n+            }\n+            SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n+            mappings.addSecondPass(sp);\n+            mappings.addSecondPass(new CreateKeySecondPass(jsc));\n         }\n-        if (onDeleteAnn !\u003d null) {\n-            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n-        } else {\n-            key.setCascadeDeleteEnabled(false);\n+        if (isInheritanceRoot) {\n+            if (discriminatorColumn !\u003d null) {\n+                if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n+                    bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+                    entityBinder.bindDiscriminatorValue();\n+                }\n+            }\n         }\n-        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n-        mappings.addSecondPass(sp);\n-        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        if (!inheritanceState.hasParents()) {\n-            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n-                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n+        if (isInheritanceRoot) {\n+            if (hasSubclasses || !discriminatorColumn.isImplicit()) {\n+                bindDiscriminatorColumnToRootPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n-    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n-    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n+    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n+    }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n     entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d9b7a06a52b56b84844513d97c535eb00d0ed8a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7969 initial @Table#indexes support\n",
      "commitDate": "2013/2/6 上午12:09",
      "commitName": "1d9b7a06a52b56b84844513d97c535eb00d0ed8a",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2012/12/25 下午7:25",
      "commitNameOld": "6c6df695350f917fe707b4f830e29c8c52c3f5d0",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 42.2,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    javax.persistence.Table tabAnn \u003d null;\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n    entityBinder.processComplementaryTableDefinitions(tabAnn);\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 505,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,113 +1,115 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n+    javax.persistence.Table tabAnn \u003d null;\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n-        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n+        tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     bindFilters(clazzToProcess, entityBinder, mappings);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n+    entityBinder.processComplementaryTableDefinitions(tabAnn);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09547a9051dd0ed851d8d6c5bd90841a93db2604": {
      "type": "Ybodychange",
      "commitMessage": "HHH-2394 Remove conditions that blocked filters on sub-classes (for annotations)\n",
      "commitDate": "2012/7/12 下午10:58",
      "commitName": "09547a9051dd0ed851d8d6c5bd90841a93db2604",
      "commitAuthor": "Rob Worsnop",
      "commitDateOld": "2012/6/2 上午12:59",
      "commitNameOld": "e26b8be6a5a935ae00e537c01c59a6fcb24fc67d",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 40.92,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    bindFilters(clazzToProcess, entityBinder, mappings);\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 503,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,115 +1,113 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n-    if (!inheritanceState.hasParents()) {\n-        bindFilters(clazzToProcess, entityBinder, mappings);\n-    }\n+    bindFilters(clazzToProcess, entityBinder, mappings);\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1569e6194b45038a210984d73d25079dd1482b3f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6974 Complete second level caching of natural id resolution\n",
      "commitDate": "2012/2/7 下午10:34",
      "commitName": "1569e6194b45038a210984d73d25079dd1482b3f",
      "commitAuthor": "Eric Dalquist",
      "commitDateOld": "2012/2/7 下午10:34",
      "commitNameOld": "c47352058541e14e0b80d38f94c65d939d5394f5",
      "commitAuthorOld": "Eric Dalquist",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,115 +1,115 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n-    entityBinder.setNaturalIdCache(clazzToProcess.getAnnotation(NaturalIdCache.class));\n+    entityBinder.setNaturalIdCache(clazzToProcess, clazzToProcess.getAnnotation(NaturalIdCache.class));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c47352058541e14e0b80d38f94c65d939d5394f5": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6974 Class level naturalId cache and stats\n\nAdd class level @NaturalIdCache annotation to denote if second level natualId caching should be done\nFlush out stats model for naturalId cache related stats\nAdd ehcache support classes for naturalId region\n",
      "commitDate": "2012/2/7 下午10:34",
      "commitName": "c47352058541e14e0b80d38f94c65d939d5394f5",
      "commitAuthor": "Eric Dalquist",
      "commitDateOld": "2011/11/23 下午6:51",
      "commitNameOld": "6c7379c38f8b6b43c13791b29cd09b1f4a26bd8e",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 76.15,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    entityBinder.setNaturalIdCache(clazzToProcess.getAnnotation(NaturalIdCache.class));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,114 +1,115 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     if (LOG.isDebugEnabled()) {\n         LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n+    entityBinder.setNaturalIdCache(clazzToProcess.getAnnotation(NaturalIdCache.class));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "129c0f13482b99e2705f0e234b6bc0572a95c271": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
      "commitDate": "2011/10/27 上午6:24",
      "commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2011/10/24 下午4:26",
      "commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    if (LOG.isDebugEnabled()) {\n        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    }\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 501,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,111 +1,114 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n-    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n+    if (LOG.isDebugEnabled()) {\n+        LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n+    }\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n-    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n+    } else if (clazzToProcess.isAnnotationPresent(Table.class)) {\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n+    }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a351c520205d18f18bc1c47091b4a62629f19de1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6724 Move persister binding for class hierarchies to PersisterClassResolver out of {Hbm|Annotation}Binder",
      "commitDate": "2011/10/12 上午8:13",
      "commitName": "a351c520205d18f18bc1c47091b4a62629f19de1",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2011/6/28 下午4:29",
      "commitNameOld": "ffb14b28b72c67dc2d658bfeb89545ca16eb3399",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 105.66,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (!inheritanceState.hasParents()) {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 492,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,123 +1,111 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class))\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n-        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n-            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n-        }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        if (inheritanceState.hasParents()) {\n-            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n-                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n-            }\n-        } else {\n+        if (!inheritanceState.hasParents()) {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n-        if (inheritanceState.hasParents()) {\n-            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n-                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n-            }\n-        }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad17f89c4c29f0327c843cf5265e156d65743ab1": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6097 - Review log levels, especially related to i18n messages\n",
      "commitDate": "2011/4/12 下午10:07",
      "commitName": "ad17f89c4c29f0327c843cf5265e156d65743ab1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/4/12 上午10:59",
      "commitNameOld": "62da5aa5bc2600252399060a0c48d32505b879ac",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 494,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,123 +1,123 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n-    LOG.bindingEntityFromClass(clazzToProcess.getName());\n+    LOG.debugf(\"Binding entity from annotated class: %s\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else if (clazzToProcess.isAnnotationPresent(Table.class))\n         LOG.invalidTableAnnotation(clazzToProcess.getName());\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n         LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011/1/19 上午5:35",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010/10/12 上午3:41",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    LOG.bindingEntityFromClass(clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n        LOG.invalidTableAnnotation(clazzToProcess.getName());\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,127 +1,123 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n-    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n+    LOG.bindingEntityFromClass(clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n     entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n     entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n     entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n     entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n-    } else {\n-        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n-            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n-        }\n-    }\n+    } else if (clazzToProcess.isAnnotationPresent(Table.class))\n+        LOG.invalidTableAnnotation(clazzToProcess.getName());\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n-    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n-        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n-    }\n+    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate)\n+        LOG.invalidOnDeleteAnnotation(propertyHolder.getEntityName());\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010/10/12 上午3:41",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/10/12 上午2:51",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 506,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "bf7607e24495af5133165ae6ed6b85feecf59148": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5190 - Introduced new annotation @DiscriminatorOptions and deprecated @ForceDiscriminator\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20749 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/9/29 下午6:45",
      "commitName": "bf7607e24495af5133165ae6ed6b85feecf59148",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010/9/29 上午12:28",
      "commitNameOld": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setInheritanceState(inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n    }\n    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 506,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,142 +1,127 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n+    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n+    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n+    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n+    entityBinder.setInheritanceState(inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n-    String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n-        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n-        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n-        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n-        if (!inheritanceState.hasParents()) {\n-            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n-        }\n-        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n-            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n-        }\n-        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n+        discriminatorColumn \u003d processDiscriminatorProperties(clazzToProcess, mappings, inheritanceState, entityBinder);\n     }\n-    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n-    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n-    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n-    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n-    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n-    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n-    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n-    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n-    entityBinder.setDiscriminatorValue(discrimValue);\n-    entityBinder.setBatchSize(sizeAnn);\n-    entityBinder.setProxy(proxyAnn);\n-    entityBinder.setWhere(whereAnn);\n-    entityBinder.setCache(cacheAnn);\n-    entityBinder.setInheritanceState(inheritanceState);\n+    entityBinder.setProxy(clazzToProcess.getAnnotation(Proxy.class));\n+    entityBinder.setBatchSize(clazzToProcess.getAnnotation(BatchSize.class));\n+    entityBinder.setWhere(clazzToProcess.getAnnotation(Where.class));\n+    entityBinder.setCache(determineCacheSettings(clazzToProcess, mappings));\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5205 - Added @Source and emum SourceType, fixed implementation and added a test\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20740 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/9/29 上午12:28",
      "commitName": "e14f58de29eb5f8a3de7480dbd8bc10fcc9e6185",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010/8/27 上午5:00",
      "commitNameOld": "232a77e5ddfa3eaf59034a7e55fd52debeb0242a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 32.81,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,142 +1,142 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n-        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n+        if (fk !\u003d null \u0026\u0026 !BinderHelper.isEmptyAnnotationValue(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f": {
      "type": "Yparameterchange",
      "commitMessage": "HHH-5474 - Clean up usages of now deprecated ExtendedMappings\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@20136 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/8/13 上午3:13",
      "commitName": "f0f82e4f1ba7416ef010d5d71914a2bbde7fc22f",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/7/9 上午7:56",
      "commitNameOld": "df184979ed2f19887bbea46603148dd59d3bfd1f",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 34.8,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 502,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,142 +1,142 @@\n-public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n+public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, Mappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-ExtendedMappings]",
        "newValue": "[clazzToProcess-XClass, inheritanceStatePerClass-Map\u003cXClass,InheritanceState\u003e, mappings-Mappings]"
      }
    },
    "1ca2bc19a5f667e10f9a2c2b10320b9c40921563": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5367 - Move annotations module sources into core module\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19921 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/7/9 上午7:41",
      "commitName": "1ca2bc19a5f667e10f9a2c2b10320b9c40921563",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/7/9 上午1:32",
      "commitNameOld": "cc3b41a09c983913594b16d6c909be0bfd41bd7a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 503,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "core/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "421789ddcd906e806bf901fea9d9e713daebd51a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5138 - Redesign types + introduce TypeRegistry \u0026 TypeResolver\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19335 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/5/2 上午2:20",
      "commitName": "421789ddcd906e806bf901fea9d9e713daebd51a",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/4/27 下午4:38",
      "commitNameOld": "b912a95d5422d6ce91c8b89aecb6b3923626e9c7",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 4.4,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,142 +1,142 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n         throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n     }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n-        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n+        SimpleValue key \u003d new DependantValue(mappings, jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n-                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n+                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder, mappings);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "422ecc653a7d78ee0464478750a076710b697849": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5125 Raise proper exception when @Entity and @MappedSuperclass are present on the same class\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19241 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/4/16 下午6:11",
      "commitName": "422ecc653a7d78ee0464478750a076710b697849",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/3/5 上午5:55",
      "commitNameOld": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 42.51,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n    }\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 504,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,139 +1,142 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n+    if (clazzToProcess.isAnnotationPresent(Entity.class) \u0026\u0026 clazzToProcess.isAnnotationPresent(MappedSuperclass.class)) {\n+        throw new AnnotationException(\"An entity cannot be annotated with both @Entity and @MappedSuperclass: \" + clazzToProcess.getName());\n+    }\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "153ad753e19b1f71665e6cfcbd903fb1ced889db": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "HHH-4812\nAdded @FetchProfile and @FetchProfiles annotations and wired them up. Added also some error handling in the AnnotationBinder.\nRefactor the handling of precedence in the AnnotationConfiguration, because I thought I would be reusing it for the fetch profile as well, but in the end decided to jsut implement in a way that xml configured fetch profiles always win over annotation confgured ones.\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18924 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/3/5 上午5:55",
      "commitName": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
      "commitAuthor": "Hardy Ferentschik",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HHH-4812\nAdded @FetchProfile and @FetchProfiles annotations and wired them up. Added also some error handling in the AnnotationBinder.\nRefactor the handling of precedence in the AnnotationConfiguration, because I thought I would be reusing it for the fetch profile as well, but in the end decided to jsut implement in a way that xml configured fetch profiles always win over annotation confgured ones.\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18924 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/3/5 上午5:55",
          "commitName": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
          "commitAuthor": "Hardy Ferentschik",
          "commitDateOld": "2010/2/18 下午5:59",
          "commitNameOld": "b5529c05a56106ddf3d582355a4b07ac3d6510d0",
          "commitAuthorOld": "Emmanuel Bernard",
          "daysBetweenCommits": 14.5,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
          "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 504,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,138 +1,139 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n+    bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "HHH-4812\nAdded @FetchProfile and @FetchProfiles annotations and wired them up. Added also some error handling in the AnnotationBinder.\nRefactor the handling of precedence in the AnnotationConfiguration, because I thought I would be reusing it for the fetch profile as well, but in the end decided to jsut implement in a way that xml configured fetch profiles always win over annotation confgured ones.\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18924 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2010/3/5 上午5:55",
          "commitName": "153ad753e19b1f71665e6cfcbd903fb1ced889db",
          "commitAuthor": "Hardy Ferentschik",
          "commitDateOld": "2010/2/18 下午5:59",
          "commitNameOld": "b5529c05a56106ddf3d582355a4b07ac3d6510d0",
          "commitAuthorOld": "Emmanuel Bernard",
          "daysBetweenCommits": 14.5,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    bindFetchProfiles(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
          "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 504,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,138 +1,139 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n+    bindFetchProfiles(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n     boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n     if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
            "newValue": "Bind a class having JSR175 annotations. Subclasses \u003cb\u003ehave to\u003c/b\u003e be bound after its parent class.\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n"
          }
        }
      ]
    },
    "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4848 finish support for derived identity Yeah! More specifically @IdClass on dependent where the @IdClass points to the associated entity id type\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18708 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/2/6 上午7:33",
      "commitName": "8478d5b44b6c8d72b386d7a1a2841bfe7b37fb08",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/2/6 上午2:28",
      "commitNameOld": "5c16c01064f4e2970860c5da47d0f0425aefac02",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n    if (!isIdClass) {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 487,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,191 +1,138 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n-    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n-    XClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n-    if (classWithIdClass !\u003d null) {\n-        IdClass idClass \u003d classWithIdClass.getAnnotation(IdClass.class);\n-        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n-        boolean isComponent \u003d true;\n-        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n-        String generatorType \u003d \"assigned\";\n-        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n-        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n-        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n-        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n-        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n-        entityBinder.setIgnoreIdAnnotations(true);\n-        propertyHolder.setInIdClass(true);\n-        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n-        propertyHolder.setInIdClass(null);\n-        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n-        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n-        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n-        persistentClass.setIdentifierMapper(mapper);\n-        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n-        if (superclass !\u003d null) {\n-            superclass.setDeclaredIdentifierMapper(mapper);\n-        } else {\n-            persistentClass.setDeclaredIdentifierMapper(mapper);\n-        }\n-        Property property \u003d new Property();\n-        property.setName(\"_identifierMapper\");\n-        property.setNodeName(\"id\");\n-        property.setUpdateable(false);\n-        property.setInsertable(false);\n-        property.setValue(mapper);\n-        property.setPropertyAccessorName(\"embedded\");\n-        persistentClass.addProperty(property);\n-        entityBinder.setIgnoreIdAnnotations(true);\n-        Iterator properties \u003d mapper.getPropertyIterator();\n-        while (properties.hasNext()) {\n-            idProperties.add(((Property) properties.next()).getName());\n-        }\n-    } else {\n+    Set\u003cString\u003e idPropertiesIfIdClass \u003d new HashSet\u003cString\u003e();\n+    boolean isIdClass \u003d mapAsIdClass(inheritanceStatePerClass, inheritanceState, persistentClass, entityBinder, propertyHolder, elementsToProcess, idPropertiesIfIdClass, mappings);\n+    if (!isIdClass) {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n-    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n-    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n-        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n-        if (!idProperties.contains(propertyName)) {\n-            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n-        } else {\n-            missingIdProperties.remove(propertyName);\n-        }\n-    }\n-    if (missingIdProperties.size() !\u003d 0) {\n-        StringBuilder missings \u003d new StringBuilder();\n-        for (String property : missingIdProperties) {\n-            missings.append(property).append(\", \");\n-        }\n-        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n-    }\n+    processIdPropertiesIfNotAlready(inheritanceStatePerClass, mappings, persistentClass, entityBinder, propertyHolder, classGenerators, elementsToProcess, subclassAndSingleTableStrategy, idPropertiesIfIdClass);\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "252299cfee96892b71b3bd3e200181089e350e27": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4848 partial implementation of @IdClass support in derivedidentity (example 1 case a of the spec)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18692 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/2/5 上午1:54",
      "commitName": "252299cfee96892b71b3bd3e200181089e350e27",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/28 上午2:58",
      "commitNameOld": "016a02ff506b715e8217b8577594ac62b3f318ce",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    XClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n    if (classWithIdClass !\u003d null) {\n        IdClass idClass \u003d classWithIdClass.getAnnotation(IdClass.class);\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        propertyHolder.setInIdClass(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        propertyHolder.setInIdClass(null);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 486,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,189 +1,191 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n     inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     XClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n     if (classWithIdClass !\u003d null) {\n         IdClass idClass \u003d classWithIdClass.getAnnotation(IdClass.class);\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n+        propertyHolder.setInIdClass(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n+        propertyHolder.setInIdClass(null);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     } else {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5ee9ba361c96c29b06542720cb8b01e1034d8544": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 Add support for parent\u0027s id being an IdClass or an EmbeddedId (last case not tested yet). (example e2.b)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18625 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/26 下午8:57",
      "commitName": "5ee9ba361c96c29b06542720cb8b01e1034d8544",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/26 上午1:19",
      "commitNameOld": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n    inheritanceState.postProcess(persistentClass, entityBinder);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    XClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n    if (classWithIdClass !\u003d null) {\n        IdClass idClass \u003d classWithIdClass.getAnnotation(IdClass.class);\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 433,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,199 +1,189 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n-    final ElementsToProcess elementsToProcess \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n+    final InheritanceState.ElementsToProcess elementsToProcess \u003d inheritanceState.getElementsToProcess();\n+    inheritanceState.postProcess(persistentClass, entityBinder);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n-    IdClass idClass \u003d null;\n-    XClass current \u003d null;\n-    if (!inheritanceState.hasParents()) {\n-        InheritanceState state \u003d inheritanceState;\n-        do {\n-            current \u003d state.getClazz();\n-            if (current.isAnnotationPresent(IdClass.class)) {\n-                idClass \u003d current.getAnnotation(IdClass.class);\n-                break;\n-            }\n-            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n-        } while (state !\u003d null);\n-    }\n-    if (idClass !\u003d null) {\n+    XClass classWithIdClass \u003d inheritanceState.getClassWithIdClass(false);\n+    if (classWithIdClass !\u003d null) {\n+        IdClass idClass \u003d classWithIdClass.getAnnotation(IdClass.class);\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n-        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n+        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", classWithIdClass);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     } else {\n         entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d00f7efb308fab613b4918f9b8831f07602c6bd0": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4529 support for derived entity id as a XToOne pointing to the master entity\nHHH-4840 support for Core style embedded id (after all these years :) )\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18619 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/26 上午1:19",
      "commitName": "d00f7efb308fab613b4918f9b8831f07602c6bd0",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2010/1/25 上午1:07",
      "commitNameOld": "5d8d70036a139f954e7b572a649ab52d4b930692",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    final ElementsToProcess elementsToProcess \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    } else {\n        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 434,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,197 +1,199 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n-    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n+    final ElementsToProcess elementsToProcess \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n+    } else {\n+        entityBinder.setWrapIdsInEmbeddedComponents(elementsToProcess.getIdPropertyCount() \u003e 1);\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n-    for (PropertyData propertyAnnotatedElement : elements) {\n+    for (PropertyData propertyAnnotatedElement : elementsToProcess.getElements()) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d24ed1a1d39c1458d020a27a504a46e76dfe2e26": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4659 - Add support for standard declarative cache (@Cacheable)\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18605 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/22 下午3:22",
      "commitName": "d24ed1a1d39c1458d020a27a504a46e76dfe2e26",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/1/22 上午1:51",
      "commitNameOld": "8577a68e69d30d9e671024bf3330616000a3ec54",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 434,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,197 +1,197 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n-    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n+    Cache cacheAnn \u003d determineCacheSettings(clazzToProcess, mappings);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dd470af1f453e54643d55b2c81ec5a7324952b1": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527 - added handling of proper default access propagation for class hierarchies and embedded classes (components)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18417 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/6 上午5:51",
      "commitName": "2dd470af1f453e54643d55b2c81ec5a7324952b1",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2010/1/5 上午2:50",
      "commitNameOld": "43dd13073d76e3ad1388f280aeff6f078f8db79f",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 428,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
      "diff": "@@ -1,200 +1,197 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n-    if (elements \u003d\u003d null) {\n-        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n-    }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n-            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n+            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n-        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n-        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n+        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", compositeClass);\n+        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessType(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4a9d8dcf0b054d4dc769b463145c1fdecede6e09": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/12/18 上午5:14",
      "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
      "commitAuthor": "Hardy Ferentschik",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2009/12/18 上午5:14",
          "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
          "commitAuthor": "Hardy Ferentschik",
          "commitDateOld": "2009/12/12 上午3:14",
          "commitNameOld": "025b3cc14180d0459856bc45a6cac7acce3e1265",
          "commitAuthorOld": "Hardy Ferentschik",
          "daysBetweenCommits": 6.08,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
          "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 431,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,201 +1,200 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n-    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n+    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n-        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n-        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n+        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n-        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n+        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n-        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n+        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": " HHH-4527 - first cut for supporting JPA2 @Access annotation. Not quite complete and needs some more tests.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18260 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
          "commitDate": "2009/12/18 上午5:14",
          "commitName": "4a9d8dcf0b054d4dc769b463145c1fdecede6e09",
          "commitAuthor": "Hardy Ferentschik",
          "commitDateOld": "2009/12/12 上午3:14",
          "commitNameOld": "025b3cc14180d0459856bc45a6cac7acce3e1265",
          "commitAuthorOld": "Hardy Ferentschik",
          "daysBetweenCommits": 6.08,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
          "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
          "functionStartLine": 431,
          "functionName": "bindClass",
          "functionAnnotation": "",
          "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n",
          "diff": "@@ -1,201 +1,200 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n     bindQueries(clazzToProcess, mappings);\n     bindFilterDefs(clazzToProcess, mappings);\n     bindTypeDefs(clazzToProcess, mappings);\n     BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     String discrimValue \u003d null;\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n     Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n     Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n         if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n-    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n+    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n-        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n-        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n+        AccessType propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n-        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n+        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n-        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n+        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
            "newValue": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n\n@param clazzToProcess entity to bind as {@code XClass} instance\n@param inheritanceStatePerClass Meta data about the inheritance relationships for all mapped classes\n@param mappings Mapping meta data\n@throws MappingException in case there is an configuration error\n"
          }
        }
      ]
    },
    "025b3cc14180d0459856bc45a6cac7acce3e1265": {
      "type": "Ybodychange",
      "commitMessage": " HHH-4527\nNo functional changes yet. Just some cleanup and refactoring (extract method, encapsulate field)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18211 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/12/12 上午3:14",
      "commitName": "025b3cc14180d0459856bc45a6cac7acce3e1265",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009/12/10 下午5:32",
      "commitNameOld": "ba3639a25a2e3a59b2252aab1d20b0addb178864",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 1.4,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (!isEntityClassType(clazzToProcess, classType)) {\n        return;\n    }\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n    bindQueries(clazzToProcess, mappings);\n    bindFilterDefs(clazzToProcess, mappings);\n    bindTypeDefs(clazzToProcess, mappings);\n    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    String discrimValue \u003d null;\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents()) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents()) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n        if (inheritanceState.hasParents()) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents()) {\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.getClazz();\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents()) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 428,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,250 +1,201 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n-    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n-        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n-            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n-        }\n+    if (!isEntityClassType(clazzToProcess, classType)) {\n         return;\n     }\n-    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n-        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n-    }\n-    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n-    final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n-    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n-    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n-    if (superEntity \u003d\u003d null) {\n-        if (inheritanceState.hasParents) {\n-            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n-        }\n-    }\n-    bindQueries(annotatedClass, mappings);\n-    bindFilterDefs(annotatedClass, mappings);\n-    bindTypeDefs(annotatedClass, mappings);\n-    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n+    PersistentClass superEntity \u003d getSuperEntity(clazzToProcess, inheritanceStatePerClass, mappings, inheritanceState);\n+    bindQueries(clazzToProcess, mappings);\n+    bindFilterDefs(clazzToProcess, mappings);\n+    bindTypeDefs(clazzToProcess, mappings);\n+    BinderHelper.bindAnyMetaDefs(clazzToProcess, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n-    String discrimValue \u003d null;\n     List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n-    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n-    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n-    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n-        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n+    if (clazzToProcess.isAnnotationPresent(javax.persistence.Table.class)) {\n+        javax.persistence.Table tabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n-    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n-    if (hasJoinedColumns) {\n-        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n-        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n-        if (explicitInheritanceJoinedColumns) {\n-            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n-            PrimaryKeyJoinColumn jcAnn;\n-            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n-            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n-                jcAnn \u003d jcsAnn.value()[colIndex];\n-                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n-            }\n-        } else {\n-            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n-            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n-            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n-        }\n-        log.debug(\"Subclass joined column(s) created\");\n-    } else {\n-        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n-            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n-        }\n-    }\n-    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n-        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n+    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d makeInheritanceJoinColumns(clazzToProcess, mappings, inheritanceState, superEntity);\n+    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n+    String discrimValue \u003d null;\n+    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n+        javax.persistence.DiscriminatorColumn discAnn \u003d clazzToProcess.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n-        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n-        if (!inheritanceState.hasParents) {\n+        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n+        if (!inheritanceState.hasParents()) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n-        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n+        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents()) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n-        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n+        discrimValue \u003d clazzToProcess.isAnnotationPresent(DiscriminatorValue.class) ? clazzToProcess.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n-    PersistentClass persistentClass;\n-    if (!inheritanceState.hasParents) {\n-        persistentClass \u003d new RootClass();\n-    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n-        persistentClass \u003d new SingleTableSubclass(superEntity);\n-    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n-        persistentClass \u003d new JoinedSubclass(superEntity);\n-    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n-        persistentClass \u003d new UnionSubclass(superEntity);\n-    } else {\n-        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n-    }\n-    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n-    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n-    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n-    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n-    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n-    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n+    PersistentClass persistentClass \u003d makePersistentClass(inheritanceState, superEntity);\n+    Proxy proxyAnn \u003d clazzToProcess.getAnnotation(Proxy.class);\n+    BatchSize sizeAnn \u003d clazzToProcess.getAnnotation(BatchSize.class);\n+    Where whereAnn \u003d clazzToProcess.getAnnotation(Where.class);\n+    Entity entityAnn \u003d clazzToProcess.getAnnotation(Entity.class);\n+    org.hibernate.annotations.Entity hibEntityAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Entity.class);\n+    org.hibernate.annotations.Cache cacheAnn \u003d clazzToProcess.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n-    if (!inheritanceState.hasParents) {\n+    if (!inheritanceState.hasParents()) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n-        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n+        Check checkAnn \u003d clazzToProcess.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n-        if (annotatedClass.isAnnotationPresent(Table.class)) {\n+        if (clazzToProcess.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n-    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n-    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n+    javax.persistence.SecondaryTable secTabAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTable.class);\n+    javax.persistence.SecondaryTables secTabsAnn \u003d clazzToProcess.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n-    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n+    OnDelete onDeleteAnn \u003d clazzToProcess.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n-    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n+    if (InheritanceType.JOINED.equals(inheritanceState.getType()) \u0026\u0026 inheritanceState.hasParents()) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n-        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n+        ForeignKey fk \u003d clazzToProcess.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n-    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n-        if (inheritanceState.hasParents) {\n+    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.getType())) {\n+        if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n-            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n+            if (inheritanceState.hasSiblings() || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n-    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n-        if (inheritanceState.hasParents) {\n+    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.getType())) {\n+        if (inheritanceState.hasParents()) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n-    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n+    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(clazzToProcess, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n-    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n+    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.getType() \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents();\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n-    if (!inheritanceState.hasParents) {\n-        current \u003d inheritanceState.clazz;\n+    if (!inheritanceState.hasParents()) {\n         InheritanceState state \u003d inheritanceState;\n         do {\n-            current \u003d state.clazz;\n+            current \u003d state.getClazz();\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n-            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n+            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n-        XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n+        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n-    if (!inheritanceState.hasParents) {\n+    if (!inheritanceState.hasParents()) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n-    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n-    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n-    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n+    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, clazzToProcess));\n+    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Table.class));\n+    entityBinder.processComplementaryTableDefinitions(clazzToProcess.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4553 - Hibernate doesn\u0027t support official JPA2 escape char for table name\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18148 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/12/7 上午6:20",
      "commitName": "a2bf14ae7c2ed7b2b0a6eb558dad08bcfc69c489",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2009/12/1 上午12:50",
      "commitNameOld": "6458ff4771ab9ed37bddb783148aff82e40cd600",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents) {\n        current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 427,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,250 +1,250 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n-    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n+    List\u003cUniqueConstraintHolder\u003e uniqueConstraints \u003d new ArrayList\u003cUniqueConstraintHolder\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n-        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n+        uniqueConstraints \u003d TableBinder.buildUniqueConstraintHolders(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents) {\n         current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n         if (superclass !\u003d null) {\n             superclass.setDeclaredIdentifierMapper(mapper);\n         } else {\n             persistentClass.setDeclaredIdentifierMapper(mapper);\n         }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 Populate the JPA 2 metamodel with the new mapping.MappedSuperclass metadata\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17879 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/10/30 上午2:57",
      "commitName": "fb9bdb7f387a4c8e100e2a8109e3c9b8706f4fed",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/10/29 上午8:36",
      "commitNameOld": "1352b5e25f330f2838e27fb8b5ba1c05d4b8c8ab",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents) {\n        current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n        if (superclass !\u003d null) {\n            superclass.setDeclaredIdentifierMapper(mapper);\n        } else {\n            persistentClass.setDeclaredIdentifierMapper(mapper);\n        }\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,244 +1,250 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents) {\n         current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n+        final org.hibernate.mapping.MappedSuperclass superclass \u003d BinderHelper.getMappedSuperclassOrNull(inferredData.getDeclaringClass(), inheritanceStatePerClass, mappings);\n+        if (superclass !\u003d null) {\n+            superclass.setDeclaredIdentifierMapper(mapper);\n+        } else {\n+            persistentClass.setDeclaredIdentifierMapper(mapper);\n+        }\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7c6981a558e35f01ff8d27938e98aa83896765c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4533 add representation for @MappedSuperclass in the Hibernate Core metamodel and properly populate this model extension in Hibernate Annotations\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17871 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/10/29 上午2:14",
      "commitName": "c7c6981a558e35f01ff8d27938e98aa83896765c",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/10/28 下午6:57",
      "commitNameOld": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents) {\n        current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,243 +1,244 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n         bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n-    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n+    final ReflectionManager reflectionManager \u003d mappings.getReflectionManager();\n+    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, reflectionManager);\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     if (!inheritanceState.hasParents) {\n         bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n-    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n+    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings, inheritanceStatePerClass);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n-    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n+    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(persistentClass, clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents) {\n         current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n-            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n+            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, reflectionManager);\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n-        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n+        XClass compositeClass \u003d reflectionManager.toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n-        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n+        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings, inheritanceStatePerClass);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n-        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n+        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings, inheritanceStatePerClass);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n-            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n+            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings, inheritanceStatePerClass);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4332 Filters for MappedSuperClass\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17859 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/10/28 下午6:57",
      "commitName": "a1e8d7cb0dcb4bd58fc5d210031bd0fb28196034",
      "commitAuthor": "Sharath Reddy",
      "commitDateOld": "2009/10/27 下午11:05",
      "commitNameOld": "2176af11442c702aefa1900cdba4c32e6338b620",
      "commitAuthorOld": "Hardy Ferentschik",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n        bindFilterDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    if (!inheritanceState.hasParents) {\n        bindFilters(clazzToProcess, entityBinder, mappings);\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents) {\n        current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,249 +1,243 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n+        bindFilterDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n-    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n-    if (filterAnn !\u003d null) {\n-        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n-    }\n-    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n-    if (filtersAnn !\u003d null) {\n-        for (Filter filter : filtersAnn.value()) {\n-            entityBinder.addFilter(filter.name(), filter.condition());\n-        }\n+    if (!inheritanceState.hasParents) {\n+        bindFilters(clazzToProcess, entityBinder, mappings);\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     XClass current \u003d null;\n     if (!inheritanceState.hasParents) {\n         current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2176af11442c702aefa1900cdba4c32e6338b620": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4528 - Applied patch (with minor cleanup)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17849 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/10/27 下午11:05",
      "commitName": "2176af11442c702aefa1900cdba4c32e6338b620",
      "commitAuthor": "Hardy Ferentschik",
      "commitDateOld": "2009/10/22 上午1:16",
      "commitNameOld": "d26c00225847f5b4e869146188e3e80914367d7a",
      "commitAuthorOld": "Sharath Reddy",
      "daysBetweenCommits": 5.91,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn !\u003d null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn !\u003d null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    XClass current \u003d null;\n    if (!inheritanceState.hasParents) {\n        current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,247 +1,249 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n         bindTypeDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n     if (filterAnn !\u003d null) {\n         entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n     }\n     Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n     if (filtersAnn !\u003d null) {\n         for (Filter filter : filtersAnn.value()) {\n             entityBinder.addFilter(filter.name(), filter.condition());\n         }\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n+    XClass current \u003d null;\n     if (!inheritanceState.hasParents) {\n-        XClass current \u003d inheritanceState.clazz;\n+        current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n+        PropertyData baseInferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", current);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n-        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n+        bindId(generatorType, generator, inferredData, baseInferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n-        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n+        Component mapper \u003d fillComponent(propertyHolder, inferredData, baseInferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4232 TypeDef support when used on @Embeddable or @MappedSuperClass classes\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17531 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/9/23 上午1:43",
      "commitName": "8cc9e9d5fd2e13844ed222e144c48f7df4487fa4",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/9/23 上午1:19",
      "commitNameOld": "88caf4d9586e988675254c268f4e145d272a9499",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n        bindTypeDefs(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn !\u003d null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn !\u003d null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    if (!inheritanceState.hasParents) {\n        XClass current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,246 +1,247 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n         bindQueries(clazzToProcess, mappings);\n+        bindTypeDefs(clazzToProcess, mappings);\n     }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n     if (filterAnn !\u003d null) {\n         entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n     }\n     Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n     if (filtersAnn !\u003d null) {\n         for (Filter filter : filtersAnn.value()) {\n             entityBinder.addFilter(filter.name(), filter.condition());\n         }\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     if (!inheritanceState.hasParents) {\n         XClass current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88caf4d9586e988675254c268f4e145d272a9499": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4364 support @NamedQuery on a @MappedSuperclass (Sharath Reddy)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@17530 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/9/23 上午1:19",
      "commitName": "88caf4d9586e988675254c268f4e145d272a9499",
      "commitAuthor": "Emmanuel Bernard",
      "commitDateOld": "2009/7/23 上午4:40",
      "commitNameOld": "eeb136fa719fe007158d90ba011473ea7d1fa38b",
      "commitAuthorOld": "Emmanuel Bernard",
      "daysBetweenCommits": 61.86,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n        bindQueries(clazzToProcess, mappings);\n    }\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn !\u003d null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn !\u003d null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    if (!inheritanceState.hasParents) {\n        XClass current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 426,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "@@ -1,243 +1,246 @@\n public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n     InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n     AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n+    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType)) {\n+        bindQueries(clazzToProcess, mappings);\n+    }\n     if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n         if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n             log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n         }\n         return;\n     }\n     if (!classType.equals(AnnotatedClassType.ENTITY)) {\n         throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n     }\n     XAnnotatedElement annotatedClass \u003d clazzToProcess;\n     log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n     InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n     PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n     if (superEntity \u003d\u003d null) {\n         if (inheritanceState.hasParents) {\n             throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n         }\n     }\n     bindQueries(annotatedClass, mappings);\n     bindFilterDefs(annotatedClass, mappings);\n     bindTypeDefs(annotatedClass, mappings);\n     BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n     String schema \u003d \"\";\n     String table \u003d \"\";\n     String catalog \u003d \"\";\n     String discrimValue \u003d null;\n     List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n     Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n     Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n     if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n         javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n         table \u003d tabAnn.name();\n         schema \u003d tabAnn.schema();\n         catalog \u003d tabAnn.catalog();\n         uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n     }\n     final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n     if (hasJoinedColumns) {\n         PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n         boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n         if (explicitInheritanceJoinedColumns) {\n             int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n             PrimaryKeyJoinColumn jcAnn;\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n             for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                 jcAnn \u003d jcsAnn.value()[colIndex];\n                 inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n             }\n         } else {\n             PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n             inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n             inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n         }\n         log.debug(\"Subclass joined column(s) created\");\n     } else {\n         if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n             log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n         }\n     }\n     if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n         DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n         org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n         if (!inheritanceState.hasParents) {\n             discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n         }\n         if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n             log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n         }\n         discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n     }\n     PersistentClass persistentClass;\n     if (!inheritanceState.hasParents) {\n         persistentClass \u003d new RootClass();\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         persistentClass \u003d new SingleTableSubclass(superEntity);\n     } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n         persistentClass \u003d new JoinedSubclass(superEntity);\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         persistentClass \u003d new UnionSubclass(superEntity);\n     } else {\n         throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n     }\n     Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n     BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n     Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n     Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n     org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n     org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n     EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n     entityBinder.setDiscriminatorValue(discrimValue);\n     entityBinder.setBatchSize(sizeAnn);\n     entityBinder.setProxy(proxyAnn);\n     entityBinder.setWhere(whereAnn);\n     entityBinder.setCache(cacheAnn);\n     entityBinder.setInheritanceState(inheritanceState);\n     Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n     if (filterAnn !\u003d null) {\n         entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n     }\n     Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n     if (filtersAnn !\u003d null) {\n         for (Filter filter : filtersAnn.value()) {\n             entityBinder.addFilter(filter.name(), filter.condition());\n         }\n     }\n     entityBinder.bindEntity();\n     if (inheritanceState.hasTable()) {\n         Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n         String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n         entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n     } else {\n         if (annotatedClass.isAnnotationPresent(Table.class)) {\n             log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n         }\n     }\n     PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n     javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n     javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n     entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n     OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n     boolean onDeleteAppropriate \u003d false;\n     if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n         onDeleteAppropriate \u003d true;\n         final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n         if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n             persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n         }\n         SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n         jsc.setKey(key);\n         ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n         if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n             key.setForeignKeyName(fk.name());\n         }\n         if (onDeleteAnn !\u003d null) {\n             key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n         } else {\n             key.setCascadeDeleteEnabled(false);\n         }\n         SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n         mappings.addSecondPass(sp);\n         mappings.addSecondPass(new CreateKeySecondPass(jsc));\n     } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n             }\n         } else {\n             if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                 bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                 entityBinder.bindDiscriminatorValue();\n             }\n         }\n     } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n         if (inheritanceState.hasParents) {\n             if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                 persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n             }\n         }\n     }\n     if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n         log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n     }\n     HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n     List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n     if (elements \u003d\u003d null) {\n         throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n     }\n     final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n     Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n     IdClass idClass \u003d null;\n     if (!inheritanceState.hasParents) {\n         XClass current \u003d inheritanceState.clazz;\n         InheritanceState state \u003d inheritanceState;\n         do {\n             current \u003d state.clazz;\n             if (current.isAnnotationPresent(IdClass.class)) {\n                 idClass \u003d current.getAnnotation(IdClass.class);\n                 break;\n             }\n             state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n         } while (state !\u003d null);\n     }\n     if (idClass !\u003d null) {\n         XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n         boolean isComponent \u003d true;\n         boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n         String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n         String generatorType \u003d \"assigned\";\n         String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n         PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n         HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n         boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n         entityBinder.setIgnoreIdAnnotations(true);\n         bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n         inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n         Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n         entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n         persistentClass.setIdentifierMapper(mapper);\n         Property property \u003d new Property();\n         property.setName(\"_identifierMapper\");\n         property.setNodeName(\"id\");\n         property.setUpdateable(false);\n         property.setInsertable(false);\n         property.setValue(mapper);\n         property.setPropertyAccessorName(\"embedded\");\n         persistentClass.addProperty(property);\n         entityBinder.setIgnoreIdAnnotations(true);\n         Iterator properties \u003d mapper.getPropertyIterator();\n         while (properties.hasNext()) {\n             idProperties.add(((Property) properties.next()).getName());\n         }\n     }\n     Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n     for (PropertyData propertyAnnotatedElement : elements) {\n         String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n         if (!idProperties.contains(propertyName)) {\n             processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n         } else {\n             missingIdProperties.remove(propertyName);\n         }\n     }\n     if (missingIdProperties.size() !\u003d 0) {\n         StringBuilder missings \u003d new StringBuilder();\n         for (String property : missingIdProperties) {\n             missings.append(property).append(\", \");\n         }\n         throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n     }\n     if (!inheritanceState.hasParents) {\n         final RootClass rootClass \u003d (RootClass) persistentClass;\n         mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n     } else {\n         superEntity.addSubclass((Subclass) persistentClass);\n     }\n     mappings.addClass(persistentClass);\n     mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n     entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9d7a03a5f7f03bc803d897baa590861154b39f5e": {
      "type": "Yfilerename",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15418 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/29 上午2:53",
      "commitName": "9d7a03a5f7f03bc803d897baa590861154b39f5e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2008/10/29 上午2:52",
      "commitNameOld": "c457f2b3258fc48ef4010a9e58cd2fc3baaca6cc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn !\u003d null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn !\u003d null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    if (!inheritanceState.hasParents) {\n        XClass current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 394,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "annotations/src/java/org/hibernate/cfg/AnnotationBinder.java",
        "newPath": "annotations/src/main/java/org/hibernate/cfg/AnnotationBinder.java"
      }
    },
    "7337743c93574823424ed6c399cfcf6bd75614f8": {
      "type": "Yintroduced",
      "commitMessage": "HHH-3550 : import annotations into core\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@15415 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2008/10/29 上午2:41",
      "commitName": "7337743c93574823424ed6c399cfcf6bd75614f8",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,243 @@\n+public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n+    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n+    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n+    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n+        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n+            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n+        }\n+        return;\n+    }\n+    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n+        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n+    }\n+    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n+    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n+    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n+    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n+    if (superEntity \u003d\u003d null) {\n+        if (inheritanceState.hasParents) {\n+            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n+        }\n+    }\n+    bindQueries(annotatedClass, mappings);\n+    bindFilterDefs(annotatedClass, mappings);\n+    bindTypeDefs(annotatedClass, mappings);\n+    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n+    String schema \u003d \"\";\n+    String table \u003d \"\";\n+    String catalog \u003d \"\";\n+    String discrimValue \u003d null;\n+    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n+    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n+    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n+    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n+        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n+        table \u003d tabAnn.name();\n+        schema \u003d tabAnn.schema();\n+        catalog \u003d tabAnn.catalog();\n+        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n+    }\n+    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n+    if (hasJoinedColumns) {\n+        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n+        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n+        if (explicitInheritanceJoinedColumns) {\n+            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n+            PrimaryKeyJoinColumn jcAnn;\n+            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n+            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n+                jcAnn \u003d jcsAnn.value()[colIndex];\n+                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n+            }\n+        } else {\n+            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n+            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n+            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n+        }\n+        log.debug(\"Subclass joined column(s) created\");\n+    } else {\n+        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n+            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n+        }\n+    }\n+    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n+        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n+        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n+        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n+        if (!inheritanceState.hasParents) {\n+            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n+        }\n+        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n+            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n+        }\n+        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n+    }\n+    PersistentClass persistentClass;\n+    if (!inheritanceState.hasParents) {\n+        persistentClass \u003d new RootClass();\n+    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n+        persistentClass \u003d new SingleTableSubclass(superEntity);\n+    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n+        persistentClass \u003d new JoinedSubclass(superEntity);\n+    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n+        persistentClass \u003d new UnionSubclass(superEntity);\n+    } else {\n+        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n+    }\n+    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n+    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n+    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n+    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n+    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n+    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n+    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n+    entityBinder.setDiscriminatorValue(discrimValue);\n+    entityBinder.setBatchSize(sizeAnn);\n+    entityBinder.setProxy(proxyAnn);\n+    entityBinder.setWhere(whereAnn);\n+    entityBinder.setCache(cacheAnn);\n+    entityBinder.setInheritanceState(inheritanceState);\n+    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n+    if (filterAnn !\u003d null) {\n+        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n+    }\n+    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n+    if (filtersAnn !\u003d null) {\n+        for (Filter filter : filtersAnn.value()) {\n+            entityBinder.addFilter(filter.name(), filter.condition());\n+        }\n+    }\n+    entityBinder.bindEntity();\n+    if (inheritanceState.hasTable()) {\n+        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n+        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n+        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n+    } else {\n+        if (annotatedClass.isAnnotationPresent(Table.class)) {\n+            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n+        }\n+    }\n+    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n+    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n+    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n+    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n+    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n+    boolean onDeleteAppropriate \u003d false;\n+    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n+        onDeleteAppropriate \u003d true;\n+        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n+        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n+            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n+        }\n+        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n+        jsc.setKey(key);\n+        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n+        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n+            key.setForeignKeyName(fk.name());\n+        }\n+        if (onDeleteAnn !\u003d null) {\n+            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n+        } else {\n+            key.setCascadeDeleteEnabled(false);\n+        }\n+        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n+        mappings.addSecondPass(sp);\n+        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n+    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n+        if (inheritanceState.hasParents) {\n+            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n+                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n+            }\n+        } else {\n+            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n+                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n+                entityBinder.bindDiscriminatorValue();\n+            }\n+        }\n+    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n+        if (inheritanceState.hasParents) {\n+            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n+                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n+            }\n+        }\n+    }\n+    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n+        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n+    }\n+    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n+    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n+    if (elements \u003d\u003d null) {\n+        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n+    }\n+    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n+    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n+    IdClass idClass \u003d null;\n+    if (!inheritanceState.hasParents) {\n+        XClass current \u003d inheritanceState.clazz;\n+        InheritanceState state \u003d inheritanceState;\n+        do {\n+            current \u003d state.clazz;\n+            if (current.isAnnotationPresent(IdClass.class)) {\n+                idClass \u003d current.getAnnotation(IdClass.class);\n+                break;\n+            }\n+            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n+        } while (state !\u003d null);\n+    }\n+    if (idClass !\u003d null) {\n+        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n+        boolean isComponent \u003d true;\n+        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n+        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n+        String generatorType \u003d \"assigned\";\n+        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n+        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n+        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n+        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n+        entityBinder.setIgnoreIdAnnotations(true);\n+        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n+        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n+        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n+        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n+        persistentClass.setIdentifierMapper(mapper);\n+        Property property \u003d new Property();\n+        property.setName(\"_identifierMapper\");\n+        property.setNodeName(\"id\");\n+        property.setUpdateable(false);\n+        property.setInsertable(false);\n+        property.setValue(mapper);\n+        property.setPropertyAccessorName(\"embedded\");\n+        persistentClass.addProperty(property);\n+        entityBinder.setIgnoreIdAnnotations(true);\n+        Iterator properties \u003d mapper.getPropertyIterator();\n+        while (properties.hasNext()) {\n+            idProperties.add(((Property) properties.next()).getName());\n+        }\n+    }\n+    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n+    for (PropertyData propertyAnnotatedElement : elements) {\n+        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n+        if (!idProperties.contains(propertyName)) {\n+            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n+        } else {\n+            missingIdProperties.remove(propertyName);\n+        }\n+    }\n+    if (missingIdProperties.size() !\u003d 0) {\n+        StringBuilder missings \u003d new StringBuilder();\n+        for (String property : missingIdProperties) {\n+            missings.append(property).append(\", \");\n+        }\n+        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n+    }\n+    if (!inheritanceState.hasParents) {\n+        final RootClass rootClass \u003d (RootClass) persistentClass;\n+        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n+    } else {\n+        superEntity.addSubclass((Subclass) persistentClass);\n+    }\n+    mappings.addClass(persistentClass);\n+    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n+    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n+    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static void bindClass(XClass clazzToProcess, Map\u003cXClass, InheritanceState\u003e inheritanceStatePerClass, ExtendedMappings mappings) throws MappingException {\n    InheritanceState inheritanceState \u003d inheritanceStatePerClass.get(clazzToProcess);\n    AnnotatedClassType classType \u003d mappings.getClassType(clazzToProcess);\n    if (AnnotatedClassType.EMBEDDABLE_SUPERCLASS.equals(classType) || AnnotatedClassType.NONE.equals(classType) || AnnotatedClassType.EMBEDDABLE.equals(classType)) {\n        if (AnnotatedClassType.NONE.equals(classType) \u0026\u0026 clazzToProcess.isAnnotationPresent(org.hibernate.annotations.Entity.class)) {\n            log.warn(\"Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity \" + \"(most likely a user error): {}\", clazzToProcess.getName());\n        }\n        return;\n    }\n    if (!classType.equals(AnnotatedClassType.ENTITY)) {\n        throw new AnnotationException(\"Annotated class should have a @javax.persistence.Entity, @javax.persistence.Embeddable or @javax.persistence.EmbeddedSuperclass annotation: \" + clazzToProcess.getName());\n    }\n    XAnnotatedElement annotatedClass \u003d clazzToProcess;\n    log.info(\"Binding entity from annotated class: {}\", clazzToProcess.getName());\n    InheritanceState superEntityState \u003d InheritanceState.getSuperEntityInheritanceState(clazzToProcess, inheritanceStatePerClass, mappings.getReflectionManager());\n    PersistentClass superEntity \u003d superEntityState !\u003d null ? mappings.getClass(superEntityState.clazz.getName()) : null;\n    if (superEntity \u003d\u003d null) {\n        if (inheritanceState.hasParents) {\n            throw new AssertionFailure(\"Subclass has to be binded after it\u0027s mother class: \" + superEntityState.clazz.getName());\n        }\n    }\n    bindQueries(annotatedClass, mappings);\n    bindFilterDefs(annotatedClass, mappings);\n    bindTypeDefs(annotatedClass, mappings);\n    BinderHelper.bindAnyMetaDefs(annotatedClass, mappings);\n    String schema \u003d \"\";\n    String table \u003d \"\";\n    String catalog \u003d \"\";\n    String discrimValue \u003d null;\n    List\u003cString[]\u003e uniqueConstraints \u003d new ArrayList\u003cString[]\u003e();\n    Ejb3DiscriminatorColumn discriminatorColumn \u003d null;\n    Ejb3JoinColumn[] inheritanceJoinedColumns \u003d null;\n    if (annotatedClass.isAnnotationPresent(javax.persistence.Table.class)) {\n        javax.persistence.Table tabAnn \u003d annotatedClass.getAnnotation(javax.persistence.Table.class);\n        table \u003d tabAnn.name();\n        schema \u003d tabAnn.schema();\n        catalog \u003d tabAnn.catalog();\n        uniqueConstraints \u003d TableBinder.buildUniqueConstraints(tabAnn.uniqueConstraints());\n    }\n    final boolean hasJoinedColumns \u003d inheritanceState.hasParents \u0026\u0026 InheritanceType.JOINED.equals(inheritanceState.type);\n    if (hasJoinedColumns) {\n        PrimaryKeyJoinColumns jcsAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumns.class);\n        boolean explicitInheritanceJoinedColumns \u003d jcsAnn !\u003d null \u0026\u0026 jcsAnn.value().length !\u003d 0;\n        if (explicitInheritanceJoinedColumns) {\n            int nbrOfInhJoinedColumns \u003d jcsAnn.value().length;\n            PrimaryKeyJoinColumn jcAnn;\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[nbrOfInhJoinedColumns];\n            for (int colIndex \u003d 0; colIndex \u003c nbrOfInhJoinedColumns; colIndex++) {\n                jcAnn \u003d jcsAnn.value()[colIndex];\n                inheritanceJoinedColumns[colIndex] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n            }\n        } else {\n            PrimaryKeyJoinColumn jcAnn \u003d annotatedClass.getAnnotation(PrimaryKeyJoinColumn.class);\n            inheritanceJoinedColumns \u003d new Ejb3JoinColumn[1];\n            inheritanceJoinedColumns[0] \u003d Ejb3JoinColumn.buildJoinColumn(jcAnn, null, superEntity.getIdentifier(), (Map\u003cString, Join\u003e) null, (PropertyHolder) null, mappings);\n        }\n        log.debug(\"Subclass joined column(s) created\");\n    } else {\n        if (annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumns.class) || annotatedClass.isAnnotationPresent(javax.persistence.PrimaryKeyJoinColumn.class)) {\n            log.warn(\"Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored\");\n        }\n    }\n    if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        javax.persistence.DiscriminatorColumn discAnn \u003d annotatedClass.getAnnotation(javax.persistence.DiscriminatorColumn.class);\n        DiscriminatorType discriminatorType \u003d discAnn !\u003d null ? discAnn.discriminatorType() : DiscriminatorType.STRING;\n        org.hibernate.annotations.DiscriminatorFormula discFormulaAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.DiscriminatorFormula.class);\n        if (!inheritanceState.hasParents) {\n            discriminatorColumn \u003d Ejb3DiscriminatorColumn.buildDiscriminatorColumn(discriminatorType, discAnn, discFormulaAnn, mappings);\n        }\n        if (discAnn !\u003d null \u0026\u0026 inheritanceState.hasParents) {\n            log.warn(\"Discriminator column has to be defined in the root entity, it will be ignored in subclass: {}\", clazzToProcess.getName());\n        }\n        discrimValue \u003d annotatedClass.isAnnotationPresent(DiscriminatorValue.class) ? annotatedClass.getAnnotation(DiscriminatorValue.class).value() : null;\n    }\n    PersistentClass persistentClass;\n    if (!inheritanceState.hasParents) {\n        persistentClass \u003d new RootClass();\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        persistentClass \u003d new SingleTableSubclass(superEntity);\n    } else if (InheritanceType.JOINED.equals(inheritanceState.type)) {\n        persistentClass \u003d new JoinedSubclass(superEntity);\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        persistentClass \u003d new UnionSubclass(superEntity);\n    } else {\n        throw new AssertionFailure(\"Unknown inheritance type: \" + inheritanceState.type);\n    }\n    Proxy proxyAnn \u003d annotatedClass.getAnnotation(Proxy.class);\n    BatchSize sizeAnn \u003d annotatedClass.getAnnotation(BatchSize.class);\n    Where whereAnn \u003d annotatedClass.getAnnotation(Where.class);\n    Entity entityAnn \u003d annotatedClass.getAnnotation(Entity.class);\n    org.hibernate.annotations.Entity hibEntityAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Entity.class);\n    org.hibernate.annotations.Cache cacheAnn \u003d annotatedClass.getAnnotation(org.hibernate.annotations.Cache.class);\n    EntityBinder entityBinder \u003d new EntityBinder(entityAnn, hibEntityAnn, clazzToProcess, persistentClass, mappings);\n    entityBinder.setDiscriminatorValue(discrimValue);\n    entityBinder.setBatchSize(sizeAnn);\n    entityBinder.setProxy(proxyAnn);\n    entityBinder.setWhere(whereAnn);\n    entityBinder.setCache(cacheAnn);\n    entityBinder.setInheritanceState(inheritanceState);\n    Filter filterAnn \u003d annotatedClass.getAnnotation(Filter.class);\n    if (filterAnn !\u003d null) {\n        entityBinder.addFilter(filterAnn.name(), filterAnn.condition());\n    }\n    Filters filtersAnn \u003d annotatedClass.getAnnotation(Filters.class);\n    if (filtersAnn !\u003d null) {\n        for (Filter filter : filtersAnn.value()) {\n            entityBinder.addFilter(filter.name(), filter.condition());\n        }\n    }\n    entityBinder.bindEntity();\n    if (inheritanceState.hasTable()) {\n        Check checkAnn \u003d annotatedClass.getAnnotation(Check.class);\n        String constraints \u003d checkAnn \u003d\u003d null ? null : checkAnn.constraints();\n        entityBinder.bindTable(schema, catalog, table, uniqueConstraints, constraints, inheritanceState.hasDenormalizedTable() ? superEntity.getTable() : null);\n    } else {\n        if (annotatedClass.isAnnotationPresent(Table.class)) {\n            log.warn(\"Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: \" + clazzToProcess.getName());\n        }\n    }\n    PropertyHolder propertyHolder \u003d PropertyHolderBuilder.buildPropertyHolder(clazzToProcess, persistentClass, entityBinder, mappings);\n    javax.persistence.SecondaryTable secTabAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTable.class);\n    javax.persistence.SecondaryTables secTabsAnn \u003d annotatedClass.getAnnotation(javax.persistence.SecondaryTables.class);\n    entityBinder.firstLevelSecondaryTablesBinding(secTabAnn, secTabsAnn);\n    OnDelete onDeleteAnn \u003d annotatedClass.getAnnotation(OnDelete.class);\n    boolean onDeleteAppropriate \u003d false;\n    if (InheritanceType.JOINED.equals(inheritanceState.type) \u0026\u0026 inheritanceState.hasParents) {\n        onDeleteAppropriate \u003d true;\n        final JoinedSubclass jsc \u003d (JoinedSubclass) persistentClass;\n        if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n            persistentClass.getRootClass().setEntityPersisterClass(JoinedSubclassEntityPersister.class);\n        }\n        SimpleValue key \u003d new DependantValue(jsc.getTable(), jsc.getIdentifier());\n        jsc.setKey(key);\n        ForeignKey fk \u003d annotatedClass.getAnnotation(ForeignKey.class);\n        if (fk !\u003d null \u0026\u0026 !BinderHelper.isDefault(fk.name())) {\n            key.setForeignKeyName(fk.name());\n        }\n        if (onDeleteAnn !\u003d null) {\n            key.setCascadeDeleteEnabled(OnDeleteAction.CASCADE.equals(onDeleteAnn.action()));\n        } else {\n            key.setCascadeDeleteEnabled(false);\n        }\n        SecondPass sp \u003d new JoinedSubclassFkSecondPass(jsc, inheritanceJoinedColumns, key, mappings);\n        mappings.addSecondPass(sp);\n        mappings.addSecondPass(new CreateKeySecondPass(jsc));\n    } else if (InheritanceType.SINGLE_TABLE.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(SingleTableEntityPersister.class);\n            }\n        } else {\n            if (inheritanceState.hasSons || !discriminatorColumn.isImplicit()) {\n                bindDiscriminatorToPersistentClass((RootClass) persistentClass, discriminatorColumn, entityBinder.getSecondaryTables(), propertyHolder);\n                entityBinder.bindDiscriminatorValue();\n            }\n        }\n    } else if (InheritanceType.TABLE_PER_CLASS.equals(inheritanceState.type)) {\n        if (inheritanceState.hasParents) {\n            if (persistentClass.getEntityPersisterClass() \u003d\u003d null) {\n                persistentClass.getRootClass().setEntityPersisterClass(UnionSubclassEntityPersister.class);\n            }\n        }\n    }\n    if (onDeleteAnn !\u003d null \u0026\u0026 !onDeleteAppropriate) {\n        log.warn(\"Inapropriate use of @OnDelete on entity, annotation ignored: {}\", propertyHolder.getEntityName());\n    }\n    HashMap\u003cString, IdGenerator\u003e classGenerators \u003d buildLocalGenerators(annotatedClass, mappings);\n    List\u003cPropertyData\u003e elements \u003d getElementsToProcess(clazzToProcess, inheritanceStatePerClass, propertyHolder, entityBinder, mappings);\n    if (elements \u003d\u003d null) {\n        throw new AnnotationException(\"No identifier specified for entity: \" + propertyHolder.getEntityName());\n    }\n    final boolean subclassAndSingleTableStrategy \u003d inheritanceState.type \u003d\u003d InheritanceType.SINGLE_TABLE \u0026\u0026 inheritanceState.hasParents;\n    Set\u003cString\u003e idProperties \u003d new HashSet\u003cString\u003e();\n    IdClass idClass \u003d null;\n    if (!inheritanceState.hasParents) {\n        XClass current \u003d inheritanceState.clazz;\n        InheritanceState state \u003d inheritanceState;\n        do {\n            current \u003d state.clazz;\n            if (current.isAnnotationPresent(IdClass.class)) {\n                idClass \u003d current.getAnnotation(IdClass.class);\n                break;\n            }\n            state \u003d InheritanceState.getSuperclassInheritanceState(current, inheritanceStatePerClass, mappings.getReflectionManager());\n        } while (state !\u003d null);\n    }\n    if (idClass !\u003d null) {\n        XClass compositeClass \u003d mappings.getReflectionManager().toXClass(idClass.value());\n        boolean isComponent \u003d true;\n        boolean propertyAnnotated \u003d entityBinder.isPropertyAnnotated(compositeClass);\n        String propertyAccessor \u003d entityBinder.getPropertyAccessor(compositeClass);\n        String generatorType \u003d \"assigned\";\n        String generator \u003d BinderHelper.ANNOTATION_STRING_DEFAULT;\n        PropertyData inferredData \u003d new PropertyPreloadedData(entityBinder.getPropertyAccessor(), \"id\", compositeClass);\n        HashMap\u003cString, IdGenerator\u003e localGenerators \u003d new HashMap\u003cString, IdGenerator\u003e();\n        boolean ignoreIdAnnotations \u003d entityBinder.isIgnoreIdAnnotations();\n        entityBinder.setIgnoreIdAnnotations(true);\n        bindId(generatorType, generator, inferredData, null, propertyHolder, localGenerators, isComponent, propertyAnnotated, propertyAccessor, entityBinder, true, false, mappings);\n        inferredData \u003d new PropertyPreloadedData(propertyAccessor, \"_identifierMapper\", compositeClass);\n        Component mapper \u003d fillComponent(propertyHolder, inferredData, propertyAnnotated, propertyAccessor, false, entityBinder, true, true, false, mappings);\n        entityBinder.setIgnoreIdAnnotations(ignoreIdAnnotations);\n        persistentClass.setIdentifierMapper(mapper);\n        Property property \u003d new Property();\n        property.setName(\"_identifierMapper\");\n        property.setNodeName(\"id\");\n        property.setUpdateable(false);\n        property.setInsertable(false);\n        property.setValue(mapper);\n        property.setPropertyAccessorName(\"embedded\");\n        persistentClass.addProperty(property);\n        entityBinder.setIgnoreIdAnnotations(true);\n        Iterator properties \u003d mapper.getPropertyIterator();\n        while (properties.hasNext()) {\n            idProperties.add(((Property) properties.next()).getName());\n        }\n    }\n    Set\u003cString\u003e missingIdProperties \u003d new HashSet\u003cString\u003e(idProperties);\n    for (PropertyData propertyAnnotatedElement : elements) {\n        String propertyName \u003d propertyAnnotatedElement.getPropertyName();\n        if (!idProperties.contains(propertyName)) {\n            processElementAnnotations(propertyHolder, subclassAndSingleTableStrategy ? Nullability.FORCED_NULL : Nullability.NO_CONSTRAINT, propertyAnnotatedElement.getProperty(), propertyAnnotatedElement, classGenerators, entityBinder, false, false, false, mappings);\n        } else {\n            missingIdProperties.remove(propertyName);\n        }\n    }\n    if (missingIdProperties.size() !\u003d 0) {\n        StringBuilder missings \u003d new StringBuilder();\n        for (String property : missingIdProperties) {\n            missings.append(property).append(\", \");\n        }\n        throw new AnnotationException(\"Unable to find properties (\" + missings.substring(0, missings.length() - 2) + \") in entity annotated with @IdClass:\" + persistentClass.getEntityName());\n    }\n    if (!inheritanceState.hasParents) {\n        final RootClass rootClass \u003d (RootClass) persistentClass;\n        mappings.addSecondPass(new CreateKeySecondPass(rootClass));\n    } else {\n        superEntity.addSubclass((Subclass) persistentClass);\n    }\n    mappings.addClass(persistentClass);\n    mappings.addSecondPass(new SecondaryTableSecondPass(entityBinder, propertyHolder, annotatedClass));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Table.class));\n    entityBinder.processComplementaryTableDefinitions(annotatedClass.getAnnotation(org.hibernate.annotations.Tables.class));\n}",
      "path": "annotations/src/java/org/hibernate/cfg/AnnotationBinder.java",
      "functionStartLine": 394,
      "functionName": "bindClass",
      "functionAnnotation": "",
      "functionDoc": "Bind a class having JSR175 annotations\nThe subclasses \u003cb\u003ehave to\u003c/b\u003e be binded after its mother class\n"
    }
  }
}