{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "CheckpointCoordinator.java",
  "functionName": "receiveAcknowledgeMessage",
  "functionId": "receiveAcknowledgeMessage___message-AcknowledgeCheckpoint",
  "sourceFilePath": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
  "functionAnnotation": "",
  "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.\n",
  "functionStartLine": 726,
  "functionEndLine": 808,
  "numCommitsSeen": 101,
  "timeTaken": 5889,
  "changeHistory": [
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
    "2edc97185700a5bdb3e181a71493d681c0f693e3",
    "f63426b0322e05fd0986ae5f224a69b1320724f6",
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
    "ea7080712f2dcbdf125b806007c80aa3d120f30a",
    "b181662be378652d6c4405841ccda6145968d145",
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
    "c590912c93a4059b40452dfa6cffbdd4d58cac13",
    "72b295b3b52dff2d0bc5b78881826e8936c370ff",
    "48a48139172e86f548f3b2f1564bdc948c3fe76a",
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
    "847ead01f2f0aaf318b2b1ba8501bc697d245900",
    "4e9d1775b5514c87981c78d55323cc2b17361867",
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
    "f0ac261add2eb184358d5b89bc90b13aef7b267d",
    "0cf04108f70375d41ebb7c39629db3a081bd2876",
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
    "55fd5f32d7ef0292a01192ab08456fae49b91791",
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
    "0ecab82add0946503a000162813bb820f6f3b4d4",
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
    "59bee4ad825d7252c791e0376ea2504602134fe7",
    "9b7f8aa121e4a231632296d0809029aca9ebde6a",
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be"
  ],
  "changeHistoryShort": {
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533": "Ybodychange",
    "2edc97185700a5bdb3e181a71493d681c0f693e3": "Ybodychange",
    "f63426b0322e05fd0986ae5f224a69b1320724f6": "Ydocchange",
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483": "Ybodychange",
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ea7080712f2dcbdf125b806007c80aa3d120f30a": "Ybodychange",
    "b181662be378652d6c4405841ccda6145968d145": "Ybodychange",
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b": "Ybodychange",
    "c590912c93a4059b40452dfa6cffbdd4d58cac13": "Ybodychange",
    "72b295b3b52dff2d0bc5b78881826e8936c370ff": "Ybodychange",
    "48a48139172e86f548f3b2f1564bdc948c3fe76a": "Ybodychange",
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d": "Ybodychange",
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977": "Ybodychange",
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c": "Ybodychange",
    "847ead01f2f0aaf318b2b1ba8501bc697d245900": "Ybodychange",
    "4e9d1775b5514c87981c78d55323cc2b17361867": "Ybodychange",
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868": "Ybodychange",
    "f0ac261add2eb184358d5b89bc90b13aef7b267d": "Ybodychange",
    "0cf04108f70375d41ebb7c39629db3a081bd2876": "Ybodychange",
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2": "Ybodychange",
    "55fd5f32d7ef0292a01192ab08456fae49b91791": "Ybodychange",
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b": "Ybodychange",
    "0ecab82add0946503a000162813bb820f6f3b4d4": "Ybodychange",
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a": "Ybodychange",
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705": "Ybodychange",
    "59bee4ad825d7252c791e0376ea2504602134fe7": "Ybodychange",
    "9b7f8aa121e4a231632296d0809029aca9ebde6a": "Ybodychange",
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6014] [checkpoint] Additional review changes\n",
      "commitDate": "2017/4/22 下午9:25",
      "commitName": "aa21f853ab0380ec1f68ae1d0b7c8d9268da4533",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2017/4/22 下午9:25",
      "commitNameOld": "218bed8b8e49b0e4c61c61f696a8f010eafea1b7",
      "commitAuthorOld": "xiaogang.sxg",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 687,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,50 +1,50 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                 case SUCCESS:\n                     LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n                         completePendingCheckpoint(checkpoint);\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+                    discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n             return true;\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             boolean wasPendingCheckpoint;\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 wasPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                 wasPendingCheckpoint \u003d false;\n             }\n-            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+            discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             return wasPendingCheckpoint;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2edc97185700a5bdb3e181a71493d681c0f693e3": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5763] [checkpoints] Acknowledge with explicit ID and CheckpointMetrics\n\nInstead of acknowledging checkpoints with the CheckpointMetaData make\nthe acknowledgement explicit by ID and CheckpointMetrics. The rest is\nnot needed.\n",
      "commitDate": "2017/2/22 下午7:14",
      "commitName": "2edc97185700a5bdb3e181a71493d681c0f693e3",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2017/2/21 上午2:43",
      "commitNameOld": "f63426b0322e05fd0986ae5f224a69b1320724f6",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 628,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,50 +1,50 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n+            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {\n                 case SUCCESS:\n                     LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n                         completePendingCheckpoint(checkpoint);\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n             return true;\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             boolean wasPendingCheckpoint;\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 wasPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                 wasPendingCheckpoint \u003d false;\n             }\n             discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             return wasPendingCheckpoint;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f63426b0322e05fd0986ae5f224a69b1320724f6": {
      "type": "Ydocchange",
      "commitMessage": "[hotfix] [jobmanager] Minor code cleanups in JobGraph and CheckpointCoordinator\n\nThis makes the exception that can occur during serialization of the ExecutionConfig explicit,\nand adds some comments to JobGraph.\n",
      "commitDate": "2017/2/21 上午2:43",
      "commitName": "f63426b0322e05fd0986ae5f224a69b1320724f6",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2017/1/24 下午10:51",
      "commitNameOld": "acfeeaf5e337e56300d10a3a991e79edc827ac7a",
      "commitAuthorOld": "Stefan Richter",
      "daysBetweenCommits": 27.16,
      "commitsBetweenForRepo": 169,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 628,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
        "newValue": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.\n"
      }
    },
    "579bc96446d598a2cfe8237b4ebd62d8c9df3483": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4410] [runtime] Rework checkpoint stats tracking\n",
      "commitDate": "2017/1/10 下午4:48",
      "commitName": "579bc96446d598a2cfe8237b4ebd62d8c9df3483",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016/12/9 下午11:05",
      "commitNameOld": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 31.74,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 628,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,50 +1,50 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {\n                 case SUCCESS:\n                     LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n                         completePendingCheckpoint(checkpoint);\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n             return true;\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             boolean wasPendingCheckpoint;\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 wasPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                 wasPendingCheckpoint \u003d false;\n             }\n             discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             return wasPendingCheckpoint;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
      "commitDate": "2016/12/9 下午11:05",
      "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
      "commitAuthor": "Till Rohrmann",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
          "commitDate": "2016/12/9 下午11:05",
          "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
          "commitAuthor": "Till Rohrmann",
          "commitDateOld": "2016/12/9 下午9:42",
          "commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 612,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
          "diff": "@@ -1,79 +1,50 @@\n-public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n-        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n-    CompletedCheckpoint completed \u003d null;\n-    PendingCheckpoint checkpoint;\n-    boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n-        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-            isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n                     LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n-                        lastCheckpointCompletionNanos \u003d System.nanoTime();\n-                        completed \u003d checkpoint.finalizeCheckpoint();\n-                        completedCheckpointStore.addCheckpoint(completed);\n-                        LOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId, completed.getStateSize(), completed.getDuration());\n-                        if (LOG.isDebugEnabled()) {\n-                            StringBuilder builder \u003d new StringBuilder();\n-                            builder.append(\"Checkpoint state: \");\n-                            for (TaskState state : completed.getTaskStates().values()) {\n-                                builder.append(state);\n-                                builder.append(\", \");\n-                            }\n-                            builder.delete(builder.length() - 2, builder.length());\n-                            LOG.debug(builder.toString());\n-                        }\n-                        pendingCheckpoints.remove(checkpointId);\n-                        rememberRecentCheckpointId(checkpointId);\n-                        dropSubsumedCheckpoints(completed.getCheckpointID());\n-                        triggerQueuedRequests();\n+                        completePendingCheckpoint(checkpoint);\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n+            return true;\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n+            boolean wasPendingCheckpoint;\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n-                isPendingCheckpoint \u003d true;\n+                wasPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n-                isPendingCheckpoint \u003d false;\n+                wasPendingCheckpoint \u003d false;\n             }\n             discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+            return wasPendingCheckpoint;\n         }\n     }\n-    if (completed !\u003d null) {\n-        final long timestamp \u003d completed.getTimestamp();\n-        for (ExecutionVertex ev : tasksToCommitTo) {\n-            Execution ee \u003d ev.getCurrentExecutionAttempt();\n-            if (ee !\u003d null) {\n-                ee.notifyCheckpointComplete(checkpointId, timestamp);\n-            }\n-        }\n-        statsTracker.onCompletedCheckpoint(completed);\n-    }\n-    return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[Exception]",
            "newValue": "[CheckpointException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-5158] [ckPtCoord] Handle exceptions from CompletedCheckpointStore in CheckpointCoordinator\n\nHandle exceptions from the CompletedCheckpointStore properly in the CheckpointCoordinator. This\nmeans that in case of an exception, the completed checkpoint will be properly cleaned up and also\nthe triggering of subsequent checkpoints will be started.\n\nThis closes #2872.\n",
          "commitDate": "2016/12/9 下午11:05",
          "commitName": "0c42d258e9d9d30eeeee7d0f1487ef0ac8b90fa4",
          "commitAuthor": "Till Rohrmann",
          "commitDateOld": "2016/12/9 下午9:42",
          "commitNameOld": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completePendingCheckpoint(checkpoint);\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n            return true;\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            boolean wasPendingCheckpoint;\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                wasPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                wasPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            return wasPendingCheckpoint;\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 612,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
          "diff": "@@ -1,79 +1,50 @@\n-public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n-        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+        LOG.error(\"Received wrong AcknowledgeCheckpoint message for job {}: {}\", job, message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n-    CompletedCheckpoint completed \u003d null;\n-    PendingCheckpoint checkpoint;\n-    boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n-        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+        final PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-            isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n                     LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n-                        lastCheckpointCompletionNanos \u003d System.nanoTime();\n-                        completed \u003d checkpoint.finalizeCheckpoint();\n-                        completedCheckpointStore.addCheckpoint(completed);\n-                        LOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId, completed.getStateSize(), completed.getDuration());\n-                        if (LOG.isDebugEnabled()) {\n-                            StringBuilder builder \u003d new StringBuilder();\n-                            builder.append(\"Checkpoint state: \");\n-                            for (TaskState state : completed.getTaskStates().values()) {\n-                                builder.append(state);\n-                                builder.append(\", \");\n-                            }\n-                            builder.delete(builder.length() - 2, builder.length());\n-                            LOG.debug(builder.toString());\n-                        }\n-                        pendingCheckpoints.remove(checkpointId);\n-                        rememberRecentCheckpointId(checkpointId);\n-                        dropSubsumedCheckpoints(completed.getCheckpointID());\n-                        triggerQueuedRequests();\n+                        completePendingCheckpoint(checkpoint);\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n+            return true;\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n+            boolean wasPendingCheckpoint;\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n-                isPendingCheckpoint \u003d true;\n+                wasPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n-                isPendingCheckpoint \u003d false;\n+                wasPendingCheckpoint \u003d false;\n             }\n             discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n+            return wasPendingCheckpoint;\n         }\n     }\n-    if (completed !\u003d null) {\n-        final long timestamp \u003d completed.getTimestamp();\n-        for (ExecutionVertex ev : tasksToCommitTo) {\n-            Execution ee \u003d ev.getCurrentExecutionAttempt();\n-            if (ee !\u003d null) {\n-                ee.notifyCheckpointComplete(checkpointId, timestamp);\n-            }\n-        }\n-        statsTracker.onCompletedCheckpoint(completed);\n-    }\n-    return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea7080712f2dcbdf125b806007c80aa3d120f30a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5278] Improve task and checkpoint related logging\n\nAdd more logging\n\nThis closes #2959.\n",
      "commitDate": "2016/12/9 下午9:42",
      "commitName": "ea7080712f2dcbdf125b806007c80aa3d120f30a",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016/12/1 下午10:55",
      "commitNameOld": "b181662be378652d6c4405841ccda6145968d145",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 7.95,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                    if (checkpoint.isFullyAcknowledged()) {\n                        lastCheckpointCompletionNanos \u003d System.nanoTime();\n                        completed \u003d checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId, completed.getStateSize(), completed.getDuration());\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder \u003d new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                isPendingCheckpoint \u003d false;\n            }\n            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 612,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,78 +1,79 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n+                    LOG.debug(\"Received acknowledge message for checkpoint {} from task {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                     if (checkpoint.isFullyAcknowledged()) {\n                         lastCheckpointCompletionNanos \u003d System.nanoTime();\n                         completed \u003d checkpoint.finalizeCheckpoint();\n                         completedCheckpointStore.addCheckpoint(completed);\n-                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n+                        LOG.info(\"Completed checkpoint {} ({} bytes in {} ms).\", checkpointId, completed.getStateSize(), completed.getDuration());\n                         if (LOG.isDebugEnabled()) {\n                             StringBuilder builder \u003d new StringBuilder();\n                             builder.append(\"Checkpoint state: \");\n                             for (TaskState state : completed.getTaskStates().values()) {\n                                 builder.append(state);\n                                 builder.append(\", \");\n                             }\n                             builder.delete(builder.length() - 2, builder.length());\n                             LOG.debug(builder.toString());\n                         }\n                         pendingCheckpoints.remove(checkpointId);\n                         rememberRecentCheckpointId(checkpointId);\n                         dropSubsumedCheckpoints(completed.getCheckpointID());\n                         triggerQueuedRequests();\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    discardState(message.getSubtaskState());\n+                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    discardState(message.getSubtaskState());\n+                    discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n-                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n+                LOG.warn(\"Received late message for now expired checkpoint attempt {} from \" + \"{} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n             } else {\n-                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n+                LOG.debug(\"Received message for an unknown checkpoint {} from {} of job {}.\", checkpointId, message.getTaskExecutionId(), message.getJob());\n                 isPendingCheckpoint \u003d false;\n             }\n-            discardState(message.getSubtaskState());\n+            discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState());\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b181662be378652d6c4405841ccda6145968d145": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5216] [checkpoints] \u0027Min Time Between Checkpoints\u0027 references timestamp after checkpoint\n",
      "commitDate": "2016/12/1 下午10:55",
      "commitName": "b181662be378652d6c4405841ccda6145968d145",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016/12/1 下午5:44",
      "commitNameOld": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        lastCheckpointCompletionNanos \u003d System.nanoTime();\n                        completed \u003d checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder \u003d new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint \u003d false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 612,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,77 +1,78 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n                     if (checkpoint.isFullyAcknowledged()) {\n+                        lastCheckpointCompletionNanos \u003d System.nanoTime();\n                         completed \u003d checkpoint.finalizeCheckpoint();\n                         completedCheckpointStore.addCheckpoint(completed);\n                         LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                         if (LOG.isDebugEnabled()) {\n                             StringBuilder builder \u003d new StringBuilder();\n                             builder.append(\"Checkpoint state: \");\n                             for (TaskState state : completed.getTaskStates().values()) {\n                                 builder.append(state);\n                                 builder.append(\", \");\n                             }\n                             builder.delete(builder.length() - 2, builder.length());\n                             LOG.debug(builder.toString());\n                         }\n                         pendingCheckpoints.remove(checkpointId);\n                         rememberRecentCheckpointId(checkpointId);\n                         dropSubsumedCheckpoints(completed.getCheckpointID());\n                         triggerQueuedRequests();\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getSubtaskState());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                 isPendingCheckpoint \u003d false;\n             }\n             discardState(message.getSubtaskState());\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5198] [logging] Improve TaskState toString\n",
      "commitDate": "2016/12/1 下午5:44",
      "commitName": "dc7d8ec2c4d03c42e3d582947a3fe39a274d7f4b",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016/11/23 上午6:00",
      "commitNameOld": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 8.49,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed \u003d checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder \u003d new StringBuilder();\n                            builder.append(\"Checkpoint state: \");\n                            for (TaskState state : completed.getTaskStates().values()) {\n                                builder.append(state);\n                                builder.append(\", \");\n                            }\n                            builder.delete(builder.length() - 2, builder.length());\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint \u003d false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 614,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,74 +1,77 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n                     if (checkpoint.isFullyAcknowledged()) {\n                         completed \u003d checkpoint.finalizeCheckpoint();\n                         completedCheckpointStore.addCheckpoint(completed);\n                         LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                         if (LOG.isDebugEnabled()) {\n                             StringBuilder builder \u003d new StringBuilder();\n-                            for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n-                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+                            builder.append(\"Checkpoint state: \");\n+                            for (TaskState state : completed.getTaskStates().values()) {\n+                                builder.append(state);\n+                                builder.append(\", \");\n                             }\n+                            builder.delete(builder.length() - 2, builder.length());\n                             LOG.debug(builder.toString());\n                         }\n                         pendingCheckpoints.remove(checkpointId);\n                         rememberRecentCheckpointId(checkpointId);\n                         dropSubsumedCheckpoints(completed.getCheckpointID());\n                         triggerQueuedRequests();\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     discardState(message.getSubtaskState());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                 isPendingCheckpoint \u003d false;\n             }\n             discardState(message.getSubtaskState());\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c590912c93a4059b40452dfa6cffbdd4d58cac13": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5085] Execute CheckpointCoordinator\u0027s state discard calls asynchronously\n\nThe CheckpointCoordinator is now given an Executor which is used to execute the state discard\ncalls asynchronously. This will prevent blocking operations to be executed from within the\ncalling thread.\n\nShut down ExecutorServices gracefully\n\nThis closes #2825.\n",
      "commitDate": "2016/11/23 上午6:00",
      "commitName": "c590912c93a4059b40452dfa6cffbdd4d58cac13",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016/11/17 上午7:34",
      "commitNameOld": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 5.93,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed \u003d checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder \u003d new StringBuilder();\n                            for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                            }\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    discardState(message.getSubtaskState());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint \u003d false;\n            }\n            discardState(message.getSubtaskState());\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 614,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,86 +1,74 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 case SUCCESS:\n                     if (checkpoint.isFullyAcknowledged()) {\n                         completed \u003d checkpoint.finalizeCheckpoint();\n                         completedCheckpointStore.addCheckpoint(completed);\n                         LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                         if (LOG.isDebugEnabled()) {\n                             StringBuilder builder \u003d new StringBuilder();\n                             for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                                 builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                             }\n                             LOG.debug(builder.toString());\n                         }\n                         pendingCheckpoints.remove(checkpointId);\n                         rememberRecentCheckpointId(checkpointId);\n                         dropSubsumedCheckpoints(completed.getCheckpointID());\n                         triggerQueuedRequests();\n                     }\n                     break;\n                 case DUPLICATE:\n                     LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                     break;\n                 case UNKNOWN:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    try {\n-                        message.getSubtaskState().discardState();\n-                    } catch (Exception e) {\n-                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-                    }\n+                    discardState(message.getSubtaskState());\n                     break;\n                 case DISCARDED:\n                     LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n-                    try {\n-                        message.getSubtaskState().discardState();\n-                    } catch (Exception e) {\n-                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-                    }\n+                    discardState(message.getSubtaskState());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n             } else {\n                 LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                 isPendingCheckpoint \u003d false;\n             }\n-            try {\n-                message.getSubtaskState().discardState();\n-            } catch (Exception e) {\n-                LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n-            }\n+            discardState(message.getSubtaskState());\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "72b295b3b52dff2d0bc5b78881826e8936c370ff": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-5063] [checkpointing] Discard state handles of declined or expired state handles\n\nWhenever the checkpoint coordinator receives an acknowledge checkpoint message which belongs\nto the job maintained by the checkpoint coordinator, it should either record the state handles\nfor later processing or discard to free the resources. The latter case can happen if a\ncheckpoint has been expired and late acknowledge checkpoint messages arrive. Furthremore, it\ncan happen if a Task sent a decline checkpoint message while other Tasks where still drawing\na checkpoint. This PR changes the behaviour such that state handles belonging to the job of\nthe checkpoint coordinator are discarded if they could not be added to the PendingCheckpoint.\n\nThis closes #2812\n",
      "commitDate": "2016/11/17 上午7:34",
      "commitName": "72b295b3b52dff2d0bc5b78881826e8936c370ff",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016/11/9 上午4:15",
      "commitNameOld": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 8.14,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                case SUCCESS:\n                    if (checkpoint.isFullyAcknowledged()) {\n                        completed \u003d checkpoint.finalizeCheckpoint();\n                        completedCheckpointStore.addCheckpoint(completed);\n                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                        if (LOG.isDebugEnabled()) {\n                            StringBuilder builder \u003d new StringBuilder();\n                            for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                            }\n                            LOG.debug(builder.toString());\n                        }\n                        pendingCheckpoints.remove(checkpointId);\n                        rememberRecentCheckpointId(checkpointId);\n                        dropSubsumedCheckpoints(completed.getCheckpointID());\n                        triggerQueuedRequests();\n                    }\n                    break;\n                case DUPLICATE:\n                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    break;\n                case UNKNOWN:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    try {\n                        message.getSubtaskState().discardState();\n                    } catch (Exception e) {\n                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n                    }\n                    break;\n                case DISCARDED:\n                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n                    try {\n                        message.getSubtaskState().discardState();\n                    } catch (Exception e) {\n                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n                    }\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n            } else {\n                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                isPendingCheckpoint \u003d false;\n            }\n            try {\n                message.getSubtaskState().discardState();\n            } catch (Exception e) {\n                LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 611,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,62 +1,86 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n-                if (checkpoint.isFullyAcknowledged()) {\n-                    completed \u003d checkpoint.finalizeCheckpoint();\n-                    completedCheckpointStore.addCheckpoint(completed);\n-                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n-                    if (LOG.isDebugEnabled()) {\n-                        StringBuilder builder \u003d new StringBuilder();\n-                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n-                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+            switch(checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n+                case SUCCESS:\n+                    if (checkpoint.isFullyAcknowledged()) {\n+                        completed \u003d checkpoint.finalizeCheckpoint();\n+                        completedCheckpointStore.addCheckpoint(completed);\n+                        LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n+                        if (LOG.isDebugEnabled()) {\n+                            StringBuilder builder \u003d new StringBuilder();\n+                            for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n+                                builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+                            }\n+                            LOG.debug(builder.toString());\n                         }\n-                        LOG.debug(builder.toString());\n+                        pendingCheckpoints.remove(checkpointId);\n+                        rememberRecentCheckpointId(checkpointId);\n+                        dropSubsumedCheckpoints(completed.getCheckpointID());\n+                        triggerQueuedRequests();\n                     }\n-                    pendingCheckpoints.remove(checkpointId);\n-                    rememberRecentCheckpointId(checkpointId);\n-                    dropSubsumedCheckpoints(completed.getCheckpointID());\n-                    triggerQueuedRequests();\n-                }\n-            } else {\n-                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\", checkpointId, message.getTaskExecutionId());\n+                    break;\n+                case DUPLICATE:\n+                    LOG.debug(\"Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n+                    break;\n+                case UNKNOWN:\n+                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the task\u0027s execution attempt id was unknown. Discarding \" + \"the state handle to avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n+                    try {\n+                        message.getSubtaskState().discardState();\n+                    } catch (Exception e) {\n+                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+                    }\n+                    break;\n+                case DISCARDED:\n+                    LOG.warn(\"Could not acknowledge the checkpoint {} for task {} of job {}, \" + \"because the pending checkpoint had been discarded. Discarding the \" + \"state handle tp avoid lingering state.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob());\n+                    try {\n+                        message.getSubtaskState().discardState();\n+                    } catch (Exception e) {\n+                        LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+                    }\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n-                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n+                LOG.warn(\"Received late message for now expired checkpoint attempt {}.\", checkpointId);\n             } else {\n+                LOG.debug(\"Received message for an unknown checkpoint {}.\", checkpointId);\n                 isPendingCheckpoint \u003d false;\n             }\n+            try {\n+                message.getSubtaskState().discardState();\n+            } catch (Exception e) {\n+                LOG.warn(\"Could not properly discard state for checkpoint {} of task {} of job {}.\", message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e);\n+            }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48a48139172e86f548f3b2f1564bdc948c3fe76a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4985] [checkpointing] Report canceled / declined checkpoints to the Checkpoint Coordinator\n",
      "commitDate": "2016/11/9 上午4:15",
      "commitName": "48a48139172e86f548f3b2f1564bdc948c3fe76a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016/11/2 下午2:34",
      "commitNameOld": "c0e620f0ace0aa3500a5642e7165cf9f05e81f6a",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\", checkpointId, message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 611,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,62 +1,62 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n-                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n+                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint {} , task {}\", checkpointId, message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cfb3790fb6feb6c771bccbd05d3b12c69f53657d": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4887] [execution graph] Introduce TaskManagerGateway to encapsulate communcation logic\n\nAll task manager related logic is now encapsulated in the TaskManagerGateway. Consequently,\nthere is no direct use of the ActorGateway in the ExecutionGraph anymore.\n\nAdd PartitionInfo\n\n[FLINK-4887] Add FutureUtils#retry to automatically retry failed future operations\n\nAdapt job manager\n\n[FLINK-4887] Refactor StackTraceSampleCoordinator to work with TaskManagerGateway and Flink futures\n\n[FLINK-4887] Refactor CheckpointCoordinator to work with TaskManagerGateway\n\n[FLINK-4887] Fix test cases to work with the newly introduce TaskManagerGateway\n\n[FLINK-4887] Update FlinkFuture#handlyAsync to avoid second future operation\n\n[FLINK-4887] Remove TaskOpeartionResult message\n\nMake StackTrace and StackTraceSampleResponse serializable\n\nIncrease timeout of TaskStopTest\n\nThis closes #2699.\n",
      "commitDate": "2016/11/1 下午4:36",
      "commitName": "cfb3790fb6feb6c771bccbd05d3b12c69f53657d",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016/10/28 下午5:04",
      "commitNameOld": "3bc9cad045b25d413f0b9f054fff12fac18a4f0e",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 3.98,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ee.notifyCheckpointComplete(checkpointId, timestamp);\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 615,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,64 +1,62 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n-                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n-                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n+                ee.notifyCheckpointComplete(checkpointId, timestamp);\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4844] Partitionable Raw Keyed/Operator State\n",
      "commitDate": "2016/10/20 下午10:14",
      "commitName": "cab9cd44eca83ef8cbcd2a2d070d8c79cb037977",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016/10/14 下午4:07",
      "commitNameOld": "5783671c2f30228a2d5b5b7bf09b762ae41db8e2",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 619,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,64 +1,64 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getCheckpointStateHandles())) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4379] [checkpoints] Introduce rescalable operator state\n\nThis introduces the Operator State Backend, which stores state that is not partitioned\nby a key. It replaces the \u0027Checkpointed\u0027 interface.\n\nAdditionally, this introduces CheckpointStateHandles as container for all checkpoint related state handles\n\nThis closes #2512\n",
      "commitDate": "2016/9/30 下午6:38",
      "commitName": "53ed6adac8cbe6b5dcb692dc9b94970f3ec5887c",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016/9/27 上午12:05",
      "commitNameOld": "70e71c16177b40c2418e6a8ca0838bf117f6a926",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getCheckpointStateHandles())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 603,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,64 +1,64 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getStateHandle(), message.getKeyGroupsStateHandle())) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getCheckpointStateHandles())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "847ead01f2f0aaf318b2b1ba8501bc697d245900": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4381] Refactor State to Prepare For Key-Group State Backends\n",
      "commitDate": "2016/9/1 上午1:10",
      "commitName": "847ead01f2f0aaf318b2b1ba8501bc697d245900",
      "commitAuthor": "Stefan Richter",
      "commitDateOld": "2016/9/1 上午1:04",
      "commitNameOld": "ec975aaba79449bd93020f296b05ea509ea57bdc",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getStateHandle(), message.getKeyGroupsStateHandle())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 603,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,64 +1,64 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getStateHandle(), message.getKeyGroupsStateHandle())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4e9d1775b5514c87981c78d55323cc2b17361867": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4417] [checkpoints] Checkpoints are subsumed by CheckpointID not, by timestamp\n\nThis closes #2407\n",
      "commitDate": "2016/8/25 上午1:56",
      "commitName": "4e9d1775b5514c87981c78d55323cc2b17361867",
      "commitAuthor": "Ramkrishna",
      "commitDateOld": "2016/8/25 上午1:56",
      "commitNameOld": "4da40bcb9ea01cb0c5e6fd0d7472dc09397f648e",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 618,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,64 +1,64 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n-                    dropSubsumedCheckpoints(completed.getTimestamp());\n+                    dropSubsumedCheckpoints(completed.getCheckpointID());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76ca1a7955fedd8583a0af12289a14d0f1bcf868": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4322] [checkpointing] Unify CheckpointCoordinator and SavepointCoordinator\n\nThe CheckpointCoordinator now also takes over the role of the SavepointCoordinator.\nSavepoints are just like other checkpoints - they only store the metadata in addition.\nRestoring from a savepoint means loading it into the CheckpointStore at startup.\n",
      "commitDate": "2016/8/18 上午1:06",
      "commitName": "76ca1a7955fedd8583a0af12289a14d0f1bcf868",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016/7/26 下午5:30",
      "commitNameOld": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 22.32,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 633,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,65 +1,64 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n-                    onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f0ac261add2eb184358d5b89bc90b13aef7b267d": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4067] [runtime] Add savepoint headers\n\nSavepoints were previously persisted without any meta data using default\nJava serialization of `CompletedCheckpoint`. This commit introduces a\nsavepoint interface with version-specific serializers and stores\nsavepoints with meta data.\n\nSavepoints expose a version number and a Collection\u003cTaskState\u003e for\nsavepoint restore.\n\nCurrently, there is only one savepoint version:\n\nSavepointV0 (Flink 1.1): This is the current savepoint version, which\nholds a reference to the Checkpoint task state collection, but is\nserialized with a custom serializater not relying on default Java\nserialization. Therefore, it should not happen again that we need to\nstick to certain classes in future Flink versions.\n\nThe savepoints are stored in `FsSavepointStore` with the following\nformat:\n\nMagicNumber SavepointVersion Savepoint\n  - MagicNumber \u003d\u003e int\n  - SavepointVersion \u003d\u003e int (returned by Savepoint#getVersion())\n  - Savepoint \u003d\u003e bytes (serialized via version-specific SavepointSerializer)\n\nThe header is minimal (magic number, version). All savepoint-specific\nmeta data can be moved to the savepoint itself. This is also were we\nwould have to add new meta data in future versions, allowing us to\ndifferentiate between different savepoint versions when we change the\nserialization stack.\n\nAll savepoint related classes have been moved from checkpoint to a new\nsub package `checkpoint.savepoint`.\n\nThis closes #2194.\n",
      "commitDate": "2016/7/26 下午5:30",
      "commitName": "f0ac261add2eb184358d5b89bc90b13aef7b267d",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2016/7/22 下午8:26",
      "commitNameOld": "54f02ec7bae56a0559a61b981d0c88885090b128",
      "commitAuthorOld": "Ufuk Celebi",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.finalizeCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 651,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,65 +1,65 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                 if (checkpoint.isFullyAcknowledged()) {\n-                    completed \u003d checkpoint.toCompletedCheckpoint();\n+                    completed \u003d checkpoint.finalizeCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     if (LOG.isDebugEnabled()) {\n                         StringBuilder builder \u003d new StringBuilder();\n                         for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                             builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                         }\n                         LOG.debug(builder.toString());\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                     onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0cf04108f70375d41ebb7c39629db3a081bd2876": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3756] [state] Add state hierarchy to CheckpointCoordinator\n\nThis commit introduces a state hierarchy for the StateForTask objects kept\nat the CheckpointCoordinator. Task states are now grouped together if they\nbelong to the same ExecutionJobVertex. The StateForTask objects are now\nstored in so called StateForTaskGroup objects. The StateForTaskGroup object\ncan also store the key group state handles associated to a ExecutionJobVertex.\n\nAdapt restore methods of CheckpointCoordinator and SavepointCoordinator\n\nAdd state size computation\n\nAdd comments to createKeyGroupPartitions; Add more information to StateForTask.toString\n\nRename StateForTaskGroup -\u003e TaskState, StateForTask -\u003e SubtaskState, KvStateForTasks -\u003e KeyGroupState\n\nThis closes #1883.\n",
      "commitDate": "2016/4/26 下午6:22",
      "commitName": "0cf04108f70375d41ebb7c39629db3a081bd2876",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2016/4/12 上午12:36",
      "commitNameOld": "2e63d1afb2358760109ba0c90011ef565eaae0ff",
      "commitAuthorOld": "zentol",
      "daysBetweenCommits": 14.74,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    if (LOG.isDebugEnabled()) {\n                        StringBuilder builder \u003d new StringBuilder();\n                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n                        }\n                        LOG.debug(builder.toString());\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 623,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
      "diff": "@@ -1,59 +1,65 @@\n public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             isPendingCheckpoint \u003d true;\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize(), null)) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n-                    LOG.debug(completed.getStates().toString());\n+                    if (LOG.isDebugEnabled()) {\n+                        StringBuilder builder \u003d new StringBuilder();\n+                        for (Map.Entry\u003cJobVertexID, TaskState\u003e entry : completed.getTaskStates().entrySet()) {\n+                            builder.append(\"JobVertexID: \").append(entry.getKey()).append(\" {\").append(entry.getValue()).append(\"}\");\n+                        }\n+                        LOG.debug(builder.toString());\n+                    }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                     onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n     return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d739ee2532e0fd49ef37508b1c2e4a355473aaa5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange,Ydocchange)",
      "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
      "commitDate": "2016/1/11 下午11:30",
      "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
      "commitAuthor": "Ufuk Celebi",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
          "commitDate": "2016/1/11 下午11:30",
          "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015/12/31 上午7:45",
          "commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
          "commitAuthorOld": "Ufuk Celebi",
          "daysBetweenCommits": 11.66,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 518,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
          "diff": "@@ -1,54 +1,59 @@\n-public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n-        return;\n+        return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-        return;\n+        return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n+    boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n-            return;\n+            return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+            isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n+                    onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n+                isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n-                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+                isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n+    return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
          "commitDate": "2016/1/11 下午11:30",
          "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015/12/31 上午7:45",
          "commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
          "commitAuthorOld": "Ufuk Celebi",
          "daysBetweenCommits": 11.66,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 518,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
          "diff": "@@ -1,54 +1,59 @@\n-public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n-        return;\n+        return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-        return;\n+        return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n+    boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n-            return;\n+            return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+            isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n+                    onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n+                isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n-                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+                isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n+    return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "[FLINK-2976] [runtime, tests] Add SavepointCoordinator\n\n[comments] Rename config keys\n\n[comments] Fix docs and don\u0027t overload savepoint backend configuration with checkpoint backend configuration\n\n[comments] Use ConcurrentMap in HeapStateStore\n\n[comments] Fix typo and add missing serialVersionUID\n\n[comments] Fix Scala style\n\n[comments] Fix Scala style\n\n[docs] Emphasize dangers and recommended approaches\n\nAdd test to show inf restart loop on submission with unknown savepoint path\n\n[comments] Suppress resart of savepoint recovery failure\n\nThis closes #1434.\n",
          "commitDate": "2016/1/11 下午11:30",
          "commitName": "d739ee2532e0fd49ef37508b1c2e4a355473aaa5",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015/12/31 上午7:45",
          "commitNameOld": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
          "commitAuthorOld": "Ufuk Celebi",
          "daysBetweenCommits": 11.66,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return false;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return false;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    boolean isPendingCheckpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return false;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            isPendingCheckpoint \u003d true;\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    onFullyAcknowledgedCheckpoint(completed);\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                isPendingCheckpoint \u003d true;\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                isPendingCheckpoint \u003d false;\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n    return isPendingCheckpoint;\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 518,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n",
          "diff": "@@ -1,54 +1,59 @@\n-public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n+public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n-        return;\n+        return false;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n-        return;\n+        return false;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n+    boolean isPendingCheckpoint;\n     synchronized (lock) {\n         if (shutdown) {\n-            return;\n+            return false;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+            isPendingCheckpoint \u003d true;\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n+                    onFullyAcknowledgedCheckpoint(completed);\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n+                isPendingCheckpoint \u003d true;\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n-                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+                isPendingCheckpoint \u003d false;\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n         statsTracker.onCompletedCheckpoint(completed);\n     }\n+    return isPendingCheckpoint;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "Receives an AcknowledgeCheckpoint message and returns whether the\nmessage was associated with a pending checkpoint.\n\n@param message Checkpoint ack from the task manager\n@return Flag indicating whether the ack\u0027d checkpoint was associated\nwith a pending checkpoint.\n@throws Exception If the checkpoint cannot be added to the completed checkpoint store.\n"
          }
        }
      ]
    },
    "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3131] [core, runtime] Add checkpoint statistics tracker\n\nAdds a simple tracker of checkpoint statistics.\n",
      "commitDate": "2015/12/31 上午7:45",
      "commitName": "2c7e63ae9ecc38c33f0b45df21bd324c2e597ef2",
      "commitAuthor": "Ufuk Celebi",
      "commitDateOld": "2015/11/27 上午12:16",
      "commitNameOld": "55fd5f32d7ef0292a01192ab08456fae49b91791",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 34.31,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n        statsTracker.onCompletedCheckpoint(completed);\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 464,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,53 +1,54 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n-            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n-                    LOG.info(\"Completed checkpoint \" + checkpointId);\n+                    LOG.info(\"Completed checkpoint \" + checkpointId + \" (in \" + completed.getDuration() + \" ms)\");\n                     LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                     triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n+        statsTracker.onCompletedCheckpoint(completed);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "55fd5f32d7ef0292a01192ab08456fae49b91791": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-3051] [streaming] Add mechanisms to control the maximum number of concurrent checkpoints\n\nThis closes #1408\n",
      "commitDate": "2015/11/27 上午12:16",
      "commitName": "55fd5f32d7ef0292a01192ab08456fae49b91791",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015/11/24 下午4:28",
      "commitNameOld": "c254bda3e84fcd9303f9a9e2a6f7a175d8e70d1e",
      "commitAuthorOld": "Gyula Fora",
      "daysBetweenCommits": 2.32,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    triggerQueuedRequests();\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 459,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,52 +1,53 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpointStore.addCheckpoint(completed);\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n+                    triggerQueuedRequests();\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73c73e92750ab8fb068d0a3cb37afcb642084fc0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
      "commitDate": "2015/10/20 上午6:16",
      "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
      "commitAuthor": "Ufuk Celebi",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
          "commitDate": "2015/10/20 上午6:16",
          "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015/8/31 下午5:02",
          "commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 49.55,
          "commitsBetweenForRepo": 328,
          "commitsBetweenForFile": 1,
          "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 367,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,52 @@\n-public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n-    SuccessfulCheckpoint completed \u003d null;\n+    CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n-                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n-                    completedCheckpoints.addLast(completed);\n-                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-                        completedCheckpoints.removeFirst().discard(userClassLoader);\n-                    }\n+                    completedCheckpointStore.addCheckpoint(completed);\n+                    LOG.info(\"Completed checkpoint \" + checkpointId);\n+                    LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-2354] [runtime] Add job graph and checkpoint recovery\n\nThis closes #1153.\n",
          "commitDate": "2015/10/20 上午6:16",
          "commitName": "73c73e92750ab8fb068d0a3cb37afcb642084fc0",
          "commitAuthor": "Ufuk Celebi",
          "commitDateOld": "2015/8/31 下午5:02",
          "commitNameOld": "b9de4ed37ffa68ef50dc6d6b3819afcc00d1d029",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 49.55,
          "commitsBetweenForRepo": 328,
          "commitsBetweenForFile": 1,
          "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    CompletedCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpointStore.addCheckpoint(completed);\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    LOG.debug(completed.getStates().toString());\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
          "functionStartLine": 367,
          "functionName": "receiveAcknowledgeMessage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,54 +1,52 @@\n-public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n-    SuccessfulCheckpoint completed \u003d null;\n+    CompletedCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n-                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n-                    completedCheckpoints.addLast(completed);\n-                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-                        completedCheckpoints.removeFirst().discard(userClassLoader);\n-                    }\n+                    completedCheckpointStore.addCheckpoint(completed);\n+                    LOG.info(\"Completed checkpoint \" + checkpointId);\n+                    LOG.debug(completed.getStates().toString());\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-2008] [FLINK-2296] Fix checkpoint committing \u0026 KafkaITCase\n\nThis closes #895\n",
      "commitDate": "2015/7/13 下午11:54",
      "commitName": "aa5e5b3087a68f2aac792c0b0fc64b4f9c707e9b",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015/6/25 下午10:38",
      "commitNameOld": "0ecab82add0946503a000162813bb820f6f3b4d4",
      "commitAuthorOld": "Paris Carbone",
      "daysBetweenCommits": 18.05,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 306,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,56 +1,54 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     SuccessfulCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                         completedCheckpoints.removeFirst().discard(userClassLoader);\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-                StateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n-                SerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n-                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, taskState);\n-                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n+                NotifyCheckpointComplete notifyMessage \u003d new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp);\n+                ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ecab82add0946503a000162813bb820f6f3b4d4": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] fix for null state in ConfirmCheckpoint messages\n",
      "commitDate": "2015/6/25 下午10:38",
      "commitName": "0ecab82add0946503a000162813bb820f6f3b4d4",
      "commitAuthor": "Paris Carbone",
      "commitDateOld": "2015/6/25 下午10:38",
      "commitNameOld": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
      "commitAuthorOld": "Paris Carbone",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                StateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n                SerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, taskState);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 308,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,56 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     SuccessfulCheckpoint completed \u003d null;\n     PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                         completedCheckpoints.removeFirst().discard(userClassLoader);\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, completed.getState(ev.getJobvertexId()).getState());\n+                StateForTask stateForTask \u003d completed.getState(ev.getJobvertexId());\n+                SerializedValue\u003cStateHandle\u003c?\u003e\u003e taskState \u003d (stateForTask !\u003d null) ? stateForTask.getState() : null;\n+                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, taskState);\n                 ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f27c3f1d1cbff7433a23227e75f2f8e30058397a": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] Add stateHandle to checkpointed message\n",
      "commitDate": "2015/6/25 下午10:38",
      "commitName": "f27c3f1d1cbff7433a23227e75f2f8e30058397a",
      "commitAuthor": "Paris Carbone",
      "commitDateOld": "2015/6/12 下午3:54",
      "commitNameOld": "078e6ef3ef0d455d6f405c21c1ca209b80418a23",
      "commitAuthorOld": "mbalassi",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    PendingCheckpoint checkpoint;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, completed.getState(ev.getJobvertexId()).getState());\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 306,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,53 +1,54 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     SuccessfulCheckpoint completed \u003d null;\n+    PendingCheckpoint checkpoint;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n-        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+        checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                         completedCheckpoints.removeFirst().discard(userClassLoader);\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n+                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp, completed.getState(ev.getJobvertexId()).getState());\n                 ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "197cd6cf0fb10efc6badd5fc8584f4b36b09e705": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] StateHandleProvider added for configurable state backend\n",
      "commitDate": "2015/5/20 上午12:32",
      "commitName": "197cd6cf0fb10efc6badd5fc8584f4b36b09e705",
      "commitAuthor": "Gyula Fora",
      "commitDateOld": "2015/5/20 上午12:25",
      "commitNameOld": "59bee4ad825d7252c791e0376ea2504602134fe7",
      "commitAuthorOld": "Gyula Fora",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 307,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,53 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     SuccessfulCheckpoint completed \u003d null;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-                        completedCheckpoints.removeFirst().dispose(userClassLoader);\n-                        ;\n+                        completedCheckpoints.removeFirst().discard(userClassLoader);\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59bee4ad825d7252c791e0376ea2504602134fe7": {
      "type": "Ybodychange",
      "commitMessage": "[streaming] Discard method added to state handle\n",
      "commitDate": "2015/5/20 上午12:25",
      "commitName": "59bee4ad825d7252c791e0376ea2504602134fe7",
      "commitAuthor": "Gyula Fora",
      "commitDateOld": "2015/5/13 上午3:35",
      "commitNameOld": "54e957614c38fed69baf726fc86059e9b11384cb",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst().dispose(userClassLoader);\n                        ;\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 307,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,53 +1,54 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n     SuccessfulCheckpoint completed \u003d null;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n                     completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n-                        completedCheckpoints.removeFirst();\n+                        completedCheckpoints.removeFirst().dispose(userClassLoader);\n+                        ;\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n     if (completed !\u003d null) {\n         final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                 ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9b7f8aa121e4a231632296d0809029aca9ebde6a": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1953] [runtime] Integrate new snapshot checkpoint coordinator with jobgraph and execution graph\n\nThis closes #651\n",
      "commitDate": "2015/5/13 上午3:35",
      "commitName": "9b7f8aa121e4a231632296d0809029aca9ebde6a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015/4/29 下午4:47",
      "commitNameOld": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 13.45,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    SuccessfulCheckpoint completed \u003d null;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst();\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (completed !\u003d null) {\n        final long timestamp \u003d completed.getTimestamp();\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 298,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,53 +1,53 @@\n public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n     if (shutdown || message \u003d\u003d null) {\n         return;\n     }\n     if (!job.equals(message.getJob())) {\n         LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n         return;\n     }\n     final long checkpointId \u003d message.getCheckpointId();\n-    boolean checkpointCompleted \u003d false;\n+    SuccessfulCheckpoint completed \u003d null;\n     synchronized (lock) {\n         if (shutdown) {\n             return;\n         }\n         PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n         if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n             if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                 if (checkpoint.isFullyAcknowledged()) {\n                     LOG.info(\"Completed checkpoint \" + checkpointId);\n-                    SuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n+                    completed \u003d checkpoint.toCompletedCheckpoint();\n                     completedCheckpoints.addLast(completed);\n                     if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                         completedCheckpoints.removeFirst();\n                     }\n                     pendingCheckpoints.remove(checkpointId);\n                     rememberRecentCheckpointId(checkpointId);\n                     dropSubsumedCheckpoints(completed.getTimestamp());\n-                    checkpointCompleted \u003d true;\n                 }\n             } else {\n                 LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n             }\n         } else if (checkpoint !\u003d null) {\n             throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n         } else {\n             if (recentPendingCheckpoints.contains(checkpointId)) {\n                 LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n             } else {\n                 LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n             }\n         }\n     }\n-    if (checkpointCompleted) {\n+    if (completed !\u003d null) {\n+        final long timestamp \u003d completed.getTimestamp();\n         for (ExecutionVertex ev : tasksToCommitTo) {\n             Execution ee \u003d ev.getCurrentExecutionAttempt();\n             if (ee !\u003d null) {\n                 ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n-                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n+                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId, timestamp);\n                 ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be": {
      "type": "Yintroduced",
      "commitMessage": "[FLINK-1953] [runtime] Implement robust and flexible checkpoint coordinator with tests.\n\n - Checkpoints can be configured to have different sets of tasks\n   that triggering the checkpoint barriers, that acknowledging the checkpoint,\n   and that require checkpoint confirmations.\n\n - A configurable number of successful chckpoints can be retained\n\n - Checkpoints time out after a certain time, if not acknowledged (prevent resource leaks)\n\n - Checkpoints are robust to lost messages and out of order acknowledging.\n",
      "commitDate": "2015/4/29 下午4:47",
      "commitName": "7f0ce1428bc32181d6d79ca6f1226b9e2e3d93be",
      "commitAuthor": "Stephan Ewen",
      "diff": "@@ -0,0 +1,53 @@\n+public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n+    if (shutdown || message \u003d\u003d null) {\n+        return;\n+    }\n+    if (!job.equals(message.getJob())) {\n+        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n+        return;\n+    }\n+    final long checkpointId \u003d message.getCheckpointId();\n+    boolean checkpointCompleted \u003d false;\n+    synchronized (lock) {\n+        if (shutdown) {\n+            return;\n+        }\n+        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n+        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n+            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n+                if (checkpoint.isFullyAcknowledged()) {\n+                    LOG.info(\"Completed checkpoint \" + checkpointId);\n+                    SuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n+                    completedCheckpoints.addLast(completed);\n+                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n+                        completedCheckpoints.removeFirst();\n+                    }\n+                    pendingCheckpoints.remove(checkpointId);\n+                    rememberRecentCheckpointId(checkpointId);\n+                    dropSubsumedCheckpoints(completed.getTimestamp());\n+                    checkpointCompleted \u003d true;\n+                }\n+            } else {\n+                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n+            }\n+        } else if (checkpoint !\u003d null) {\n+            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n+        } else {\n+            if (recentPendingCheckpoints.contains(checkpointId)) {\n+                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n+            } else {\n+                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n+            }\n+        }\n+    }\n+    if (checkpointCompleted) {\n+        for (ExecutionVertex ev : tasksToCommitTo) {\n+            Execution ee \u003d ev.getCurrentExecutionAttempt();\n+            if (ee !\u003d null) {\n+                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n+                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n+                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void receiveAcknowledgeMessage(AcknowledgeCheckpoint message) {\n    if (shutdown || message \u003d\u003d null) {\n        return;\n    }\n    if (!job.equals(message.getJob())) {\n        LOG.error(\"Received AcknowledgeCheckpoint message for wrong job: {}\", message);\n        return;\n    }\n    final long checkpointId \u003d message.getCheckpointId();\n    boolean checkpointCompleted \u003d false;\n    synchronized (lock) {\n        if (shutdown) {\n            return;\n        }\n        PendingCheckpoint checkpoint \u003d pendingCheckpoints.get(checkpointId);\n        if (checkpoint !\u003d null \u0026\u0026 !checkpoint.isDiscarded()) {\n            if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState())) {\n                if (checkpoint.isFullyAcknowledged()) {\n                    LOG.info(\"Completed checkpoint \" + checkpointId);\n                    SuccessfulCheckpoint completed \u003d checkpoint.toCompletedCheckpoint();\n                    completedCheckpoints.addLast(completed);\n                    if (completedCheckpoints.size() \u003e numSuccessfulCheckpointsToRetain) {\n                        completedCheckpoints.removeFirst();\n                    }\n                    pendingCheckpoints.remove(checkpointId);\n                    rememberRecentCheckpointId(checkpointId);\n                    dropSubsumedCheckpoints(completed.getTimestamp());\n                    checkpointCompleted \u003d true;\n                }\n            } else {\n                LOG.error(\"Received duplicate or invalid acknowledge message for checkpoint \" + checkpointId + \" , task \" + message.getTaskExecutionId());\n            }\n        } else if (checkpoint !\u003d null) {\n            throw new IllegalStateException(\"Received message for discarded but non-removed checkpoint \" + checkpointId);\n        } else {\n            if (recentPendingCheckpoints.contains(checkpointId)) {\n                LOG.warn(\"Received late message for now expired checkpoint attempt \" + checkpointId);\n            } else {\n                LOG.info(\"Received message for non-existing checkpoint \" + checkpointId);\n            }\n        }\n    }\n    if (checkpointCompleted) {\n        for (ExecutionVertex ev : tasksToCommitTo) {\n            Execution ee \u003d ev.getCurrentExecutionAttempt();\n            if (ee !\u003d null) {\n                ExecutionAttemptID attemptId \u003d ee.getAttemptId();\n                ConfirmCheckpoint confirmMessage \u003d new ConfirmCheckpoint(job, attemptId, checkpointId);\n                ev.sendMessageToCurrentExecution(confirmMessage, ee.getAttemptId());\n            }\n        }\n    }\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointCoordinator.java",
      "functionStartLine": 263,
      "functionName": "receiveAcknowledgeMessage",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}