{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "PojoSerializer.java",
  "functionName": "deserialize",
  "functionId": "deserialize___source-DataInputView",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
  "functionAnnotation": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
  "functionDoc": "",
  "functionStartLine": 369,
  "functionEndLine": 428,
  "numCommitsSeen": 24,
  "timeTaken": 1737,
  "changeHistory": [
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8",
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
    "21a715867d655bb61df9a9f7eef37e42b99e206a",
    "6ba5fcdf85f802748fd47218ce8c41a617d224c9",
    "7407076d3990752eb5fa4072cd036efd2f656cbc",
    "926f835adb9cb77bcda19e4ed009cc07c89cea74",
    "76d4a75e823c31a899f2143fb6be185b90e55532"
  ],
  "changeHistoryShort": {
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8": "Ybodychange",
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": "Ybodychange",
    "21a715867d655bb61df9a9f7eef37e42b99e206a": "Yfilerename",
    "6ba5fcdf85f802748fd47218ce8c41a617d224c9": "Yannotationchange",
    "7407076d3990752eb5fa4072cd036efd2f656cbc": "Ymultichange(Ybodychange,Yannotationchange)",
    "926f835adb9cb77bcda19e4ed009cc07c89cea74": "Ybodychange",
    "76d4a75e823c31a899f2143fb6be185b90e55532": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6801] [core] Allow deserialized PojoSerializer to have removed fields\n\nPrior to this commit, deserializing the PojoSerializer would fail when\nwe encounter a missing field that existed in the POJO type before. It is\nactually perfectly fine to have a missing field; the deserialized\nPojoSerializer should simply skip reading the removed field\u0027s previously\nserialized values, i.e. much like how Java Object Serialization works.\n\nThis commit relaxes the deserialization of the PojoSerializer, so that a\nnull will be used as a placeholder value to indicate a removed field\nthat previously existed. De-/serialization and copying methods on the\nPojoSerializer will respect null Fields and simply skip them.\n",
      "commitDate": "2017/6/13 下午12:38",
      "commitName": "ae285f9bd5398fe4d8d86eb3207bbc5beb8a24c8",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2017/6/13 下午12:38",
      "commitNameOld": "c929eb30867bb1f539c98fe9e47f91790bd85764",
      "commitAuthorOld": "Tzu-Li (Gordon) Tai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (fields[i] !\u003d null) {\n                    if (isNull) {\n                        fields[i].set(target, null);\n                    } else {\n                        Object field \u003d fieldSerializers[i].deserialize(source);\n                        fields[i].set(target, field);\n                    }\n                } else if (!isNull) {\n                    fieldSerializers[i].deserialize(source);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 369,
      "functionName": "deserialize",
      "functionAnnotation": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,53 @@\n @Override\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n public T deserialize(DataInputView source) throws IOException {\n     int flags \u003d source.readByte();\n     if ((flags \u0026 IS_NULL) !\u003d 0) {\n         return null;\n     }\n     T target;\n     Class\u003c?\u003e actualSubclass \u003d null;\n     TypeSerializer subclassSerializer \u003d null;\n     if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n         String subclassName \u003d source.readUTF();\n         try {\n             actualSubclass \u003d Class.forName(subclassName, true, cl);\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(\"Cannot instantiate class.\", e);\n         }\n         subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n         int subclassTag \u003d source.readByte();\n         subclassSerializer \u003d registeredSerializers[subclassTag];\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else {\n         target \u003d createInstance();\n     }\n     if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n         try {\n             for (int i \u003d 0; i \u003c numFields; i++) {\n                 boolean isNull \u003d source.readBoolean();\n-                if (isNull) {\n-                    fields[i].set(target, null);\n-                } else {\n-                    Object field \u003d fieldSerializers[i].deserialize(source);\n-                    fields[i].set(target, field);\n+                if (fields[i] !\u003d null) {\n+                    if (isNull) {\n+                        fields[i].set(target, null);\n+                    } else {\n+                        Object field \u003d fieldSerializers[i].deserialize(source);\n+                        fields[i].set(target, field);\n+                    }\n+                } else if (!isNull) {\n+                    fieldSerializers[i].deserialize(source);\n                 }\n             }\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n         }\n     } else {\n         if (subclassSerializer !\u003d null) {\n             target \u003d (T) subclassSerializer.deserialize(target, source);\n         }\n     }\n     return target;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-6178] [core] Allow serializer upgrades for managed state\n\nThis commit adds the functionality of allowing serializer upgrades for\nFlink\u0027s managed state. It consists of 2 major changes: 1) new\nuser-facing API in `TypeSerializer`, and 2) activate serializer upgrades\nin state backends.\n\nFor 1) new user-facing API for `TypeSerializer`, the following is added:\n- new class: TypeSerializerConfigSnapshot\n- new class: CompatibilityResult\n- new method: TypeSerializer#snapshotConfiguration()\n- new method:\n  TypeSerializer#ensureCompatibility(TypeSerializerConfigSnapshot)\n\nGenerally speaking, configuration snapshots contains a point-in-time\nview of a serializer\u0027s state / configuration, and is persisted along\nwith checkpoints. On restore, the configuration is confronted with the\nnew serializer of the state to check for compatibility, which may\nintroduce reconfiguration of the new serializer to be compatible.\n\nThis compatibility check is integrated in the state backends\u0027 restore\nflow in 2). Currently, if the check results in the need to perform state\nmigration, the restore simply fails as the state migration feature isn\u0027t\nyet available.\n",
      "commitDate": "2017/5/8 上午2:04",
      "commitName": "8aa5e05733655e7b3d1f11ed15f61672d61e5cb5",
      "commitAuthor": "Tzu-Li (Gordon) Tai",
      "commitDateOld": "2017/2/20 上午8:01",
      "commitNameOld": "082d40fdc415952737a109c913a86d009ed234c1",
      "commitAuthorOld": "Fabian Hueske",
      "daysBetweenCommits": 76.75,
      "commitsBetweenForRepo": 545,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (isNull) {\n                    fields[i].set(target, null);\n                } else {\n                    Object field \u003d fieldSerializers[i].deserialize(source);\n                    fields[i].set(target, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 340,
      "functionName": "deserialize",
      "functionAnnotation": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n @Override\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n public T deserialize(DataInputView source) throws IOException {\n     int flags \u003d source.readByte();\n     if ((flags \u0026 IS_NULL) !\u003d 0) {\n         return null;\n     }\n     T target;\n     Class\u003c?\u003e actualSubclass \u003d null;\n     TypeSerializer subclassSerializer \u003d null;\n     if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n         String subclassName \u003d source.readUTF();\n         try {\n             actualSubclass \u003d Class.forName(subclassName, true, cl);\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(\"Cannot instantiate class.\", e);\n         }\n         subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n         int subclassTag \u003d source.readByte();\n         subclassSerializer \u003d registeredSerializers[subclassTag];\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else {\n         target \u003d createInstance();\n     }\n     if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n         try {\n             for (int i \u003d 0; i \u003c numFields; i++) {\n                 boolean isNull \u003d source.readBoolean();\n                 if (isNull) {\n                     fields[i].set(target, null);\n                 } else {\n                     Object field \u003d fieldSerializers[i].deserialize(source);\n                     fields[i].set(target, field);\n                 }\n             }\n         } catch (IllegalAccessException e) {\n-            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields before.\", e);\n         }\n     } else {\n         if (subclassSerializer !\u003d null) {\n             target \u003d (T) subclassSerializer.deserialize(target, source);\n         }\n     }\n     return target;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "21a715867d655bb61df9a9f7eef37e42b99e206a": {
      "type": "Yfilerename",
      "commitMessage": "[FLINK-3303] [core] Move all type utilities to flink-core\n",
      "commitDate": "2016/2/2 下午11:55",
      "commitName": "21a715867d655bb61df9a9f7eef37e42b99e206a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2016/2/2 下午11:55",
      "commitNameOld": "7081836e0d640ee640687606bd73b6673d3f2a07",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (isNull) {\n                    fields[i].set(target, null);\n                } else {\n                    Object field \u003d fieldSerializers[i].deserialize(source);\n                    fields[i].set(target, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 391,
      "functionName": "deserialize",
      "functionAnnotation": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java"
      }
    },
    "6ba5fcdf85f802748fd47218ce8c41a617d224c9": {
      "type": "Yannotationchange",
      "commitMessage": "[core] [java api] Various code cleanup and fixed for warnings.\n",
      "commitDate": "2015/2/17 上午3:39",
      "commitName": "6ba5fcdf85f802748fd47218ce8c41a617d224c9",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015/2/10 下午8:15",
      "commitNameOld": "7407076d3990752eb5fa4072cd036efd2f656cbc",
      "commitAuthorOld": "Aljoscha Krettek",
      "daysBetweenCommits": 6.31,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\n@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (isNull) {\n                    fields[i].set(target, null);\n                } else {\n                    Object field \u003d fieldSerializers[i].deserialize(source);\n                    fields[i].set(target, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 382,
      "functionName": "deserialize",
      "functionAnnotation": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n+@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n public T deserialize(DataInputView source) throws IOException {\n     int flags \u003d source.readByte();\n     if ((flags \u0026 IS_NULL) !\u003d 0) {\n         return null;\n     }\n     T target;\n     Class\u003c?\u003e actualSubclass \u003d null;\n     TypeSerializer subclassSerializer \u003d null;\n     if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n         String subclassName \u003d source.readUTF();\n         try {\n             actualSubclass \u003d Class.forName(subclassName, true, cl);\n         } catch (ClassNotFoundException e) {\n             throw new RuntimeException(\"Cannot instantiate class.\", e);\n         }\n         subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n         int subclassTag \u003d source.readByte();\n         subclassSerializer \u003d registeredSerializers[subclassTag];\n         target \u003d (T) subclassSerializer.createInstance();\n         initializeFields(target);\n     } else {\n         target \u003d createInstance();\n     }\n     if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n         try {\n             for (int i \u003d 0; i \u003c numFields; i++) {\n                 boolean isNull \u003d source.readBoolean();\n                 if (isNull) {\n                     fields[i].set(target, null);\n                 } else {\n                     Object field \u003d fieldSerializers[i].deserialize(source);\n                     fields[i].set(target, field);\n                 }\n             }\n         } catch (IllegalAccessException e) {\n             throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n         }\n     } else {\n         if (subclassSerializer !\u003d null) {\n             target \u003d (T) subclassSerializer.deserialize(target, source);\n         }\n     }\n     return target;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "@Override,@SuppressWarnings(\"unchecked\")",
        "newValue": "@Override,@SuppressWarnings({ \"unchecked\", \"rawtypes\" })"
      }
    },
    "7407076d3990752eb5fa4072cd036efd2f656cbc": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "[FLINK-1369] [types] Add support for Subclasses, Interfaces, Abstract Classes.\n\n- Abstract classes with fields are handled as POJO types.\n- Interfaces and abstract classes without fields are handled as generic types.\n\nThis closes #236\nThis closes #316\n",
      "commitDate": "2015/2/10 下午8:15",
      "commitName": "7407076d3990752eb5fa4072cd036efd2f656cbc",
      "commitAuthor": "Aljoscha Krettek",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-1369] [types] Add support for Subclasses, Interfaces, Abstract Classes.\n\n- Abstract classes with fields are handled as POJO types.\n- Interfaces and abstract classes without fields are handled as generic types.\n\nThis closes #236\nThis closes #316\n",
          "commitDate": "2015/2/10 下午8:15",
          "commitName": "7407076d3990752eb5fa4072cd036efd2f656cbc",
          "commitAuthor": "Aljoscha Krettek",
          "commitDateOld": "2015/2/9 下午8:19",
          "commitNameOld": "7bc78cbf97d341ebfed32fdfe20f21e4d146a869",
          "commitAuthorOld": "Aljoscha Krettek",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (isNull) {\n                    fields[i].set(target, null);\n                } else {\n                    Object field \u003d fieldSerializers[i].deserialize(source);\n                    fields[i].set(target, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
          "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
          "functionStartLine": 382,
          "functionName": "deserialize",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,49 @@\n @Override\n+@SuppressWarnings(\"unchecked\")\n public T deserialize(DataInputView source) throws IOException {\n-    boolean isNull \u003d source.readBoolean();\n-    if (isNull) {\n+    int flags \u003d source.readByte();\n+    if ((flags \u0026 IS_NULL) !\u003d 0) {\n         return null;\n     }\n     T target;\n-    try {\n-        target \u003d clazz.newInstance();\n-    } catch (Throwable t) {\n-        throw new RuntimeException(\"Cannot instantiate class.\", t);\n-    }\n-    try {\n-        for (int i \u003d 0; i \u003c numFields; i++) {\n-            isNull \u003d source.readBoolean();\n-            if (isNull) {\n-                fields[i].set(target, null);\n-            } else {\n-                Object field \u003d fieldSerializers[i].deserialize(source);\n-                fields[i].set(target, field);\n-            }\n+    Class\u003c?\u003e actualSubclass \u003d null;\n+    TypeSerializer subclassSerializer \u003d null;\n+    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n+        String subclassName \u003d source.readUTF();\n+        try {\n+            actualSubclass \u003d Class.forName(subclassName, true, cl);\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Cannot instantiate class.\", e);\n         }\n-    } catch (IllegalAccessException e) {\n-        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n+        target \u003d (T) subclassSerializer.createInstance();\n+        initializeFields(target);\n+    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n+        int subclassTag \u003d source.readByte();\n+        subclassSerializer \u003d registeredSerializers[subclassTag];\n+        target \u003d (T) subclassSerializer.createInstance();\n+        initializeFields(target);\n+    } else {\n+        target \u003d createInstance();\n+    }\n+    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n+        try {\n+            for (int i \u003d 0; i \u003c numFields; i++) {\n+                boolean isNull \u003d source.readBoolean();\n+                if (isNull) {\n+                    fields[i].set(target, null);\n+                } else {\n+                    Object field \u003d fieldSerializers[i].deserialize(source);\n+                    fields[i].set(target, field);\n+                }\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+        }\n+    } else {\n+        if (subclassSerializer !\u003d null) {\n+            target \u003d (T) subclassSerializer.deserialize(target, source);\n+        }\n     }\n     return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "[FLINK-1369] [types] Add support for Subclasses, Interfaces, Abstract Classes.\n\n- Abstract classes with fields are handled as POJO types.\n- Interfaces and abstract classes without fields are handled as generic types.\n\nThis closes #236\nThis closes #316\n",
          "commitDate": "2015/2/10 下午8:15",
          "commitName": "7407076d3990752eb5fa4072cd036efd2f656cbc",
          "commitAuthor": "Aljoscha Krettek",
          "commitDateOld": "2015/2/9 下午8:19",
          "commitNameOld": "7bc78cbf97d341ebfed32fdfe20f21e4d146a869",
          "commitAuthorOld": "Aljoscha Krettek",
          "daysBetweenCommits": 1.0,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\n@SuppressWarnings(\"unchecked\")\npublic T deserialize(DataInputView source) throws IOException {\n    int flags \u003d source.readByte();\n    if ((flags \u0026 IS_NULL) !\u003d 0) {\n        return null;\n    }\n    T target;\n    Class\u003c?\u003e actualSubclass \u003d null;\n    TypeSerializer subclassSerializer \u003d null;\n    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n        String subclassName \u003d source.readUTF();\n        try {\n            actualSubclass \u003d Class.forName(subclassName, true, cl);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(\"Cannot instantiate class.\", e);\n        }\n        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n        int subclassTag \u003d source.readByte();\n        subclassSerializer \u003d registeredSerializers[subclassTag];\n        target \u003d (T) subclassSerializer.createInstance();\n        initializeFields(target);\n    } else {\n        target \u003d createInstance();\n    }\n    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n        try {\n            for (int i \u003d 0; i \u003c numFields; i++) {\n                boolean isNull \u003d source.readBoolean();\n                if (isNull) {\n                    fields[i].set(target, null);\n                } else {\n                    Object field \u003d fieldSerializers[i].deserialize(source);\n                    fields[i].set(target, field);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n        }\n    } else {\n        if (subclassSerializer !\u003d null) {\n            target \u003d (T) subclassSerializer.deserialize(target, source);\n        }\n    }\n    return target;\n}",
          "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
          "functionStartLine": 382,
          "functionName": "deserialize",
          "functionAnnotation": "@Override,@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,27 +1,49 @@\n @Override\n+@SuppressWarnings(\"unchecked\")\n public T deserialize(DataInputView source) throws IOException {\n-    boolean isNull \u003d source.readBoolean();\n-    if (isNull) {\n+    int flags \u003d source.readByte();\n+    if ((flags \u0026 IS_NULL) !\u003d 0) {\n         return null;\n     }\n     T target;\n-    try {\n-        target \u003d clazz.newInstance();\n-    } catch (Throwable t) {\n-        throw new RuntimeException(\"Cannot instantiate class.\", t);\n-    }\n-    try {\n-        for (int i \u003d 0; i \u003c numFields; i++) {\n-            isNull \u003d source.readBoolean();\n-            if (isNull) {\n-                fields[i].set(target, null);\n-            } else {\n-                Object field \u003d fieldSerializers[i].deserialize(source);\n-                fields[i].set(target, field);\n-            }\n+    Class\u003c?\u003e actualSubclass \u003d null;\n+    TypeSerializer subclassSerializer \u003d null;\n+    if ((flags \u0026 IS_SUBCLASS) !\u003d 0) {\n+        String subclassName \u003d source.readUTF();\n+        try {\n+            actualSubclass \u003d Class.forName(subclassName, true, cl);\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Cannot instantiate class.\", e);\n         }\n-    } catch (IllegalAccessException e) {\n-        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+        subclassSerializer \u003d getSubclassSerializer(actualSubclass);\n+        target \u003d (T) subclassSerializer.createInstance();\n+        initializeFields(target);\n+    } else if ((flags \u0026 IS_TAGGED_SUBCLASS) !\u003d 0) {\n+        int subclassTag \u003d source.readByte();\n+        subclassSerializer \u003d registeredSerializers[subclassTag];\n+        target \u003d (T) subclassSerializer.createInstance();\n+        initializeFields(target);\n+    } else {\n+        target \u003d createInstance();\n+    }\n+    if ((flags \u0026 NO_SUBCLASS) !\u003d 0) {\n+        try {\n+            for (int i \u003d 0; i \u003c numFields; i++) {\n+                boolean isNull \u003d source.readBoolean();\n+                if (isNull) {\n+                    fields[i].set(target, null);\n+                } else {\n+                    Object field \u003d fieldSerializers[i].deserialize(source);\n+                    fields[i].set(target, field);\n+                }\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+        }\n+    } else {\n+        if (subclassSerializer !\u003d null) {\n+            target \u003d (T) subclassSerializer.deserialize(target, source);\n+        }\n     }\n     return target;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Override",
            "newValue": "@Override,@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "926f835adb9cb77bcda19e4ed009cc07c89cea74": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1032] Rework support for POJO types in the Java API\n",
      "commitDate": "2014/10/8 下午5:39",
      "commitName": "926f835adb9cb77bcda19e4ed009cc07c89cea74",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014/9/30 下午9:10",
      "commitNameOld": "76d4a75e823c31a899f2143fb6be185b90e55532",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 7.85,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic T deserialize(DataInputView source) throws IOException {\n    boolean isNull \u003d source.readBoolean();\n    if (isNull) {\n        return null;\n    }\n    T target;\n    try {\n        target \u003d clazz.newInstance();\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\n    }\n    try {\n        for (int i \u003d 0; i \u003c numFields; i++) {\n            isNull \u003d source.readBoolean();\n            if (isNull) {\n                fields[i].set(target, null);\n            } else {\n                Object field \u003d fieldSerializers[i].deserialize(source);\n                fields[i].set(target, field);\n            }\n        }\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n    }\n    return target;\n}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 201,
      "functionName": "deserialize",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,27 @@\n @Override\n public T deserialize(DataInputView source) throws IOException {\n+    boolean isNull \u003d source.readBoolean();\n+    if (isNull) {\n+        return null;\n+    }\n     T target;\n     try {\n         target \u003d clazz.newInstance();\n     } catch (Throwable t) {\n         throw new RuntimeException(\"Cannot instantiate class.\", t);\n     }\n     try {\n         for (int i \u003d 0; i \u003c numFields; i++) {\n-            Object field \u003d fieldSerializers[i].deserialize(source);\n-            fields[i].set(target, field);\n+            isNull \u003d source.readBoolean();\n+            if (isNull) {\n+                fields[i].set(target, null);\n+            } else {\n+                Object field \u003d fieldSerializers[i].deserialize(source);\n+                fields[i].set(target, field);\n+            }\n         }\n     } catch (IllegalAccessException e) {\n         throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n     }\n     return target;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76d4a75e823c31a899f2143fb6be185b90e55532": {
      "type": "Yintroduced",
      "commitMessage": "[FLINK-1005] Extend TypeSerializer interface to handle non-mutable object deserialization more efficiently.\n",
      "commitDate": "2014/9/30 下午9:10",
      "commitName": "76d4a75e823c31a899f2143fb6be185b90e55532",
      "commitAuthor": "Stephan Ewen",
      "diff": "@@ -0,0 +1,18 @@\n+@Override\n+public T deserialize(DataInputView source) throws IOException {\n+    T target;\n+    try {\n+        target \u003d clazz.newInstance();\n+    } catch (Throwable t) {\n+        throw new RuntimeException(\"Cannot instantiate class.\", t);\n+    }\n+    try {\n+        for (int i \u003d 0; i \u003c numFields; i++) {\n+            Object field \u003d fieldSerializers[i].deserialize(source);\n+            fields[i].set(target, field);\n+        }\n+    } catch (IllegalAccessException e) {\n+        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n+    }\n+    return target;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic T deserialize(DataInputView source) throws IOException {\n    T target;\n    try {\n        target \u003d clazz.newInstance();\n    } catch (Throwable t) {\n        throw new RuntimeException(\"Cannot instantiate class.\", t);\n    }\n    try {\n        for (int i \u003d 0; i \u003c numFields; i++) {\n            Object field \u003d fieldSerializers[i].deserialize(source);\n            fields[i].set(target, field);\n        }\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(\"Error during POJO copy, this should not happen since we check the fields\" + \"before.\");\n    }\n    return target;\n}",
      "path": "flink-java/src/main/java/org/apache/flink/api/java/typeutils/runtime/PojoSerializer.java",
      "functionStartLine": 190,
      "functionName": "deserialize",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}