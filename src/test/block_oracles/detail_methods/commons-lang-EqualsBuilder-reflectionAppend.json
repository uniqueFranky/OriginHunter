{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "EqualsBuilder.java",
  "functionName": "reflectionAppend",
  "functionId": "reflectionAppend___lhs-Object(modifiers-final)__rhs-Object(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n\u003cp\u003eIf either class of the compared objects is contained in\n\u003ccode\u003ebypassReflectionClasses\u003c/code\u003e, both objects are compared by calling\nthe equals method of the left hand object with the right hand object as an argument.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
  "functionStartLine": 491,
  "functionEndLine": 554,
  "numCommitsSeen": 196,
  "timeTaken": 3117,
  "changeHistory": [
    "2e9f3a80146262511ca7bcdd3411f095dff4951d",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4",
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "aeb6f86bcdec061ee9c6be96066fa19c56523490",
    "9072a7615a54d5e753cf088326d9e14f1a5a6751",
    "f525bc3ccd9cfb69603bd9778998263a458415d0",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "1a60c21395fe7648188d1c91f62ac7baefa12742",
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "ca3a3baa651465310d31824250318bd500fa9e8b",
    "654fb75d80a63fa551ced73c3b652f4120573590",
    "8393f10b791c4fd28a1031f0a6427a2c9af04977",
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5",
    "eadb45d1a7b8b16164171c7caa171fd9f911a414",
    "984bc76cd36138514e8c3c2cd494cd952d22dd13",
    "5c40090fecdacd9366bba7e3e29d94f213cf2633"
  ],
  "changeHistoryShort": {
    "2e9f3a80146262511ca7bcdd3411f095dff4951d": "Ymultichange(Ybodychange,Ydocchange)",
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": "Ydocchange",
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4": "Ybodychange",
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange,Ydocchange)",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "aeb6f86bcdec061ee9c6be96066fa19c56523490": "Ybodychange",
    "9072a7615a54d5e753cf088326d9e14f1a5a6751": "Ybodychange",
    "f525bc3ccd9cfb69603bd9778998263a458415d0": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "1a60c21395fe7648188d1c91f62ac7baefa12742": "Ybodychange",
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "ca3a3baa651465310d31824250318bd500fa9e8b": "Ybodychange",
    "654fb75d80a63fa551ced73c3b652f4120573590": "Yparameterchange",
    "8393f10b791c4fd28a1031f0a6427a2c9af04977": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5": "Ybodychange",
    "eadb45d1a7b8b16164171c7caa171fd9f911a414": "Ydocchange",
    "984bc76cd36138514e8c3c2cd494cd952d22dd13": "Ybodychange",
    "5c40090fecdacd9366bba7e3e29d94f213cf2633": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2e9f3a80146262511ca7bcdd3411f095dff4951d": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-1356: Add bypass option for classes to recursive and reflective EqualsBuilder\n\nPatch supplied by Yathos UG\n",
      "commitDate": "2018/2/12 上午3:43",
      "commitName": "2e9f3a80146262511ca7bcdd3411f095dff4951d",
      "commitAuthor": "pascalschumacher",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1356: Add bypass option for classes to recursive and reflective EqualsBuilder\n\nPatch supplied by Yathos UG\n",
          "commitDate": "2018/2/12 上午3:43",
          "commitName": "2e9f3a80146262511ca7bcdd3411f095dff4951d",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2017/9/9 上午12:19",
          "commitNameOld": "3e08af573f8b50da5202f55df62c925f88a47f3d",
          "commitAuthorOld": "namannigam",
          "daysBetweenCommits": 156.14,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            if (bypassReflectionClasses !\u003d null \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n                isEquals \u003d lhs.equals(rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 491,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n\u003cp\u003eIf either class of the compared objects is contained in\n\u003ccode\u003ebypassReflectionClasses\u003c/code\u003e, both objects are compared by calling\nthe equals method of the left hand object with the right hand object as an argument.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,44 +1,48 @@\n public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n     if (!isEquals) {\n         return this;\n     }\n     if (lhs \u003d\u003d rhs) {\n         return this;\n     }\n     if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n         isEquals \u003d false;\n         return this;\n     }\n     final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n     final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n     Class\u003c?\u003e testClass;\n     if (lhsClass.isInstance(rhs)) {\n         testClass \u003d lhsClass;\n         if (!rhsClass.isInstance(lhs)) {\n             testClass \u003d rhsClass;\n         }\n     } else if (rhsClass.isInstance(lhs)) {\n         testClass \u003d rhsClass;\n         if (!lhsClass.isInstance(rhs)) {\n             testClass \u003d lhsClass;\n         }\n     } else {\n         isEquals \u003d false;\n         return this;\n     }\n     try {\n         if (testClass.isArray()) {\n             append(lhs, rhs);\n         } else {\n-            reflectionAppend(lhs, rhs, testClass);\n-            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n-                testClass \u003d testClass.getSuperclass();\n+            if (bypassReflectionClasses !\u003d null \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n+                isEquals \u003d lhs.equals(rhs);\n+            } else {\n                 reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n+                }\n             }\n         }\n     } catch (final IllegalArgumentException e) {\n         isEquals \u003d false;\n         return this;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-1356: Add bypass option for classes to recursive and reflective EqualsBuilder\n\nPatch supplied by Yathos UG\n",
          "commitDate": "2018/2/12 上午3:43",
          "commitName": "2e9f3a80146262511ca7bcdd3411f095dff4951d",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2017/9/9 上午12:19",
          "commitNameOld": "3e08af573f8b50da5202f55df62c925f88a47f3d",
          "commitAuthorOld": "namannigam",
          "daysBetweenCommits": 156.14,
          "commitsBetweenForRepo": 125,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            if (bypassReflectionClasses !\u003d null \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n                isEquals \u003d lhs.equals(rhs);\n            } else {\n                reflectionAppend(lhs, rhs, testClass);\n                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                    testClass \u003d testClass.getSuperclass();\n                    reflectionAppend(lhs, rhs, testClass);\n                }\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 491,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n\u003cp\u003eIf either class of the compared objects is contained in\n\u003ccode\u003ebypassReflectionClasses\u003c/code\u003e, both objects are compared by calling\nthe equals method of the left hand object with the right hand object as an argument.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,44 +1,48 @@\n public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n     if (!isEquals) {\n         return this;\n     }\n     if (lhs \u003d\u003d rhs) {\n         return this;\n     }\n     if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n         isEquals \u003d false;\n         return this;\n     }\n     final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n     final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n     Class\u003c?\u003e testClass;\n     if (lhsClass.isInstance(rhs)) {\n         testClass \u003d lhsClass;\n         if (!rhsClass.isInstance(lhs)) {\n             testClass \u003d rhsClass;\n         }\n     } else if (rhsClass.isInstance(lhs)) {\n         testClass \u003d rhsClass;\n         if (!lhsClass.isInstance(rhs)) {\n             testClass \u003d lhsClass;\n         }\n     } else {\n         isEquals \u003d false;\n         return this;\n     }\n     try {\n         if (testClass.isArray()) {\n             append(lhs, rhs);\n         } else {\n-            reflectionAppend(lhs, rhs, testClass);\n-            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n-                testClass \u003d testClass.getSuperclass();\n+            if (bypassReflectionClasses !\u003d null \u0026\u0026 (bypassReflectionClasses.contains(lhsClass) || bypassReflectionClasses.contains(rhsClass))) {\n+                isEquals \u003d lhs.equals(rhs);\n+            } else {\n                 reflectionAppend(lhs, rhs, testClass);\n+                while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                    testClass \u003d testClass.getSuperclass();\n+                    reflectionAppend(lhs, rhs, testClass);\n+                }\n             }\n         }\n     } catch (final IllegalArgumentException e) {\n         isEquals \u003d false;\n         return this;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
            "newValue": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n\u003cp\u003eIf either class of the compared objects is contained in\n\u003ccode\u003ebypassReflectionClasses\u003c/code\u003e, both objects are compared by calling\nthe equals method of the left hand object with the right hand object as an argument.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n"
          }
        }
      ]
    },
    "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec": {
      "type": "Ydocchange",
      "commitMessage": "Make sure lines in files don\u0027t have trailing white spaces and remove all trailing white spaces\n",
      "commitDate": "2017/6/6 下午9:12",
      "commitName": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016/12/12 下午11:25",
      "commitNameOld": "f13d18cff3f0932e727dda04bf80008fc2fbbc70",
      "commitAuthorOld": "duncan",
      "daysBetweenCommits": 175.91,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 465,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
        "newValue": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using\n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n"
      }
    },
    "0f6a292a29fedd49741310cd517ac4ba907bf8d4": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1034: Add support for recursive comparison to EqualsBuilder#reflectionEquals (closes #202)\n\nminimal clean-ups: remove getter methods, improve javadoc, add unit test for reflectionAppend\n",
      "commitDate": "2016/11/14 上午1:47",
      "commitName": "0f6a292a29fedd49741310cd517ac4ba907bf8d4",
      "commitAuthor": "pascalschumacher",
      "commitDateOld": "2016/11/14 上午1:47",
      "commitNameOld": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 465,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
      "diff": "@@ -1,43 +1,44 @@\n public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n-    if (!isEquals)\n+    if (!isEquals) {\n         return this;\n+    }\n     if (lhs \u003d\u003d rhs) {\n         return this;\n     }\n     if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n         isEquals \u003d false;\n         return this;\n     }\n     final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n     final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n     Class\u003c?\u003e testClass;\n     if (lhsClass.isInstance(rhs)) {\n         testClass \u003d lhsClass;\n         if (!rhsClass.isInstance(lhs)) {\n             testClass \u003d rhsClass;\n         }\n     } else if (rhsClass.isInstance(lhs)) {\n         testClass \u003d rhsClass;\n         if (!lhsClass.isInstance(rhs)) {\n             testClass \u003d lhsClass;\n         }\n     } else {\n         isEquals \u003d false;\n         return this;\n     }\n     try {\n         if (testClass.isArray()) {\n             append(lhs, rhs);\n         } else {\n             reflectionAppend(lhs, rhs, testClass);\n             while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                 testClass \u003d testClass.getSuperclass();\n                 reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n     } catch (final IllegalArgumentException e) {\n         isEquals \u003d false;\n         return this;\n     }\n     return this;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0095d8adf26b9469115b1be0358cb09d1fcb5fd4": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
      "commitDate": "2016/11/14 上午1:47",
      "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
      "commitAuthor": "pascalschumacher",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016/11/14 上午1:47",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:55",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals)\n        return this;\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,22 +1,43 @@\n-private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-    if (isRegistered(lhs, rhs)) {\n-        return;\n+public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+    if (!isEquals)\n+        return this;\n+    if (lhs \u003d\u003d rhs) {\n+        return this;\n+    }\n+    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+        isEquals \u003d false;\n+        return this;\n+    }\n+    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+    Class\u003c?\u003e testClass;\n+    if (lhsClass.isInstance(rhs)) {\n+        testClass \u003d lhsClass;\n+        if (!rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+        }\n+    } else if (rhsClass.isInstance(lhs)) {\n+        testClass \u003d rhsClass;\n+        if (!lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+        }\n+    } else {\n+        isEquals \u003d false;\n+        return this;\n     }\n     try {\n-        register(lhs, rhs);\n-        final Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (final IllegalAccessException e) {\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n+        if (testClass.isArray()) {\n+            append(lhs, rhs);\n+        } else {\n+            reflectionAppend(lhs, rhs, testClass);\n+            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                testClass \u003d testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n-    } finally {\n-        unregister(lhs, rhs);\n+    } catch (final IllegalArgumentException e) {\n+        isEquals \u003d false;\n+        return this;\n     }\n+    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class\u003c?\u003e(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]",
            "newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final)]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016/11/14 上午1:47",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:55",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals)\n        return this;\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,22 +1,43 @@\n-private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-    if (isRegistered(lhs, rhs)) {\n-        return;\n+public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+    if (!isEquals)\n+        return this;\n+    if (lhs \u003d\u003d rhs) {\n+        return this;\n+    }\n+    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+        isEquals \u003d false;\n+        return this;\n+    }\n+    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+    Class\u003c?\u003e testClass;\n+    if (lhsClass.isInstance(rhs)) {\n+        testClass \u003d lhsClass;\n+        if (!rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+        }\n+    } else if (rhsClass.isInstance(lhs)) {\n+        testClass \u003d rhsClass;\n+        if (!lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+        }\n+    } else {\n+        isEquals \u003d false;\n+        return this;\n     }\n     try {\n-        register(lhs, rhs);\n-        final Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (final IllegalAccessException e) {\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n+        if (testClass.isArray()) {\n+            append(lhs, rhs);\n+        } else {\n+            reflectionAppend(lhs, rhs, testClass);\n+            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                testClass \u003d testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n-    } finally {\n-        unregister(lhs, rhs);\n+    } catch (final IllegalArgumentException e) {\n+        isEquals \u003d false;\n+        return this;\n     }\n+    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "EqualsBuilder"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016/11/14 上午1:47",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:55",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals)\n        return this;\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,22 +1,43 @@\n-private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-    if (isRegistered(lhs, rhs)) {\n-        return;\n+public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+    if (!isEquals)\n+        return this;\n+    if (lhs \u003d\u003d rhs) {\n+        return this;\n+    }\n+    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+        isEquals \u003d false;\n+        return this;\n+    }\n+    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+    Class\u003c?\u003e testClass;\n+    if (lhsClass.isInstance(rhs)) {\n+        testClass \u003d lhsClass;\n+        if (!rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+        }\n+    } else if (rhsClass.isInstance(lhs)) {\n+        testClass \u003d rhsClass;\n+        if (!lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+        }\n+    } else {\n+        isEquals \u003d false;\n+        return this;\n     }\n     try {\n-        register(lhs, rhs);\n-        final Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (final IllegalAccessException e) {\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n+        if (testClass.isArray()) {\n+            append(lhs, rhs);\n+        } else {\n+            reflectionAppend(lhs, rhs, testClass);\n+            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                testClass \u003d testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n-    } finally {\n-        unregister(lhs, rhs);\n+    } catch (final IllegalArgumentException e) {\n+        isEquals \u003d false;\n+        return this;\n     }\n+    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016/11/14 上午1:47",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:55",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals)\n        return this;\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,22 +1,43 @@\n-private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-    if (isRegistered(lhs, rhs)) {\n-        return;\n+public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+    if (!isEquals)\n+        return this;\n+    if (lhs \u003d\u003d rhs) {\n+        return this;\n+    }\n+    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+        isEquals \u003d false;\n+        return this;\n+    }\n+    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+    Class\u003c?\u003e testClass;\n+    if (lhsClass.isInstance(rhs)) {\n+        testClass \u003d lhsClass;\n+        if (!rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+        }\n+    } else if (rhsClass.isInstance(lhs)) {\n+        testClass \u003d rhsClass;\n+        if (!lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+        }\n+    } else {\n+        isEquals \u003d false;\n+        return this;\n     }\n     try {\n-        register(lhs, rhs);\n-        final Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (final IllegalAccessException e) {\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n+        if (testClass.isArray()) {\n+            append(lhs, rhs);\n+        } else {\n+            reflectionAppend(lhs, rhs, testClass);\n+            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                testClass \u003d testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n-    } finally {\n-        unregister(lhs, rhs);\n+    } catch (final IllegalArgumentException e) {\n+        isEquals \u003d false;\n+        return this;\n     }\n+    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-1034: Recursive and reflective EqualsBuilder (closes #202)\n\npatch by yathos UG\n",
          "commitDate": "2016/11/14 上午1:47",
          "commitName": "0095d8adf26b9469115b1be0358cb09d1fcb5fd4",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:55",
          "commitNameOld": "eb2b89efbe15ab0b70fd94f0ecd0aa03866fb4d2",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 20.99,
          "commitsBetweenForRepo": 30,
          "commitsBetweenForFile": 1,
          "actualSource": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals)\n        return this;\n    if (lhs \u003d\u003d rhs) {\n        return this;\n    }\n    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n        isEquals \u003d false;\n        return this;\n    }\n    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n    Class\u003c?\u003e testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass \u003d lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass \u003d rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass \u003d rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass \u003d lhsClass;\n        }\n    } else {\n        isEquals \u003d false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n                testClass \u003d testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals \u003d false;\n        return this;\n    }\n    return this;\n}",
          "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
          "functionStartLine": 502,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n",
          "diff": "@@ -1,22 +1,43 @@\n-private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n-    if (isRegistered(lhs, rhs)) {\n-        return;\n+public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n+    if (!isEquals)\n+        return this;\n+    if (lhs \u003d\u003d rhs) {\n+        return this;\n+    }\n+    if (lhs \u003d\u003d null || rhs \u003d\u003d null) {\n+        isEquals \u003d false;\n+        return this;\n+    }\n+    final Class\u003c?\u003e lhsClass \u003d lhs.getClass();\n+    final Class\u003c?\u003e rhsClass \u003d rhs.getClass();\n+    Class\u003c?\u003e testClass;\n+    if (lhsClass.isInstance(rhs)) {\n+        testClass \u003d lhsClass;\n+        if (!rhsClass.isInstance(lhs)) {\n+            testClass \u003d rhsClass;\n+        }\n+    } else if (rhsClass.isInstance(lhs)) {\n+        testClass \u003d rhsClass;\n+        if (!lhsClass.isInstance(rhs)) {\n+            testClass \u003d lhsClass;\n+        }\n+    } else {\n+        isEquals \u003d false;\n+        return this;\n     }\n     try {\n-        register(lhs, rhs);\n-        final Field[] fields \u003d clazz.getDeclaredFields();\n-        AccessibleObject.setAccessible(fields, true);\n-        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (final IllegalAccessException e) {\n-                    throw new InternalError(\"Unexpected IllegalAccessException\");\n-                }\n+        if (testClass.isArray()) {\n+            append(lhs, rhs);\n+        } else {\n+            reflectionAppend(lhs, rhs, testClass);\n+            while (testClass.getSuperclass() !\u003d null \u0026\u0026 testClass !\u003d reflectUpToClass) {\n+                testClass \u003d testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass);\n             }\n         }\n-    } finally {\n-        unregister(lhs, rhs);\n+    } catch (final IllegalArgumentException e) {\n+        isEquals \u003d false;\n+        return this;\n     }\n+    return this;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
            "newValue": "\u003cp\u003eTests if two \u003ccode\u003eobjects\u003c/code\u003e by using reflection.\u003c/p\u003e\n\n\u003cp\u003eIt uses \u003ccode\u003eAccessibleObject.setAccessible\u003c/code\u003e to gain access to private\nfields. This means that it will throw a security exception if run under\na security manager, if the permissions are not set up correctly. It is also\nnot as efficient as testing explicitly. Non-primitive fields are compared using \n\u003ccode\u003eequals()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the testTransients field is set to \u003ccode\u003etrue\u003c/code\u003e, transient\nmembers will be tested, otherwise they are ignored, as they are likely\nderived fields, and not part of the value of the \u003ccode\u003eObject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eStatic fields will not be included. Superclass fields will be appended\nup to and including the specified superclass in field \u003ccode\u003ereflectUpToClass\u003c/code\u003e.\nA null superclass is treated as java.lang.Object.\u003c/p\u003e\n\n\u003cp\u003eField names listed in field \u003ccode\u003eexcludeFields\u003c/code\u003e will be ignored.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the left hand object\n@return EqualsBuilder - used to chain calls.\n"
          }
        }
      ]
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016/9/19 下午7:56",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016/8/22 上午1:14",
      "commitNameOld": "b2c1afce7eb13ea44fc7d25562cc3bb83cc91b2f",
      "commitAuthorOld": "Philippe Marschall",
      "daysBetweenCommits": 28.78,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            final Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 397,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n         final Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers())) \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n+            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers()) \u0026\u0026 !f.isAnnotationPresent(EqualsExclude.class)) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (final IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aeb6f86bcdec061ee9c6be96066fa19c56523490": {
      "type": "Ybodychange",
      "commitMessage": "EqualsExlcude notation, HashCodeExclude notation and ToStringExludeNotation\n",
      "commitDate": "2015/5/4 上午2:59",
      "commitName": "aeb6f86bcdec061ee9c6be96066fa19c56523490",
      "commitAuthor": "Felipe Adorno",
      "commitDateOld": "2015/4/7 上午3:44",
      "commitNameOld": "11491d355da8a851d6badb6348b10d8c4acc9d8e",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 26.97,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            final Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers())) \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n         final Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n+            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers())) \u0026\u0026 (!f.isAnnotationPresent(EqualsExclude.class))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (final IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9072a7615a54d5e753cf088326d9e14f1a5a6751": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Useless parentheses\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671669 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/4/7 上午3:41",
      "commitName": "9072a7615a54d5e753cf088326d9e14f1a5a6751",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2015/4/7 上午3:37",
      "commitNameOld": "f525bc3ccd9cfb69603bd9778998263a458415d0",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            final Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n         final Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (!f.getName().contains(\"$\")) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 !f.getName().contains(\"$\") \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 !Modifier.isStatic(f.getModifiers())) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (final IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f525bc3ccd9cfb69603bd9778998263a458415d0": {
      "type": "Ybodychange",
      "commitMessage": "Use not String.contains instead of indexOf \u003d\u003d -1\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1671666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/4/7 上午3:37",
      "commitName": "f525bc3ccd9cfb69603bd9778998263a458415d0",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014/9/10 下午7:32",
      "commitNameOld": "2154d5fbf8cc02cc4d51b63d6a532af06cccd0fc",
      "commitAuthorOld": "Duncan Jones",
      "daysBetweenCommits": 208.34,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            final Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (!f.getName().contains(\"$\")) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 393,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n         final Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             final Field f \u003d fields[i];\n-            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (!f.getName().contains(\"$\")) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (final IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        final Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            final Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (final IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 384,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n-        Field[] fields \u003d clazz.getDeclaredFields();\n+        final Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-            Field f \u003d fields[i];\n+            final Field f \u003d fields[i];\n             if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n+                } catch (final IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/4/6 上午1:53",
      "commitNameOld": "b819343483d33cc529b785935cea9bfc2fc080e5",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 291.55,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 384,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,22 +1,22 @@\n-private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n+private static void reflectionAppend(final Object lhs, final Object rhs, final Class\u003c?\u003e clazz, final EqualsBuilder builder, final boolean useTransients, final String[] excludeFields) {\n     if (isRegistered(lhs, rhs)) {\n         return;\n     }\n     try {\n         register(lhs, rhs);\n         Field[] fields \u003d clazz.getDeclaredFields();\n         AccessibleObject.setAccessible(fields, true);\n         for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n             Field f \u003d fields[i];\n             if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                 try {\n                     builder.append(f.get(lhs), f.get(rhs));\n                 } catch (IllegalAccessException e) {\n                     throw new InternalError(\"Unexpected IllegalAccessException\");\n                 }\n             }\n         }\n     } finally {\n         unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[lhs-Object, rhs-Object, clazz-Class\u003c?\u003e, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
        "newValue": "[lhs-Object(modifiers-final), rhs-Object(modifiers-final), clazz-Class\u003c?\u003e(modifiers-final), builder-EqualsBuilder(modifiers-final), useTransients-boolean(modifiers-final), excludeFields-String[](modifiers-final)]"
      }
    },
    "1a60c21395fe7648188d1c91f62ac7baefa12742": {
      "type": "Ybodychange",
      "commitMessage": "Applying the copy of the HashCodeBuilder code to stop cyclic references over to EqualsBuilder per LANG-606 and Oliver Sauder\u0027s patch\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@925671 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/3/21 上午4:16",
      "commitName": "1a60c21395fe7648188d1c91f62ac7baefa12742",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010/2/25 上午9:28",
      "commitNameOld": "43fca0d7499c99f9e82e0ee2e52b81acdc954f2c",
      "commitAuthorOld": "Niall Pemberton",
      "daysBetweenCommits": 23.78,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    if (isRegistered(lhs, rhs)) {\n        return;\n    }\n    try {\n        register(lhs, rhs);\n        Field[] fields \u003d clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n            Field f \u003d fields[i];\n            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                    throw new InternalError(\"Unexpected IllegalAccessException\");\n                }\n            }\n        }\n    } finally {\n        unregister(lhs, rhs);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 442,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,14 +1,22 @@\n private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n-    Field[] fields \u003d clazz.getDeclaredFields();\n-    AccessibleObject.setAccessible(fields, true);\n-    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n-        Field f \u003d fields[i];\n-        if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n-            try {\n-                builder.append(f.get(lhs), f.get(rhs));\n-            } catch (IllegalAccessException e) {\n-                throw new InternalError(\"Unexpected IllegalAccessException\");\n+    if (isRegistered(lhs, rhs)) {\n+        return;\n+    }\n+    try {\n+        register(lhs, rhs);\n+        Field[] fields \u003d clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n+            Field f \u003d fields[i];\n+            if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n             }\n         }\n+    } finally {\n+        unregister(lhs, rhs);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a": {
      "type": "Ybodychange",
      "commitMessage": "Replacing the creation of a List in the core of each Builder class to test contains on the excludeFields with a call to ArrayUtils.contains. Reported by Anthony Whitford in LANG-575\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@897421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/9 下午7:44",
      "commitName": "5494a87bbb6d6b6f0d176d0c93e4f25718ed3c2a",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010/1/3 上午10:11",
      "commitNameOld": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 6.4,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 315,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,15 +1,14 @@\n private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n-    List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n-        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+        if (!ArrayUtils.contains(excludeFields, f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
        "newPath": "src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
        "newPath": "src/java/org/apache/commons/lang3/builder/EqualsBuilder.java"
      }
    },
    "ca3a3baa651465310d31824250318bd500fa9e8b": {
      "type": "Ybodychange",
      "commitMessage": "Genericizing excludeFieldList variablle - LANG-336\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@772548 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/5/7 下午4:31",
      "commitName": "ca3a3baa651465310d31824250318bd500fa9e8b",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/3/16 上午11:35",
      "commitNameOld": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 52.21,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,15 +1,15 @@\n private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n-    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n+    List\u003cString\u003e excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.\u003cString\u003eemptyList();\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n         if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "654fb75d80a63fa551ced73c3b652f4120573590": {
      "type": "Yparameterchange",
      "commitMessage": "Genericize some more classes\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@754810 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/3/16 上午11:35",
      "commitName": "654fb75d80a63fa551ced73c3b652f4120573590",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2008/11/7 上午4:36",
      "commitNameOld": "b1e8a26177324ece7c786da8cd063076bc131ea1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 129.29,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 313,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
      "diff": "@@ -1,15 +1,15 @@\n-private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n+private static void reflectionAppend(Object lhs, Object rhs, Class\u003c?\u003e clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n     List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n         if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]",
        "newValue": "[lhs-Object, rhs-Object, clazz-Class\u003c?\u003e, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
      }
    },
    "8393f10b791c4fd28a1031f0a6427a2c9af04977": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Ydocchange)",
      "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2006/4/24 下午3:00",
      "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
      "commitAuthor": "Henri Yandell",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/4/24 下午3:00",
          "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2005/4/14 下午12:30",
          "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 375.1,
          "commitsBetweenForRepo": 266,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
          "functionStartLine": 289,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
          "diff": "@@ -1,14 +1,15 @@\n-private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n+    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n-        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean]",
            "newValue": "[lhs-Object, rhs-Object, clazz-Class, builder-EqualsBuilder, useTransients-boolean, excludeFields-String[]]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/4/24 下午3:00",
          "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2005/4/14 下午12:30",
          "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 375.1,
          "commitsBetweenForRepo": 266,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
          "functionStartLine": 289,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
          "diff": "@@ -1,14 +1,15 @@\n-private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n+    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n-        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Adding new excludeFields functionality for EqualsBuilder and HashCodeBuilder, as submitted by Pete Gieser, Bugzilla: #39315\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@396461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2006/4/24 下午3:00",
          "commitName": "8393f10b791c4fd28a1031f0a6427a2c9af04977",
          "commitAuthor": "Henri Yandell",
          "commitDateOld": "2005/4/14 下午12:30",
          "commitNameOld": "4f69e5183a56d6a38a76ebafcb12637c0ecb8f4c",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 375.1,
          "commitsBetweenForRepo": 266,
          "commitsBetweenForFile": 1,
          "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
          "functionStartLine": 289,
          "functionName": "reflectionAppend",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n",
          "diff": "@@ -1,14 +1,15 @@\n-private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients, String[] excludeFields) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n+    List excludedFieldList \u003d excludeFields !\u003d null ? Arrays.asList(excludeFields) : Collections.EMPTY_LIST;\n     AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n-        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+        if (!excludedFieldList.contains(f.getName()) \u0026\u0026 (f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n",
            "newValue": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n@param excludeFields array of field names to exclude from testing\n"
          }
        }
      ]
    },
    "d27569f61a49489dd72e4b8a1ed4b0648008b3d5": {
      "type": "Ybodychange",
      "commitMessage": "Severity\tDescription\tResource\tIn Folder\tLocation\tCreation Time\n\tThe static method setAccessible(AccessibleObject[], boolean) from the type AccessibleObject should be accessed directly \tEqualsBuilder.java\tApache Jakarta Commons/lang/src/java/org/apache/commons/lang/builder\tline 268\tJuly 19, 2003 6:10:35 PM\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137465 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/20 上午9:11",
      "commitName": "d27569f61a49489dd72e4b8a1ed4b0648008b3d5",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2003/7/15 上午6:25",
      "commitNameOld": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 5.12,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    AccessibleObject.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 261,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n",
      "diff": "@@ -1,14 +1,14 @@\n private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n-    Field.setAccessible(fields, true);\n+    AccessibleObject.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n         if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n             try {\n                 builder.append(f.get(lhs), f.get(rhs));\n             } catch (IllegalAccessException e) {\n                 throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eadb45d1a7b8b16164171c7caa171fd9f911a414": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc fixes. Shouldn\u0027t have been anything other than javadoc changes in this.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137416 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/7/15 上午6:25",
      "commitName": "eadb45d1a7b8b16164171c7caa171fd9f911a414",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2003/4/18 下午5:12",
      "commitNameOld": "8ba5fec31d83b9f9df973537f7b3a788e3fcc987",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 87.55,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    Field.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 260,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Appends the fields and values defined by the given object of the\ngiven Class.\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n",
        "newValue": "\u003cp\u003eAppends the fields and values defined by the given object of the\ngiven Class.\u003c/p\u003e\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n"
      }
    },
    "984bc76cd36138514e8c3c2cd494cd952d22dd13": {
      "type": "Ybodychange",
      "commitMessage": "Fix infinite recursion in inner classes reflection methods\nfrom Per Velschow\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137232 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/1/20 上午2:49",
      "commitName": "984bc76cd36138514e8c3c2cd494cd952d22dd13",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2003/1/20 上午1:35",
      "commitNameOld": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    Field.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n            try {\n                builder.append(f.get(lhs), f.get(rhs));\n            } catch (IllegalAccessException e) {\n                throw new InternalError(\"Unexpected IllegalAccessException\");\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 256,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "Appends the fields and values defined by the given object of the\ngiven Class.\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n",
      "diff": "@@ -1,15 +1,14 @@\n private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n     Field[] fields \u003d clazz.getDeclaredFields();\n     Field.setAccessible(fields, true);\n     for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n         Field f \u003d fields[i];\n-        if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n-            if (!Modifier.isStatic(f.getModifiers())) {\n-                try {\n-                    builder.append(f.get(lhs), f.get(rhs));\n-                } catch (IllegalAccessException e) {\n-                }\n+        if ((f.getName().indexOf(\u0027$\u0027) \u003d\u003d -1) \u0026\u0026 (useTransients || !Modifier.isTransient(f.getModifiers())) \u0026\u0026 (!Modifier.isStatic(f.getModifiers()))) {\n+            try {\n+                builder.append(f.get(lhs), f.get(rhs));\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(\"Unexpected IllegalAccessException\");\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c40090fecdacd9366bba7e3e29d94f213cf2633": {
      "type": "Yintroduced",
      "commitMessage": "Add superclass behaviour to builder classes\nfrom Gary Gregory\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137228 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/1/20 上午1:35",
      "commitName": "5c40090fecdacd9366bba7e3e29d94f213cf2633",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,15 @@\n+private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n+    Field[] fields \u003d clazz.getDeclaredFields();\n+    Field.setAccessible(fields, true);\n+    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n+        Field f \u003d fields[i];\n+        if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n+            if (!Modifier.isStatic(f.getModifiers())) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private static void reflectionAppend(Object lhs, Object rhs, Class clazz, EqualsBuilder builder, boolean useTransients) {\n    Field[] fields \u003d clazz.getDeclaredFields();\n    Field.setAccessible(fields, true);\n    for (int i \u003d 0; i \u003c fields.length \u0026\u0026 builder.isEquals; i++) {\n        Field f \u003d fields[i];\n        if (useTransients || !Modifier.isTransient(f.getModifiers())) {\n            if (!Modifier.isStatic(f.getModifiers())) {\n                try {\n                    builder.append(f.get(lhs), f.get(rhs));\n                } catch (IllegalAccessException e) {\n                }\n            }\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java",
      "functionStartLine": 256,
      "functionName": "reflectionAppend",
      "functionAnnotation": "",
      "functionDoc": "Appends the fields and values defined by the given object of the\ngiven Class.\n\n@param lhs the left hand object\n@param rhs the right hand object\n@param clazz the class to append details of\n@param builder the builder to append to\n@param useTransients whether to test transient fields\n"
    }
  }
}