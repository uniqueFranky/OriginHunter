{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "AbstractNestablePropertyAccessor.java",
  "functionName": "setPropertyValue",
  "functionId": "setPropertyValue___tokens-PropertyTokenHolder__pv-PropertyValue",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 273,
  "functionEndLine": 280,
  "numCommitsSeen": 115,
  "timeTaken": 6163,
  "changeHistory": [
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
    "2dc674f356fbe941b98301f89494767f80d55e6a",
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405",
    "3d86f15a847d4567c3b08b21a21500398a394e31",
    "595cdf05e962299c19c34bbfb370316636d074f2",
    "e377fc003d675a61a9643d149b0745314ad02d7d",
    "aa213396b4aa73501d44927d3fe016571bba7555",
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb",
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3",
    "d004b634a5215635d01234ca72ac1a60079f055d",
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56",
    "59002f245623d758765b72d598cd78c326c6f5fa",
    "94685481162a93666fc2f39b66223833a6bcb418",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "569426dfdfec186e98a6ae4bd8ebf946720206b1",
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
    "b8f7d324afe9891f7ba812eae431a7e38b254944",
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
    "c09227a71265578a15bbf516abc523716490d1ac",
    "6f146737f475828b6d765784017773378c2c4922",
    "2fcab44de08bd09159fb7adea2531b16dea3e69b",
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
    "90d8dade254b4f34fd28d498ce529efd2177c606",
    "5d6840e8770b441ae0676b309ba2021704e55a77",
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8",
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
    "cc91efecaee777604828669b1b14ff9ee6468dfe",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
    "66abad25400aab7e6211f75449ec6bde08cae659",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
    "1c33206042c09a4344e5e4a1c6b759eb6180274c",
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94",
    "ad492e906e4c9c994cad733d366ec9c30950ed92",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
    "af8af8c633ba016eca671bc9468eba006e8834b1",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
    "eca1cad7e1e78714d22681554474f887d9046632",
    "bf7a947559d8f9918cc738780bf04caf8ea46962",
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89": "Ymultichange(Ybodychange,Yannotationchange)",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": "Ybodychange",
    "2dc674f356fbe941b98301f89494767f80d55e6a": "Ymovefromfile",
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405": "Ybodychange",
    "3d86f15a847d4567c3b08b21a21500398a394e31": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "595cdf05e962299c19c34bbfb370316636d074f2": "Ybodychange",
    "e377fc003d675a61a9643d149b0745314ad02d7d": "Ybodychange",
    "aa213396b4aa73501d44927d3fe016571bba7555": "Ybodychange",
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb": "Ybodychange",
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3": "Ybodychange",
    "d004b634a5215635d01234ca72ac1a60079f055d": "Ybodychange",
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56": "Ybodychange",
    "59002f245623d758765b72d598cd78c326c6f5fa": "Ybodychange",
    "94685481162a93666fc2f39b66223833a6bcb418": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "569426dfdfec186e98a6ae4bd8ebf946720206b1": "Ybodychange",
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16": "Ybodychange",
    "b8f7d324afe9891f7ba812eae431a7e38b254944": "Ybodychange",
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091": "Ybodychange",
    "c09227a71265578a15bbf516abc523716490d1ac": "Ybodychange",
    "6f146737f475828b6d765784017773378c2c4922": "Ybodychange",
    "2fcab44de08bd09159fb7adea2531b16dea3e69b": "Ybodychange",
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e": "Ybodychange",
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f": "Ybodychange",
    "90d8dade254b4f34fd28d498ce529efd2177c606": "Ybodychange",
    "5d6840e8770b441ae0676b309ba2021704e55a77": "Ybodychange",
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044": "Ybodychange",
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a": "Ybodychange",
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8": "Ybodychange",
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8": "Ybodychange",
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31": "Ybodychange",
    "cc91efecaee777604828669b1b14ff9ee6468dfe": "Ybodychange",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": "Ybodychange",
    "66abad25400aab7e6211f75449ec6bde08cae659": "Ybodychange",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": "Ybodychange",
    "1c33206042c09a4344e5e4a1c6b759eb6180274c": "Ybodychange",
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f": "Ybodychange",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": "Ybodychange",
    "ad492e906e4c9c994cad733d366ec9c30950ed92": "Ybodychange",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": "Ybodychange",
    "af8af8c633ba016eca671bc9468eba006e8834b1": "Ybodychange",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": "Ybodychange",
    "eca1cad7e1e78714d22681554474f887d9046632": "Ybodychange",
    "bf7a947559d8f9918cc738780bf04caf8ea46962": "Ybodychange",
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611": "Ymultichange(Ybodychange,Yannotationchange)",
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "AbstractNestablePropertyAccessor\u0027s setPropertyValue refactored into several delegate methods\n\nIssue: SPR-15053\n",
      "commitDate": "2016/12/27 上午2:47",
      "commitName": "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "AbstractNestablePropertyAccessor\u0027s setPropertyValue refactored into several delegate methods\n\nIssue: SPR-15053\n",
          "commitDate": "2016/12/27 上午2:47",
          "commitName": "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2016/9/14 上午3:55",
          "commitNameOld": "c69e6a36f7322d52d2989ea9136c7aff33f199c9",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 103.95,
          "commitsBetweenForRepo": 562,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    if (tokens.keys !\u003d null) {\n        processKeyedProperty(tokens, pv);\n    } else {\n        processLocalProperty(tokens, pv);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
          "functionStartLine": 269,
          "functionName": "setPropertyValue",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,147 +1,7 @@\n-@SuppressWarnings(\"unchecked\")\n protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n-    String propertyName \u003d tokens.canonicalName;\n-    String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n-        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n-        getterTokens.canonicalName \u003d tokens.canonicalName;\n-        getterTokens.actualName \u003d tokens.actualName;\n-        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n-        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-        Object propValue;\n-        try {\n-            propValue \u003d getPropertyValue(getterTokens);\n-        } catch (NotReadablePropertyException ex) {\n-            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n-        }\n-        String key \u003d tokens.keys[tokens.keys.length - 1];\n-        if (propValue \u003d\u003d null) {\n-            if (isAutoGrowNestedPaths()) {\n-                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n-                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n-                propValue \u003d setDefaultValue(getterTokens);\n-            } else {\n-                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n-            }\n-        }\n-        if (propValue.getClass().isArray()) {\n-            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n-            int arrayIndex \u003d Integer.parseInt(key);\n-            Object oldValue \u003d null;\n-            try {\n-                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n-                    oldValue \u003d Array.get(propValue, arrayIndex);\n-                }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n-                int length \u003d Array.getLength(propValue);\n-                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n-                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n-                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n-                    System.arraycopy(propValue, 0, newArray, 0, length);\n-                    setPropertyValue(actualName, newArray);\n-                    propValue \u003d getPropertyValue(actualName);\n-                }\n-                Array.set(propValue, arrayIndex, convertedValue);\n-            } catch (IndexOutOfBoundsException ex) {\n-                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-            }\n-        } else if (propValue instanceof List) {\n-            PropertyHandler ph \u003d getPropertyHandler(actualName);\n-            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n-            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n-            int index \u003d Integer.parseInt(key);\n-            Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n-                oldValue \u003d list.get(index);\n-            }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n-            int size \u003d list.size();\n-            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n-                for (int i \u003d size; i \u003c index; i++) {\n-                    try {\n-                        list.add(null);\n-                    } catch (NullPointerException ex) {\n-                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n-                    }\n-                }\n-                list.add(convertedValue);\n-            } else {\n-                try {\n-                    list.set(index, convertedValue);\n-                } catch (IndexOutOfBoundsException ex) {\n-                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-                }\n-            }\n-        } else if (propValue instanceof Map) {\n-            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n-            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n-            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n-            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n-            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n-            Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor()) {\n-                oldValue \u003d map.get(convertedMapKey);\n-            }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n-            map.put(convertedMapKey, convertedMapValue);\n-        } else {\n-            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n-        }\n+        processKeyedProperty(tokens, pv);\n     } else {\n-        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-        if (ph \u003d\u003d null || !ph.isWritable()) {\n-            if (pv.isOptional()) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-                }\n-                return;\n-            } else {\n-                throw createNotWritablePropertyException(propertyName);\n-            }\n-        }\n-        Object oldValue \u003d null;\n-        try {\n-            Object originalValue \u003d pv.getValue();\n-            Object valueToApply \u003d originalValue;\n-            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n-                if (pv.isConverted()) {\n-                    valueToApply \u003d pv.getConvertedValue();\n-                } else {\n-                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n-                        try {\n-                            oldValue \u003d ph.getValue();\n-                        } catch (Exception ex) {\n-                            if (ex instanceof PrivilegedActionException) {\n-                                ex \u003d ((PrivilegedActionException) ex).getException();\n-                            }\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n-                            }\n-                        }\n-                    }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n-                }\n-                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n-            }\n-            ph.setValue(this.wrappedObject, valueToApply);\n-        } catch (TypeMismatchException ex) {\n-            throw ex;\n-        } catch (InvocationTargetException ex) {\n-            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            if (ex.getTargetException() instanceof ClassCastException) {\n-                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n-            } else {\n-                Throwable cause \u003d ex.getTargetException();\n-                if (cause instanceof UndeclaredThrowableException) {\n-                    cause \u003d cause.getCause();\n-                }\n-                throw new MethodInvocationException(propertyChangeEvent, cause);\n-            }\n-        } catch (Exception ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new MethodInvocationException(pce, ex);\n-        }\n+        processLocalProperty(tokens, pv);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "AbstractNestablePropertyAccessor\u0027s setPropertyValue refactored into several delegate methods\n\nIssue: SPR-15053\n",
          "commitDate": "2016/12/27 上午2:47",
          "commitName": "64d6561cbbda4d5a74cd0f3ce5983e29c9d42b89",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2016/9/14 上午3:55",
          "commitNameOld": "c69e6a36f7322d52d2989ea9136c7aff33f199c9",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 103.95,
          "commitsBetweenForRepo": 562,
          "commitsBetweenForFile": 1,
          "actualSource": "protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    if (tokens.keys !\u003d null) {\n        processKeyedProperty(tokens, pv);\n    } else {\n        processLocalProperty(tokens, pv);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
          "functionStartLine": 269,
          "functionName": "setPropertyValue",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,147 +1,7 @@\n-@SuppressWarnings(\"unchecked\")\n protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n-    String propertyName \u003d tokens.canonicalName;\n-    String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n-        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n-        getterTokens.canonicalName \u003d tokens.canonicalName;\n-        getterTokens.actualName \u003d tokens.actualName;\n-        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n-        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-        Object propValue;\n-        try {\n-            propValue \u003d getPropertyValue(getterTokens);\n-        } catch (NotReadablePropertyException ex) {\n-            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n-        }\n-        String key \u003d tokens.keys[tokens.keys.length - 1];\n-        if (propValue \u003d\u003d null) {\n-            if (isAutoGrowNestedPaths()) {\n-                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n-                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n-                propValue \u003d setDefaultValue(getterTokens);\n-            } else {\n-                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n-            }\n-        }\n-        if (propValue.getClass().isArray()) {\n-            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n-            int arrayIndex \u003d Integer.parseInt(key);\n-            Object oldValue \u003d null;\n-            try {\n-                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n-                    oldValue \u003d Array.get(propValue, arrayIndex);\n-                }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n-                int length \u003d Array.getLength(propValue);\n-                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n-                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n-                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n-                    System.arraycopy(propValue, 0, newArray, 0, length);\n-                    setPropertyValue(actualName, newArray);\n-                    propValue \u003d getPropertyValue(actualName);\n-                }\n-                Array.set(propValue, arrayIndex, convertedValue);\n-            } catch (IndexOutOfBoundsException ex) {\n-                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-            }\n-        } else if (propValue instanceof List) {\n-            PropertyHandler ph \u003d getPropertyHandler(actualName);\n-            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n-            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n-            int index \u003d Integer.parseInt(key);\n-            Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n-                oldValue \u003d list.get(index);\n-            }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n-            int size \u003d list.size();\n-            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n-                for (int i \u003d size; i \u003c index; i++) {\n-                    try {\n-                        list.add(null);\n-                    } catch (NullPointerException ex) {\n-                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n-                    }\n-                }\n-                list.add(convertedValue);\n-            } else {\n-                try {\n-                    list.set(index, convertedValue);\n-                } catch (IndexOutOfBoundsException ex) {\n-                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n-                }\n-            }\n-        } else if (propValue instanceof Map) {\n-            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n-            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n-            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n-            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n-            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n-            Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor()) {\n-                oldValue \u003d map.get(convertedMapKey);\n-            }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n-            map.put(convertedMapKey, convertedMapValue);\n-        } else {\n-            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n-        }\n+        processKeyedProperty(tokens, pv);\n     } else {\n-        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n-        if (ph \u003d\u003d null || !ph.isWritable()) {\n-            if (pv.isOptional()) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-                }\n-                return;\n-            } else {\n-                throw createNotWritablePropertyException(propertyName);\n-            }\n-        }\n-        Object oldValue \u003d null;\n-        try {\n-            Object originalValue \u003d pv.getValue();\n-            Object valueToApply \u003d originalValue;\n-            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n-                if (pv.isConverted()) {\n-                    valueToApply \u003d pv.getConvertedValue();\n-                } else {\n-                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n-                        try {\n-                            oldValue \u003d ph.getValue();\n-                        } catch (Exception ex) {\n-                            if (ex instanceof PrivilegedActionException) {\n-                                ex \u003d ((PrivilegedActionException) ex).getException();\n-                            }\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n-                            }\n-                        }\n-                    }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n-                }\n-                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n-            }\n-            ph.setValue(this.wrappedObject, valueToApply);\n-        } catch (TypeMismatchException ex) {\n-            throw ex;\n-        } catch (InvocationTargetException ex) {\n-            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            if (ex.getTargetException() instanceof ClassCastException) {\n-                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n-            } else {\n-                Throwable cause \u003d ex.getTargetException();\n-                if (cause instanceof UndeclaredThrowableException) {\n-                    cause \u003d cause.getCause();\n-                }\n-                throw new MethodInvocationException(propertyChangeEvent, cause);\n-            }\n-        } catch (Exception ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new MethodInvocationException(pce, ex);\n-        }\n+        processLocalProperty(tokens, pv);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": ""
          }
        }
      ]
    },
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
      "type": "Ybodychange",
      "commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
      "commitDate": "2016/4/7 下午8:18",
      "commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/12/9 下午7:28",
      "commitNameOld": "11806b921541ba225008937d9054d08ab06524ae",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 120.03,
      "commitsBetweenForRepo": 538,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        try {\n                            oldValue \u003d ph.getValue();\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(this.wrappedObject, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
      "functionStartLine": 288,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,147 +1,147 @@\n @SuppressWarnings(\"unchecked\")\n protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyHandler ph \u003d getPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n         PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n         if (ph \u003d\u003d null || !ph.isWritable()) {\n             if (pv.isOptional()) {\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                 }\n                 return;\n             } else {\n                 throw createNotWritablePropertyException(propertyName);\n             }\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                         try {\n                             oldValue \u003d ph.getValue();\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            ph.setValue(object, valueToApply);\n+            ph.setValue(this.wrappedObject, valueToApply);\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n             } else {\n                 Throwable cause \u003d ex.getTargetException();\n                 if (cause instanceof UndeclaredThrowableException) {\n                     cause \u003d cause.getCause();\n                 }\n                 throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2dc674f356fbe941b98301f89494767f80d55e6a": {
      "type": "Ymovefromfile",
      "commitMessage": "Restore AbstractPropertyAccessor\n\nCommit 3d86f15 added a lot of new feature in AbstractPropertyAccessor\nshared by both DirectFieldAccessor and BeanWrapperImpl. This makes this\nabstract class harder to implement for others having simpler use cases.\n\nIt turns that Spring Data has such use case; this commit split these new\nfeatures in a dedicated new base class, leaving AbstractPropertyAccessor\nuntouched.\n\nIssue: SPR-12805\n",
      "commitDate": "2015/5/22 下午4:33",
      "commitName": "2dc674f356fbe941b98301f89494767f80d55e6a",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015/5/22 下午4:28",
      "commitNameOld": "27c435c4eae6502ba068a5da8c19d626c28316c3",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        try {\n                            oldValue \u003d ph.getValue();\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(object, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
      "functionStartLine": 286,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractNestablePropertyAccessor.java",
        "oldMethodName": "setPropertyValue",
        "newMethodName": "setPropertyValue"
      }
    },
    "6fb31903536c0a41dd4fbe153c81494ccfd4d405": {
      "type": "Ybodychange",
      "commitMessage": "Fix regression with binding and validation\n\nPreviously, the binding may have to call the getter first to retrieve the\nold value of a property before actually setting it. This was guarded by\na catch block that was accidentally removed in 3d86f15\n\nRestore that catch block and add a test to cover it.\n\nIssue: SPR-12805\n",
      "commitDate": "2015/5/21 下午11:48",
      "commitName": "6fb31903536c0a41dd4fbe153c81494ccfd4d405",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2015/5/21 下午7:49",
      "commitNameOld": "3d86f15a847d4567c3b08b21a21500398a394e31",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        try {\n                            oldValue \u003d ph.getValue();\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(object, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
      "functionStartLine": 379,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,138 +1,147 @@\n @SuppressWarnings(\"unchecked\")\n protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyHandler ph \u003d getPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n         PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n         if (ph \u003d\u003d null || !ph.isWritable()) {\n             if (pv.isOptional()) {\n                 if (logger.isDebugEnabled()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                 }\n                 return;\n             } else {\n                 throw createNotWritablePropertyException(propertyName);\n             }\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n-                        oldValue \u003d ph.getValue();\n+                        try {\n+                            oldValue \u003d ph.getValue();\n+                        } catch (Exception ex) {\n+                            if (ex instanceof PrivilegedActionException) {\n+                                ex \u003d ((PrivilegedActionException) ex).getException();\n+                            }\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n+                            }\n+                        }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             ph.setValue(object, valueToApply);\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n             } else {\n                 Throwable cause \u003d ex.getTargetException();\n                 if (cause instanceof UndeclaredThrowableException) {\n                     cause \u003d cause.getCause();\n                 }\n                 throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d86f15a847d4567c3b08b21a21500398a394e31": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
      "commitDate": "2015/5/21 下午7:49",
      "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
      "commitAuthor": "Stephane Nicoll",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015/5/21 下午7:49",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015/5/21 上午5:06",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        oldValue \u003d ph.getValue();\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(object, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,206 +1,138 @@\n @SuppressWarnings(\"unchecked\")\n-private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getPropertyHandler(actualName);\n+            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n-            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n-        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-                if (pv.isOptional()) {\n+        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+        if (ph \u003d\u003d null || !ph.isWritable()) {\n+            if (pv.isOptional()) {\n+                if (logger.isDebugEnabled()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-                    return;\n-                } else {\n-                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n+                return;\n+            } else {\n+                throw createNotWritablePropertyException(propertyName);\n             }\n-            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n-                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-                        final Method readMethod \u003d pd.getReadMethod();\n-                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() {\n-                                        readMethod.setAccessible(true);\n-                                        return null;\n-                                    }\n-                                });\n-                            } else {\n-                                readMethod.setAccessible(true);\n-                            }\n-                        }\n-                        try {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() throws Exception {\n-                                        return readMethod.invoke(object);\n-                                    }\n-                                }, acc);\n-                            } else {\n-                                oldValue \u003d readMethod.invoke(object);\n-                            }\n-                        } catch (Exception ex) {\n-                            if (ex instanceof PrivilegedActionException) {\n-                                ex \u003d ((PrivilegedActionException) ex).getException();\n-                            }\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n-                            }\n-                        }\n+                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+                        oldValue \u003d ph.getValue();\n                     }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n-            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-                if (System.getSecurityManager() !\u003d null) {\n-                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() {\n-                            writeMethod.setAccessible(true);\n-                            return null;\n-                        }\n-                    });\n-                } else {\n-                    writeMethod.setAccessible(true);\n-                }\n-            }\n-            final Object value \u003d valueToApply;\n-            if (System.getSecurityManager() !\u003d null) {\n-                try {\n-                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() throws Exception {\n-                            writeMethod.invoke(object, value);\n-                            return null;\n-                        }\n-                    }, acc);\n-                } catch (PrivilegedActionException ex) {\n-                    throw ex.getException();\n-                }\n-            } else {\n-                writeMethod.invoke(this.object, value);\n-            }\n+            ph.setValue(object, valueToApply);\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n-                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n             } else {\n                 Throwable cause \u003d ex.getTargetException();\n                 if (cause instanceof UndeclaredThrowableException) {\n                     cause \u003d cause.getCause();\n                 }\n                 throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
            "newPath": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
            "oldMethodName": "setPropertyValue",
            "newMethodName": "setPropertyValue"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015/5/21 下午7:49",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015/5/21 上午5:06",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        oldValue \u003d ph.getValue();\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(object, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,206 +1,138 @@\n @SuppressWarnings(\"unchecked\")\n-private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getPropertyHandler(actualName);\n+            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n-            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n-        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-                if (pv.isOptional()) {\n+        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+        if (ph \u003d\u003d null || !ph.isWritable()) {\n+            if (pv.isOptional()) {\n+                if (logger.isDebugEnabled()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-                    return;\n-                } else {\n-                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n+                return;\n+            } else {\n+                throw createNotWritablePropertyException(propertyName);\n             }\n-            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n-                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-                        final Method readMethod \u003d pd.getReadMethod();\n-                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() {\n-                                        readMethod.setAccessible(true);\n-                                        return null;\n-                                    }\n-                                });\n-                            } else {\n-                                readMethod.setAccessible(true);\n-                            }\n-                        }\n-                        try {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() throws Exception {\n-                                        return readMethod.invoke(object);\n-                                    }\n-                                }, acc);\n-                            } else {\n-                                oldValue \u003d readMethod.invoke(object);\n-                            }\n-                        } catch (Exception ex) {\n-                            if (ex instanceof PrivilegedActionException) {\n-                                ex \u003d ((PrivilegedActionException) ex).getException();\n-                            }\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n-                            }\n-                        }\n+                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+                        oldValue \u003d ph.getValue();\n                     }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n-            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-                if (System.getSecurityManager() !\u003d null) {\n-                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() {\n-                            writeMethod.setAccessible(true);\n-                            return null;\n-                        }\n-                    });\n-                } else {\n-                    writeMethod.setAccessible(true);\n-                }\n-            }\n-            final Object value \u003d valueToApply;\n-            if (System.getSecurityManager() !\u003d null) {\n-                try {\n-                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() throws Exception {\n-                            writeMethod.invoke(object, value);\n-                            return null;\n-                        }\n-                    }, acc);\n-                } catch (PrivilegedActionException ex) {\n-                    throw ex.getException();\n-                }\n-            } else {\n-                writeMethod.invoke(this.object, value);\n-            }\n+            ph.setValue(object, valueToApply);\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n-                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n             } else {\n                 Throwable cause \u003d ex.getTargetException();\n                 if (cause instanceof UndeclaredThrowableException) {\n                     cause \u003d cause.getCause();\n                 }\n                 throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge BeanWrapperImpl and DirectFieldAccessor\n\n`BeanWrapperImpl` and `DirectFieldAccessor` are two\n`ConfigurablePropertyAccessor` implementations with different features\nset.\n\nThis commit harmonizes the two implementations to use a common base class\nthat delegates the actual property handling to the sub-classes:\n\n* `BeanWrapperImpl`:  `PropertyDescriptor` and introspection utilities\n* `DirectFieldAccessor`: reflection on `java.lang.Field`\n\nIssues: SPR-12206 - SPR-12805\n",
          "commitDate": "2015/5/21 下午7:49",
          "commitName": "3d86f15a847d4567c3b08b21a21500398a394e31",
          "commitAuthor": "Stephane Nicoll",
          "commitDateOld": "2015/5/21 上午5:06",
          "commitNameOld": "ad4c8795ae13c94f942526765b5cf36ac6c3ae9b",
          "commitAuthorOld": "Rossen Stoyanchev",
          "daysBetweenCommits": 0.61,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyHandler ph \u003d getPropertyHandler(actualName);\n            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n        if (ph \u003d\u003d null || !ph.isWritable()) {\n            if (pv.isOptional()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                }\n                return;\n            } else {\n                throw createNotWritablePropertyException(propertyName);\n            }\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n                        oldValue \u003d ph.getValue();\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            ph.setValue(object, valueToApply);\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/AbstractPropertyAccessor.java",
          "functionStartLine": 378,
          "functionName": "setPropertyValue",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,206 +1,138 @@\n @SuppressWarnings(\"unchecked\")\n-private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getPropertyHandler(actualName);\n+            Class\u003c?\u003e requiredType \u003d ph.getCollectionType(tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, ph.nested(tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n-            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n-            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n+            PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+            Class\u003c?\u003e mapKeyType \u003d ph.getMapKeyType(tokens.keys.length);\n+            Class\u003c?\u003e mapValueType \u003d ph.getMapValueType(tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, ph.nested(tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n-        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n-        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n-            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-                if (pv.isOptional()) {\n+        PropertyHandler ph \u003d getLocalPropertyHandler(actualName);\n+        if (ph \u003d\u003d null || !ph.isWritable()) {\n+            if (pv.isOptional()) {\n+                if (logger.isDebugEnabled()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n-                    return;\n-                } else {\n-                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n+                return;\n+            } else {\n+                throw createNotWritablePropertyException(propertyName);\n             }\n-            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n-                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-                        final Method readMethod \u003d pd.getReadMethod();\n-                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() {\n-                                        readMethod.setAccessible(true);\n-                                        return null;\n-                                    }\n-                                });\n-                            } else {\n-                                readMethod.setAccessible(true);\n-                            }\n-                        }\n-                        try {\n-                            if (System.getSecurityManager() !\u003d null) {\n-                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                                    @Override\n-                                    public Object run() throws Exception {\n-                                        return readMethod.invoke(object);\n-                                    }\n-                                }, acc);\n-                            } else {\n-                                oldValue \u003d readMethod.invoke(object);\n-                            }\n-                        } catch (Exception ex) {\n-                            if (ex instanceof PrivilegedActionException) {\n-                                ex \u003d ((PrivilegedActionException) ex).getException();\n-                            }\n-                            if (logger.isDebugEnabled()) {\n-                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n-                            }\n-                        }\n+                    if (isExtractOldValueForEditor() \u0026\u0026 ph.isReadable()) {\n+                        oldValue \u003d ph.getValue();\n                     }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, ph.toTypeDescriptor());\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n-            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n-                if (System.getSecurityManager() !\u003d null) {\n-                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() {\n-                            writeMethod.setAccessible(true);\n-                            return null;\n-                        }\n-                    });\n-                } else {\n-                    writeMethod.setAccessible(true);\n-                }\n-            }\n-            final Object value \u003d valueToApply;\n-            if (System.getSecurityManager() !\u003d null) {\n-                try {\n-                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n-\n-                        @Override\n-                        public Object run() throws Exception {\n-                            writeMethod.invoke(object, value);\n-                            return null;\n-                        }\n-                    }, acc);\n-                } catch (PrivilegedActionException ex) {\n-                    throw ex.getException();\n-                }\n-            } else {\n-                writeMethod.invoke(this.object, value);\n-            }\n+            ph.setValue(object, valueToApply);\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n-                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+                throw new TypeMismatchException(propertyChangeEvent, ph.getPropertyType(), ex.getTargetException());\n             } else {\n                 Throwable cause \u003d ex.getTargetException();\n                 if (cause instanceof UndeclaredThrowableException) {\n                     cause \u003d cause.getCause();\n                 }\n                 throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "595cdf05e962299c19c34bbfb370316636d074f2": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2015/4/4 上午6:23",
      "commitName": "595cdf05e962299c19c34bbfb370316636d074f2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/3/31 下午4:03",
      "commitNameOld": "e377fc003d675a61a9643d149b0745314ad02d7d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.6,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                Throwable cause \u003d ex.getTargetException();\n                if (cause instanceof UndeclaredThrowableException) {\n                    cause \u003d cause.getCause();\n                }\n                throw new MethodInvocationException(propertyChangeEvent, cause);\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 936,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,202 +1,206 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n-                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+                Throwable cause \u003d ex.getTargetException();\n+                if (cause instanceof UndeclaredThrowableException) {\n+                    cause \u003d cause.getCause();\n+                }\n+                throw new MethodInvocationException(propertyChangeEvent, cause);\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e377fc003d675a61a9643d149b0745314ad02d7d": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapperImpl.setPropertyValue throws InvalidPropertyException with correct property value for nested collection case\n\nIssue: SPR-12866\n",
      "commitDate": "2015/3/31 下午4:03",
      "commitName": "e377fc003d675a61a9643d149b0745314ad02d7d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/2/11 下午6:29",
      "commitNameOld": "aa213396b4aa73501d44927d3fe016571bba7555",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 47.9,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 935,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,202 +1,202 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 int length \u003d Array.getLength(propValue);\n                 if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                     Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                     Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                     System.arraycopy(propValue, 0, newArray, 0, length);\n                     setPropertyValue(actualName, newArray);\n                     propValue \u003d getPropertyValue(actualName);\n                 }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n-            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + propValue + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aa213396b4aa73501d44927d3fe016571bba7555": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper auto-grows arrays if necessary\n\nPreviously, only indexed access for collections were supported. When\nattempting to access the element of an array that had not the requested\nsize, the call would fail with an IndexOutOfBoundException\n\nThis commit harmonize the binding support so that the array is updated\naccording to the requested index if necessary.\n\nIssue: SPR-12706\n",
      "commitDate": "2015/2/11 下午6:29",
      "commitName": "aa213396b4aa73501d44927d3fe016571bba7555",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2014/11/30 上午3:49",
      "commitNameOld": "bfbd25a0e94ab789171d331a121812468cbeb154",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 73.61,
      "commitsBetweenForRepo": 203,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                int length \u003d Array.getLength(propValue);\n                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n                    System.arraycopy(propValue, 0, newArray, 0, length);\n                    setPropertyValue(actualName, newArray);\n                    propValue \u003d getPropertyValue(actualName);\n                }\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 935,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,202 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+                int length \u003d Array.getLength(propValue);\n+                if (arrayIndex \u003e\u003d length \u0026\u0026 arrayIndex \u003c this.autoGrowCollectionLimit) {\n+                    Class\u003c?\u003e componentType \u003d propValue.getClass().getComponentType();\n+                    Object newArray \u003d Array.newInstance(componentType, arrayIndex + 1);\n+                    System.arraycopy(propValue, 0, newArray, 0, length);\n+                    setPropertyValue(actualName, newArray);\n+                    propValue \u003d getPropertyValue(actualName);\n+                }\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1708a8a10d17b9c3dc203b90f181c1d55ad5facb": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary null check\n\nIssue: SPR-12378\n",
      "commitDate": "2014/10/27 下午4:32",
      "commitName": "1708a8a10d17b9c3dc203b90f181c1d55ad5facb",
      "commitAuthor": "Seo, Kyung-Seok",
      "commitDateOld": "2014/9/25 下午11:00",
      "commitNameOld": "cfc821d1799ca7c64b1bbc53811b712fdaa4776c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 31.73,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 930,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n-            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n+            TypeDescriptor typeDescriptor \u003d TypeDescriptor.valueOf(mapKeyType);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3": {
      "type": "Ybodychange",
      "commitMessage": "Support for nested path using field access\n\nThis commit adds a nested path support for DirectFieldAccessor that is\nsimilar to what BeanWrapper provides. It is now possible to use\nexpressions such as \"person.address.city.name\" to access the name of\nthe city that a given person lives in using fields to traverse the\ngraph.\n\nDirectFieldAccessor also now supports an auto-grow option to create\na default instance for a \"null\" intermediate path. This option is\nfalse by default and leads to a NullValueInNestedPathException in such\na case.\n\nThis commit also harmonizes part of the tests suite so that core tests\nare shared between BeanWrapperImpl and DirectFieldAccessor.\n\nNote that map and list access is not implemented as part of this\ncommit.\n\nIssue: SPR-9705\n",
      "commitDate": "2014/6/27 上午1:22",
      "commitName": "8221c9abc5b5215bbf88e512f6f8060a9afd3ad3",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2014/1/28 上午8:25",
      "commitNameOld": "fcbd3b121ba0d6fa8378fd0f0773ef2a652f1426",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 149.71,
      "commitsBetweenForRepo": 764,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (isAutoGrowNestedPaths()) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 910,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n-            if (this.autoGrowNestedPaths) {\n+            if (isAutoGrowNestedPaths()) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d004b634a5215635d01234ca72ac1a60079f055d": {
      "type": "Ybodychange",
      "commitMessage": "Fixed type resolution in case of inconsistencies between read and write method\n\nIssue: SPR-11361\n",
      "commitDate": "2014/1/28 上午7:46",
      "commitName": "d004b634a5215635d01234ca72ac1a60079f055d",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/1/24 下午11:22",
      "commitNameOld": "8543b91c508d0eaf86212d148e63041eb38eeb3b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.35,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 929,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c2b56c07e59aeb123fbe63b282c0ef98d7380f56": {
      "type": "Ybodychange",
      "commitMessage": "Cache property TypeDescriptors\n\nAttempt to improve performance by caching TypeDescriptors against bean\nPropertyDescriptors in CachedIntrospectionResults.\n\nThis change is an attempt to fix the failing performance test case\n`testPrototypeCreationWithOverriddenResourcePropertiesIsFastEnough` in\n`AnnotationProcessorPerformanceTests`.\n",
      "commitDate": "2013/12/3 下午1:55",
      "commitName": "c2b56c07e59aeb123fbe63b282c0ef98d7380f56",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/11/26 上午4:52",
      "commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 7.38,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 926,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n-                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd, new TypeDescriptor(property(pd)));\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59002f245623d758765b72d598cd78c326c6f5fa": {
      "type": "Ybodychange",
      "commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
      "commitDate": "2013/11/26 上午4:52",
      "commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/5/14 上午6:04",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 195.95,
      "commitsBetweenForRepo": 742,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 921,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,194 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class requiredType \u003d propValue.getClass().getComponentType();\n+            Class\u003c?\u003e requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n-            List list \u003d (List) propValue;\n+            Class\u003c?\u003e requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n+            List\u003cObject\u003e list \u003d (List\u003cObject\u003e) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n-            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n-            Map map \u003d (Map) propValue;\n+            Class\u003c?\u003e mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n+            Class\u003c?\u003e mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n+            Map\u003cObject, Object\u003e map \u003d (Map\u003cObject, Object\u003e) propValue;\n             TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94685481162a93666fc2f39b66223833a6bcb418": {
      "type": "Ybodychange",
      "commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
      "commitDate": "2013/5/14 上午6:04",
      "commitName": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthor": "Rob Winch",
      "commitDateOld": "2013/2/5 上午2:35",
      "commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 98.15,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    @Override\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        @Override\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 923,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,190 +1,194 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n+                                    @Override\n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n+                                    @Override\n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n+                        @Override\n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n+                        @Override\n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 932,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java"
      }
    },
    "569426dfdfec186e98a6ae4bd8ebf946720206b1": {
      "type": "Ybodychange",
      "commitMessage": "restored DataBinder\u0027s ability to bind to an auto-growing List with unknown element type (SPR-8828)\n",
      "commitDate": "2011/12/8 上午5:27",
      "commitName": "569426dfdfec186e98a6ae4bd8ebf946720206b1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/7/4 上午4:24",
      "commitNameOld": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 157.04,
      "commitsBetweenForRepo": 543,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            int size \u003d list.size();\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 932,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,190 +1,190 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n-            int size \u003d list.size();\n             Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n+            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n+            int size \u003d list.size();\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n                 try {\n                     list.set(index, convertedValue);\n                 } catch (IndexOutOfBoundsException ex) {\n                     throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                 }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+            TypeDescriptor typeDescriptor \u003d (mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class));\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "22939b6d05bc226f47e4714f9ebcdc709de3ab16": {
      "type": "Ybodychange",
      "commitMessage": "properly wrap IndexOutOfBoundsException even for List\n",
      "commitDate": "2011/7/4 上午4:24",
      "commitName": "22939b6d05bc226f47e4714f9ebcdc709de3ab16",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/7/4 上午4:12",
      "commitNameOld": "b8f7d324afe9891f7ba812eae431a7e38b254944",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            int size \u003d list.size();\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                try {\n                    list.set(index, convertedValue);\n                } catch (IndexOutOfBoundsException ex) {\n                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n                }\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,190 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             int size \u003d list.size();\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             } else {\n-                list.set(index, convertedValue);\n+                try {\n+                    list.set(index, convertedValue);\n+                } catch (IndexOutOfBoundsException ex) {\n+                    throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid list index in property path \u0027\" + propertyName + \"\u0027\", ex);\n+                }\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b8f7d324afe9891f7ba812eae431a7e38b254944": {
      "type": "Ybodychange",
      "commitMessage": "regular IndexOutOfBoundsException if index beyond auto-grow limit\n",
      "commitDate": "2011/7/4 上午4:12",
      "commitName": "b8f7d324afe9891f7ba812eae431a7e38b254944",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/7/4 上午4:05",
      "commitNameOld": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            int size \u003d list.size();\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            } else {\n                list.set(index, convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,186 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             int size \u003d list.size();\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-            if (index \u003c size) {\n-                list.set(index, convertedValue);\n-            } else if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n+            if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                 for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n+            } else {\n+                list.set(index, convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b9fe1b325081f4ec7a5c1e905da00d3ed5223091": {
      "type": "Ybodychange",
      "commitMessage": "restored original array behavior (no default growth of arrays)\n",
      "commitDate": "2011/7/4 上午4:05",
      "commitName": "b9fe1b325081f4ec7a5c1e905da00d3ed5223091",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/7/4 上午3:26",
      "commitNameOld": "4c75054f9041279423f31754aa23f9ca781e9d43",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            int size \u003d list.size();\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            if (index \u003c size) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n                for (int i \u003d size; i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 928,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,186 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n+            int size \u003d list.size();\n             Object oldValue \u003d null;\n-            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n+            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c size) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n-            if (index \u003c list.size()) {\n+            if (index \u003c size) {\n                 list.set(index, convertedValue);\n-            } else if (index \u003e\u003d list.size()) {\n-                for (int i \u003d list.size(); i \u003c index; i++) {\n+            } else if (index \u003e\u003d size \u0026\u0026 index \u003c this.autoGrowCollectionLimit) {\n+                for (int i \u003d size; i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n-                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n+                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + size + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c09227a71265578a15bbf516abc523716490d1ac": {
      "type": "Ybodychange",
      "commitMessage": "removed dependency on java.beans\n",
      "commitDate": "2011/6/5 下午4:29",
      "commitName": "c09227a71265578a15bbf516abc523716490d1ac",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/3 上午7:37",
      "commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 907,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,186 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n                 propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(property(pd), tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f146737f475828b6d765784017773378c2c4922": {
      "type": "Ybodychange",
      "commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
      "commitDate": "2011/6/3 上午7:37",
      "commitName": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午5:25",
      "commitNameOld": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 146.09,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 906,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,186 +1,186 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             if (this.autoGrowNestedPaths) {\n                 int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                 getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                 propValue \u003d setDefaultValue(getterTokens);\n             } else {\n                 throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n             }\n         }\n         if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n                 propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, TypeDescriptor.nested(getWrappedClass(), pd, tokens.keys.length));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2fcab44de08bd09159fb7adea2531b16dea3e69b": {
      "type": "Ybodychange",
      "commitMessage": "remove addressed TODO\n",
      "commitDate": "2011/1/8 上午5:25",
      "commitName": "2fcab44de08bd09159fb7adea2531b16dea3e69b",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午5:13",
      "commitNameOld": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "34fbd5affa10eb73cd82f32f1d6d1718950fc35e": {
      "type": "Ybodychange",
      "commitMessage": "typo\n",
      "commitDate": "2011/1/8 上午5:13",
      "commitName": "34fbd5affa10eb73cd82f32f1d6d1718950fc35e",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午3:22",
      "commitNameOld": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f": {
      "type": "Ybodychange",
      "commitMessage": "sp7839 - map autogrow, including auto-grow support for map values\n",
      "commitDate": "2011/1/8 上午3:22",
      "commitName": "414fcab899b4fdf0b0190227ac1699ef3f3b3f3f",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午1:54",
      "commitNameOld": "90d8dade254b4f34fd28d498ce529efd2177c606",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            if (this.autoGrowNestedPaths) {\n                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n                propValue \u003d setDefaultValue(getterTokens);\n            } else {\n                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n            }\n        }\n        if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 917,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,179 +1,186 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n-            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n-        } else if (propValue.getClass().isArray()) {\n+            if (this.autoGrowNestedPaths) {\n+                int lastKeyIndex \u003d tokens.canonicalName.lastIndexOf(\u0027[\u0027);\n+                getterTokens.canonicalName \u003d tokens.canonicalName.substring(0, lastKeyIndex);\n+                propValue \u003d setDefaultValue(getterTokens);\n+            } else {\n+                throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+            }\n+        }\n+        if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                 propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90d8dade254b4f34fd28d498ce529efd2177c606": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug related to array autogrow\n",
      "commitDate": "2011/1/8 上午1:54",
      "commitName": "90d8dade254b4f34fd28d498ce529efd2177c606",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午1:28",
      "commitNameOld": "5d6840e8770b441ae0676b309ba2021704e55a77",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,183 +1,179 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                 propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n-                PropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n-                newValue.resolvedDescriptor \u003d pd;\n-                newValue.conversionNecessary \u003d false;\n-                setPropertyValue(newValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d6840e8770b441ae0676b309ba2021704e55a77": {
      "type": "Ybodychange",
      "commitMessage": "array autogrow on set e.g. array[0]\u003dfoo\n",
      "commitDate": "2011/1/8 上午1:28",
      "commitName": "5d6840e8770b441ae0676b309ba2021704e55a77",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午12:18",
      "commitNameOld": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                Array.set(propValue, arrayIndex, convertedValue);\n                PropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n                newValue.resolvedDescriptor \u003d pd;\n                newValue.conversionNecessary \u003d false;\n                setPropertyValue(newValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 915,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,178 +1,183 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n-                if (isExtractOldValueForEditor()) {\n+                if (isExtractOldValueForEditor() \u0026\u0026 arrayIndex \u003c Array.getLength(propValue)) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n+                propValue \u003d growArrayIfNecessary(propValue, arrayIndex, actualName);\n                 Array.set(propValue, arrayIndex, convertedValue);\n+                PropertyValue newValue \u003d new PropertyValue(actualName, propValue);\n+                newValue.resolvedDescriptor \u003d pd;\n+                newValue.conversionNecessary \u003d false;\n+                setPropertyValue(newValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044": {
      "type": "Ybodychange",
      "commitMessage": "removed accidental system.out commit\n",
      "commitDate": "2011/1/8 上午12:18",
      "commitName": "2ef629d5a8f5f933a614ba89e1b1e0d58ae04044",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/8 上午12:16",
      "commitNameOld": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,179 +1,178 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n-                System.out.println(list);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ed03fc6caec159db6fe4a27f085f4effa130a1a": {
      "type": "Ybodychange",
      "commitMessage": "fetch property value again after setting default value to protect against object copy\n",
      "commitDate": "2011/1/8 上午12:16",
      "commitName": "1ed03fc6caec159db6fe4a27f085f4effa130a1a",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/7 上午10:51",
      "commitNameOld": "42403a37c3fcf159bdc574a7200396825d55fecf",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n                System.out.println(list);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 916,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,178 +1,179 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n+                System.out.println(list);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c6c782df59c09a6a36c8283cbd725e9aef20e0e8": {
      "type": "Ybodychange",
      "commitMessage": "forNestedType usage clarification\n",
      "commitDate": "2011/1/7 上午2:33",
      "commitName": "c6c782df59c09a6a36c8283cbd725e9aef20e0e8",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/6 下午8:00",
      "commitNameOld": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.27,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,178 +1,178 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8": {
      "type": "Ybodychange",
      "commitMessage": "temp added ignore on 2 new failing tests until time to investigate\n",
      "commitDate": "2011/1/6 下午8:00",
      "commitName": "7ec5f1694b2916eda9c4d873e22091a0c1f5d4f8",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/6 下午1:14",
      "commitNameOld": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "01c98c3bfb6fc3f970dc66055b8435a47a876e31": {
      "type": "Ybodychange",
      "commitMessage": "added initial support for handling unknown nested type values when converting collections; now favor factory method for constructing nested type descriptors for clarity (made constructor private); improved javadoc\n",
      "commitDate": "2011/1/6 下午1:14",
      "commitName": "01c98c3bfb6fc3f970dc66055b8435a47a876e31",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/6 上午3:18",
      "commitNameOld": "cc91efecaee777604828669b1b14ff9ee6468dfe",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 901,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,184 +1,178 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-                methodParameter.increaseNestingLevel();\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-            methodParameter.increaseNestingLevel();\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, PropertyTypeDescriptor.forNestedType(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n             Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n-            methodParameter.increaseNestingLevel();\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, PropertyTypeDescriptor.forNestedType(mapValueType, new MethodParameter(pd.getReadMethod(), -1), pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc91efecaee777604828669b1b14ff9ee6468dfe": {
      "type": "Ybodychange",
      "commitMessage": "Fixed bugs in bean wrapper related to nesting levels on method parameters\n",
      "commitDate": "2011/1/6 上午3:18",
      "commitName": "cc91efecaee777604828669b1b14ff9ee6468dfe",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/5 下午1:49",
      "commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n                methodParameter.increaseNestingLevel();\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n            methodParameter.increaseNestingLevel();\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n            methodParameter.increaseNestingLevel();\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 902,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,177 +1,184 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+                MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+                methodParameter.increaseNestingLevel();\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+            methodParameter.increaseNestingLevel();\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, methodParameter, pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n+            TypeDescriptor typeDescriptor \u003d mapKeyType !\u003d null ? TypeDescriptor.valueOf(mapKeyType) : TypeDescriptor.valueOf(Object.class);\n+            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, typeDescriptor);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n+            MethodParameter methodParameter \u003d new MethodParameter(pd.getReadMethod(), -1);\n+            methodParameter.increaseNestingLevel();\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new PropertyTypeDescriptor(mapValueType, methodParameter, pd));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
      "type": "Ybodychange",
      "commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
      "commitDate": "2011/1/5 下午1:49",
      "commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2010/10/14 上午8:14",
      "commitNameOld": "0195b0da3c28b3a48b8f1fc8b0b5a354f1a56265",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 83.23,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 902,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,177 +1,177 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(requiredType, new MethodParameter(pd.getReadMethod(), -1), pd));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n+            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(mapKeyType, new MethodParameter(pd.getReadMethod(), -1), pd));\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "66abad25400aab7e6211f75449ec6bde08cae659": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper preserves annotation information for individual array/list/map elements (SPR-7348)\n",
      "commitDate": "2010/7/13 上午4:56",
      "commitName": "66abad25400aab7e6211f75449ec6bde08cae659",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/6/24 上午1:27",
      "commitNameOld": "7f91153bba5a76099889f83d411adc6a40e8276e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.14,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 922,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,176 +1,177 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n+            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n                 Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), requiredType));\n             if (index \u003c list.size()) {\n                 list.set(index, convertedValue);\n             } else if (index \u003e\u003d list.size()) {\n                 for (int i \u003d list.size(); i \u003c index; i++) {\n                     try {\n                         list.add(null);\n                     } catch (NullPointerException ex) {\n                         throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n                 }\n                 list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n+            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType, new PropertyTypeDescriptor(pd, new MethodParameter(pd.getReadMethod(), -1), mapKeyType));\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(this.object, value);\n             }\n         } catch (TypeMismatchException ex) {\n             throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
      "type": "Ybodychange",
      "commitMessage": "revised BeanWrapper\u0027s exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
      "commitDate": "2010/5/18 上午5:59",
      "commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/3/25 上午1:40",
      "commitNameOld": "53b6e1c1b0a9dc60dae2f495751e71cfff401b7e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 54.18,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, arrayIndex, convertedValue);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n            if (index \u003c list.size()) {\n                list.set(index, convertedValue);\n            } else if (index \u003e\u003d list.size()) {\n                for (int i \u003d list.size(); i \u003c index; i++) {\n                    try {\n                        list.add(null);\n                    } catch (NullPointerException ex) {\n                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                    }\n                }\n                list.add(convertedValue);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(this.object, value);\n            }\n        } catch (TypeMismatchException ex) {\n            throw ex;\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 904,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,212 +1,176 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n-                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n-                Array.set(propValue, Integer.parseInt(key), convertedValue);\n-            } catch (IllegalArgumentException ex) {\n-                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-                throw new TypeMismatchException(pce, requiredType, ex);\n-            } catch (IllegalStateException ex) {\n-                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-                throw new ConversionNotSupportedException(pce, requiredType, ex);\n+                Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+                Array.set(propValue, arrayIndex, convertedValue);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n-            try {\n-                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n-                if (index \u003c list.size()) {\n-                    list.set(index, convertedValue);\n-                } else if (index \u003e\u003d list.size()) {\n-                    for (int i \u003d list.size(); i \u003c index; i++) {\n-                        try {\n-                            list.add(null);\n-                        } catch (NullPointerException ex) {\n-                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n-                        }\n+            Object convertedValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+            if (index \u003c list.size()) {\n+                list.set(index, convertedValue);\n+            } else if (index \u003e\u003d list.size()) {\n+                for (int i \u003d list.size(); i \u003c index; i++) {\n+                    try {\n+                        list.add(null);\n+                    } catch (NullPointerException ex) {\n+                        throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                     }\n-                    list.add(convertedValue);\n                 }\n-            } catch (IllegalArgumentException ex) {\n-                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-                throw new TypeMismatchException(pce, requiredType, ex);\n+                list.add(convertedValue);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey;\n-            Object convertedMapValue;\n-            try {\n-                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n-            } catch (IllegalArgumentException ex) {\n-                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n-                throw new TypeMismatchException(pce, mapKeyType, ex);\n-            }\n+            Object convertedMapKey \u003d convertIfNecessary(null, null, key, mapKeyType);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n-            try {\n-                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n-            } catch (IllegalArgumentException ex) {\n-                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-                throw new TypeMismatchException(pce, mapValueType, ex);\n-            }\n+            Object convertedMapValue \u003d convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new TypeDescriptor(new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1)));\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n-                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+                    valueToApply \u003d convertForProperty(propertyName, oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n-                writeMethod.invoke(object, value);\n+                writeMethod.invoke(this.object, value);\n             }\n+        } catch (TypeMismatchException ex) {\n+            throw ex;\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n-        } catch (ConverterNotFoundException ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-        } catch (ConversionException ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-        } catch (IllegalStateException ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n-        } catch (IllegalArgumentException ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-        } catch (IllegalAccessException ex) {\n-            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c33206042c09a4344e5e4a1c6b759eb6180274c": {
      "type": "Ybodychange",
      "commitMessage": "catch ConversionException and ConvertedNotFoundException in BeanWrapper\u0027s convertIfNecessary as well, in order to support constructor resolution (SPR-6563)\n",
      "commitDate": "2009/12/15 下午8:53",
      "commitName": "1c33206042c09a4344e5e4a1c6b759eb6180274c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/12/8 上午2:57",
      "commitNameOld": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.75,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (ConverterNotFoundException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (ConversionException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 865,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,209 +1,212 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n-        } catch (ConversionException ex) {\n+        } catch (ConverterNotFoundException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n-            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n-        } catch (IllegalArgumentException ex) {\n+            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n+        } catch (ConversionException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n+        } catch (IllegalArgumentException ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "61f23710ebed6d7feb1e7b477d301d952d3cde5f": {
      "type": "Ybodychange",
      "commitMessage": "relaxed warning about ambiguous setters to only be logged in case of actual write access (SPR-6399)\n",
      "commitDate": "2009/12/8 上午2:57",
      "commitName": "61f23710ebed6d7feb1e7b477d301d952d3cde5f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/12/4 上午8:34",
      "commitNameOld": "e161c93f8dd9fdf7d7685e3ae7a31de03331ae86",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (ConversionException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 858,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,209 +1,209 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            final Method writeMethod \u003d pd.getWriteMethod();\n+            final Method writeMethod \u003d (pd instanceof GenericTypeAwarePropertyDescriptor ? ((GenericTypeAwarePropertyDescriptor) pd).getWriteMethodForActualAccess() : pd.getWriteMethod());\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (ConversionException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": {
      "type": "Ybodychange",
      "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
      "commitDate": "2009/11/27 上午9:43",
      "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/10/19 上午9:06",
      "commitNameOld": "e4f50f5b7396a88471869c387f2a7fbf2c424a65",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 39.03,
      "commitsBetweenForRepo": 368,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (ConversionException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 855,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,209 +1,209 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n-                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n+                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 if (pv.isOptional()) {\n                     logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                     return;\n                 } else {\n                     PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                     throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                 }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (ConversionException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad492e906e4c9c994cad733d366ec9c30950ed92": {
      "type": "Ybodychange",
      "commitMessage": "PropertyOverrideConfigurer\u0027s \"ignoreInvalidKeys\" ignores invalid property names as well (SPR-5792)\n",
      "commitDate": "2009/9/24 下午10:40",
      "commitName": "ad492e906e4c9c994cad733d366ec9c30950ed92",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/9/18 下午10:07",
      "commitNameOld": "99753f0d1c40c6de81bd4bdcf446c2b6ebed4788",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.02,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                if (pv.isOptional()) {\n                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n                    return;\n                } else {\n                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n                }\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (ConversionException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 730,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,204 +1,209 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n-                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n-                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n+                if (pv.isOptional()) {\n+                    logger.debug(\"Ignoring optional value for property \u0027\" + actualName + \"\u0027 - property not found on bean class [\" + getRootClass().getName() + \"]\");\n+                    return;\n+                } else {\n+                    PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n+                    throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n+                }\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (ConversionException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
      "type": "Ybodychange",
      "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
      "commitDate": "2009/8/9 上午8:46",
      "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/7 上午6:31",
      "commitNameOld": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (ConversionException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 709,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,201 +1,204 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                                     public Object run() {\n                                         readMethod.setAccessible(true);\n                                         return null;\n                                     }\n                                 });\n                             } else {\n                                 readMethod.setAccessible(true);\n                             }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                 if (System.getSecurityManager() !\u003d null) {\n                     AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                         public Object run() {\n                             writeMethod.setAccessible(true);\n                             return null;\n                         }\n                     });\n                 } else {\n                     writeMethod.setAccessible(true);\n                 }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n+        } catch (ConversionException ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af8af8c633ba016eca671bc9468eba006e8834b1": {
      "type": "Ybodychange",
      "commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
      "commitDate": "2009/8/7 上午6:31",
      "commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009/8/7 上午12:34",
      "commitNameOld": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n                            if (System.getSecurityManager() !\u003d null) {\n                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                                    public Object run() {\n                                        readMethod.setAccessible(true);\n                                        return null;\n                                    }\n                                });\n                            } else {\n                                readMethod.setAccessible(true);\n                            }\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n                if (System.getSecurityManager() !\u003d null) {\n                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                        public Object run() {\n                            writeMethod.setAccessible(true);\n                            return null;\n                        }\n                    });\n                } else {\n                    writeMethod.setAccessible(true);\n                }\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 707,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,181 +1,201 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         final Method readMethod \u003d pd.getReadMethod();\n-                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n-                            readMethod.setAccessible(true);\n+                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !readMethod.isAccessible()) {\n+                            if (System.getSecurityManager() !\u003d null) {\n+                                AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\n+                                    public Object run() {\n+                                        readMethod.setAccessible(true);\n+                                        return null;\n+                                    }\n+                                });\n+                            } else {\n+                                readMethod.setAccessible(true);\n+                            }\n                         }\n                         try {\n                             if (System.getSecurityManager() !\u003d null) {\n                                 oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                                     public Object run() throws Exception {\n                                         return readMethod.invoke(object);\n                                     }\n                                 }, acc);\n                             } else {\n                                 oldValue \u003d readMethod.invoke(object);\n                             }\n                         } catch (Exception ex) {\n                             if (ex instanceof PrivilegedActionException) {\n                                 ex \u003d ((PrivilegedActionException) ex).getException();\n                             }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             final Method writeMethod \u003d pd.getWriteMethod();\n-            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n-                writeMethod.setAccessible(true);\n+            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers()) \u0026\u0026 !writeMethod.isAccessible()) {\n+                if (System.getSecurityManager() !\u003d null) {\n+                    AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\n+                        public Object run() {\n+                            writeMethod.setAccessible(true);\n+                            return null;\n+                        }\n+                    });\n+                } else {\n+                    writeMethod.setAccessible(true);\n+                }\n             }\n             final Object value \u003d valueToApply;\n             if (System.getSecurityManager() !\u003d null) {\n                 try {\n                     AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n \n                         public Object run() throws Exception {\n                             writeMethod.invoke(object, value);\n                             return null;\n                         }\n                     }, acc);\n                 } catch (PrivilegedActionException ex) {\n                     throw ex.getException();\n                 }\n             } else {\n                 writeMethod.invoke(object, value);\n             }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         } catch (Exception ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
      "type": "Ybodychange",
      "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
      "commitDate": "2009/8/7 上午12:34",
      "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009/5/12 下午4:26",
      "commitNameOld": "eca1cad7e1e78714d22681554474f887d9046632",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 86.34,
      "commitsBetweenForRepo": 550,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        final Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            if (System.getSecurityManager() !\u003d null) {\n                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                                    public Object run() throws Exception {\n                                        return readMethod.invoke(object);\n                                    }\n                                }, acc);\n                            } else {\n                                oldValue \u003d readMethod.invoke(object);\n                            }\n                        } catch (Exception ex) {\n                            if (ex instanceof PrivilegedActionException) {\n                                ex \u003d ((PrivilegedActionException) ex).getException();\n                            }\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            final Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            final Object value \u003d valueToApply;\n            if (System.getSecurityManager() !\u003d null) {\n                try {\n                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n\n                        public Object run() throws Exception {\n                            writeMethod.invoke(object, value);\n                            return null;\n                        }\n                    }, acc);\n                } catch (PrivilegedActionException ex) {\n                    throw ex.getException();\n                }\n            } else {\n                writeMethod.invoke(object, value);\n            }\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        } catch (Exception ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 696,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,151 +1,181 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IllegalStateException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n-                        Method readMethod \u003d pd.getReadMethod();\n+                        final Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n-                            oldValue \u003d readMethod.invoke(this.object);\n+                            if (System.getSecurityManager() !\u003d null) {\n+                                oldValue \u003d AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\n+                                    public Object run() throws Exception {\n+                                        return readMethod.invoke(object);\n+                                    }\n+                                }, acc);\n+                            } else {\n+                                oldValue \u003d readMethod.invoke(object);\n+                            }\n                         } catch (Exception ex) {\n+                            if (ex instanceof PrivilegedActionException) {\n+                                ex \u003d ((PrivilegedActionException) ex).getException();\n+                            }\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n-            Method writeMethod \u003d pd.getWriteMethod();\n+            final Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n-            writeMethod.invoke(this.object, valueToApply);\n+            final Object value \u003d valueToApply;\n+            if (System.getSecurityManager() !\u003d null) {\n+                try {\n+                    AccessController.doPrivileged(new PrivilegedExceptionAction\u003cObject\u003e() {\n+\n+                        public Object run() throws Exception {\n+                            writeMethod.invoke(object, value);\n+                            return null;\n+                        }\n+                    }, acc);\n+                } catch (PrivilegedActionException ex) {\n+                    throw ex.getException();\n+                }\n+            } else {\n+                writeMethod.invoke(object, value);\n+            }\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n+        } catch (Exception ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eca1cad7e1e78714d22681554474f887d9046632": {
      "type": "Ybodychange",
      "commitMessage": "Fixing build.\n",
      "commitDate": "2009/5/12 下午4:26",
      "commitName": "eca1cad7e1e78714d22681554474f887d9046632",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2009/5/11 下午10:52",
      "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IllegalStateException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new ConversionNotSupportedException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, valueToApply);\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,148 +1,151 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n+            } catch (IllegalStateException ex) {\n+                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+                throw new ConversionNotSupportedException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n                             oldValue \u003d readMethod.invoke(this.object);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n             writeMethod.invoke(this.object, valueToApply);\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalStateException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bf7a947559d8f9918cc738780bf04caf8ea46962": {
      "type": "Ybodychange",
      "commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
      "commitDate": "2009/5/11 下午10:52",
      "commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2009/4/1 上午4:34",
      "commitNameOld": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 40.76,
      "commitsBetweenForRepo": 240,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, valueToApply);\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalStateException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "",
      "diff": "@@ -1,145 +1,148 @@\n @SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey;\n             Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n                             oldValue \u003d readMethod.invoke(this.object);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n             writeMethod.invoke(this.object, valueToApply);\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+        } catch (IllegalStateException ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new ConversionNotSupportedException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dd70ca9fe3775f7459e66695d6e21e112ff9611": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "polishing\n",
      "commitDate": "2009/4/1 上午4:34",
      "commitName": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "polishing\n",
          "commitDate": "2009/4/1 上午4:34",
          "commitName": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2008/11/28 上午1:35",
          "commitNameOld": "85661c688218e09dbce629ba7880ee6d9617aa90",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 124.12,
          "commitsBetweenForRepo": 557,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, valueToApply);\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
          "functionStartLine": 651,
          "functionName": "setPropertyValue",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,144 +1,145 @@\n+@SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-        Object propValue \u003d null;\n+        Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey \u003d null;\n-            Object convertedMapValue \u003d null;\n+            Object convertedMapKey;\n+            Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n                             oldValue \u003d readMethod.invoke(this.object);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n             writeMethod.invoke(this.object, valueToApply);\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "polishing\n",
          "commitDate": "2009/4/1 上午4:34",
          "commitName": "9dd70ca9fe3775f7459e66695d6e21e112ff9611",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2008/11/28 上午1:35",
          "commitNameOld": "85661c688218e09dbce629ba7880ee6d9617aa90",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 124.12,
          "commitsBetweenForRepo": 557,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey;\n            Object convertedMapValue;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, valueToApply);\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
          "functionStartLine": 651,
          "functionName": "setPropertyValue",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "",
          "diff": "@@ -1,144 +1,145 @@\n+@SuppressWarnings(\"unchecked\")\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n-        Object propValue \u003d null;\n+        Object propValue;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n-            Object convertedMapKey \u003d null;\n-            Object convertedMapValue \u003d null;\n+            Object convertedMapKey;\n+            Object convertedMapValue;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n                             oldValue \u003d readMethod.invoke(this.object);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n             writeMethod.invoke(this.object, valueToApply);\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "b0790bf5e7b6091552ccf17a2e707ab438d129d7": {
      "type": "Ybodychange",
      "commitMessage": "Java 5 code style\n",
      "commitDate": "2008/11/27 上午8:27",
      "commitName": "b0790bf5e7b6091552ccf17a2e707ab438d129d7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/11/20 上午10:10",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue \u003d null;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d null;\n            Object convertedMapValue \u003d null;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, valueToApply);\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 650,
      "functionName": "setPropertyValue",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,144 +1,144 @@\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue \u003d null;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n             Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey \u003d null;\n             Object convertedMapValue \u003d null;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n-                            oldValue \u003d readMethod.invoke(this.object, new Object[0]);\n+                            oldValue \u003d readMethod.invoke(this.object);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n-                pv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n+                pv.getOriginalPropertyValue().conversionNecessary \u003d (valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n-            writeMethod.invoke(this.object, new Object[] { valueToApply });\n+            writeMethod.invoke(this.object, valueToApply);\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008/11/20 上午10:10",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/10/28 上午7:30",
      "commitNameOld": "c8e5aa07a543d8213f96194fea59fb9a1cc7e0e3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 23.11,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "actualSource": "private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue \u003d null;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d null;\n            Object convertedMapValue \u003d null;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object, new Object[0]);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, new Object[] { valueToApply });\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 650,
      "functionName": "setPropertyValue",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,151 +1,144 @@\n private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n     String propertyName \u003d tokens.canonicalName;\n     String actualName \u003d tokens.actualName;\n     if (tokens.keys !\u003d null) {\n         PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n         getterTokens.canonicalName \u003d tokens.canonicalName;\n         getterTokens.actualName \u003d tokens.actualName;\n         getterTokens.keys \u003d new String[tokens.keys.length - 1];\n         System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n         Object propValue \u003d null;\n         try {\n             propValue \u003d getPropertyValue(getterTokens);\n         } catch (NotReadablePropertyException ex) {\n             throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n         }\n         String key \u003d tokens.keys[tokens.keys.length - 1];\n         if (propValue \u003d\u003d null) {\n             throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n         } else if (propValue.getClass().isArray()) {\n             Class requiredType \u003d propValue.getClass().getComponentType();\n             int arrayIndex \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             try {\n                 if (isExtractOldValueForEditor()) {\n                     oldValue \u003d Array.get(propValue, arrayIndex);\n                 }\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 Array.set(propValue, Integer.parseInt(key), convertedValue);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             } catch (IndexOutOfBoundsException ex) {\n                 throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n             }\n         } else if (propValue instanceof List) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class requiredType \u003d null;\n-            if (JdkVersion.isAtLeastJava15()) {\n-                requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n-            }\n+            Class requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n             List list \u003d (List) propValue;\n             int index \u003d Integer.parseInt(key);\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                 oldValue \u003d list.get(index);\n             }\n             try {\n                 Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                 if (index \u003c list.size()) {\n                     list.set(index, convertedValue);\n                 } else if (index \u003e\u003d list.size()) {\n                     for (int i \u003d list.size(); i \u003c index; i++) {\n                         try {\n                             list.add(null);\n                         } catch (NullPointerException ex) {\n                             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                         }\n                     }\n                     list.add(convertedValue);\n                 }\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, requiredType, ex);\n             }\n         } else if (propValue instanceof Map) {\n             PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n-            Class mapKeyType \u003d null;\n-            Class mapValueType \u003d null;\n-            if (JdkVersion.isAtLeastJava15()) {\n-                mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n-                mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n-            }\n+            Class mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n+            Class mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n             Map map \u003d (Map) propValue;\n             Object convertedMapKey \u003d null;\n             Object convertedMapValue \u003d null;\n             try {\n                 convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                 throw new TypeMismatchException(pce, mapKeyType, ex);\n             }\n             Object oldValue \u003d null;\n             if (isExtractOldValueForEditor()) {\n                 oldValue \u003d map.get(convertedMapKey);\n             }\n             try {\n                 convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n             } catch (IllegalArgumentException ex) {\n                 PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                 throw new TypeMismatchException(pce, mapValueType, ex);\n             }\n             map.put(convertedMapKey, convertedMapValue);\n         } else {\n             throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n         }\n     } else {\n         PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n         if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n             pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n             if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                 PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                 throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n             }\n             pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n         }\n         Object oldValue \u003d null;\n         try {\n             Object originalValue \u003d pv.getValue();\n             Object valueToApply \u003d originalValue;\n             if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                 if (pv.isConverted()) {\n                     valueToApply \u003d pv.getConvertedValue();\n                 } else {\n                     if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                         Method readMethod \u003d pd.getReadMethod();\n                         if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                             readMethod.setAccessible(true);\n                         }\n                         try {\n                             oldValue \u003d readMethod.invoke(this.object, new Object[0]);\n                         } catch (Exception ex) {\n                             if (logger.isDebugEnabled()) {\n                                 logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                             }\n                         }\n                     }\n                     valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                 }\n                 pv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n             }\n             Method writeMethod \u003d pd.getWriteMethod();\n             if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                 writeMethod.setAccessible(true);\n             }\n             writeMethod.invoke(this.object, new Object[] { valueToApply });\n         } catch (InvocationTargetException ex) {\n             PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             if (ex.getTargetException() instanceof ClassCastException) {\n                 throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n             } else {\n                 throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n             }\n         } catch (IllegalArgumentException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n         } catch (IllegalAccessException ex) {\n             PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n             throw new MethodInvocationException(pce, ex);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008/10/23 上午12:13",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,151 @@\n+private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n+    String propertyName \u003d tokens.canonicalName;\n+    String actualName \u003d tokens.actualName;\n+    if (tokens.keys !\u003d null) {\n+        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n+        getterTokens.canonicalName \u003d tokens.canonicalName;\n+        getterTokens.actualName \u003d tokens.actualName;\n+        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n+        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n+        Object propValue \u003d null;\n+        try {\n+            propValue \u003d getPropertyValue(getterTokens);\n+        } catch (NotReadablePropertyException ex) {\n+            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n+        }\n+        String key \u003d tokens.keys[tokens.keys.length - 1];\n+        if (propValue \u003d\u003d null) {\n+            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n+        } else if (propValue.getClass().isArray()) {\n+            Class requiredType \u003d propValue.getClass().getComponentType();\n+            int arrayIndex \u003d Integer.parseInt(key);\n+            Object oldValue \u003d null;\n+            try {\n+                if (isExtractOldValueForEditor()) {\n+                    oldValue \u003d Array.get(propValue, arrayIndex);\n+                }\n+                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+                Array.set(propValue, Integer.parseInt(key), convertedValue);\n+            } catch (IllegalArgumentException ex) {\n+                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+                throw new TypeMismatchException(pce, requiredType, ex);\n+            } catch (IndexOutOfBoundsException ex) {\n+                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n+            }\n+        } else if (propValue instanceof List) {\n+            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            Class requiredType \u003d null;\n+            if (JdkVersion.isAtLeastJava15()) {\n+                requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n+            }\n+            List list \u003d (List) propValue;\n+            int index \u003d Integer.parseInt(key);\n+            Object oldValue \u003d null;\n+            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n+                oldValue \u003d list.get(index);\n+            }\n+            try {\n+                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n+                if (index \u003c list.size()) {\n+                    list.set(index, convertedValue);\n+                } else if (index \u003e\u003d list.size()) {\n+                    for (int i \u003d list.size(); i \u003c index; i++) {\n+                        try {\n+                            list.add(null);\n+                        } catch (NullPointerException ex) {\n+                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n+                        }\n+                    }\n+                    list.add(convertedValue);\n+                }\n+            } catch (IllegalArgumentException ex) {\n+                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+                throw new TypeMismatchException(pce, requiredType, ex);\n+            }\n+        } else if (propValue instanceof Map) {\n+            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            Class mapKeyType \u003d null;\n+            Class mapValueType \u003d null;\n+            if (JdkVersion.isAtLeastJava15()) {\n+                mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n+                mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n+            }\n+            Map map \u003d (Map) propValue;\n+            Object convertedMapKey \u003d null;\n+            Object convertedMapValue \u003d null;\n+            try {\n+                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n+            } catch (IllegalArgumentException ex) {\n+                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n+                throw new TypeMismatchException(pce, mapKeyType, ex);\n+            }\n+            Object oldValue \u003d null;\n+            if (isExtractOldValueForEditor()) {\n+                oldValue \u003d map.get(convertedMapKey);\n+            }\n+            try {\n+                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n+            } catch (IllegalArgumentException ex) {\n+                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+                throw new TypeMismatchException(pce, mapValueType, ex);\n+            }\n+            map.put(convertedMapKey, convertedMapValue);\n+        } else {\n+            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n+        }\n+    } else {\n+        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n+        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n+            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n+            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n+                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n+                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n+            }\n+            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n+        }\n+        Object oldValue \u003d null;\n+        try {\n+            Object originalValue \u003d pv.getValue();\n+            Object valueToApply \u003d originalValue;\n+            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n+                if (pv.isConverted()) {\n+                    valueToApply \u003d pv.getConvertedValue();\n+                } else {\n+                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n+                        Method readMethod \u003d pd.getReadMethod();\n+                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n+                            readMethod.setAccessible(true);\n+                        }\n+                        try {\n+                            oldValue \u003d readMethod.invoke(this.object, new Object[0]);\n+                        } catch (Exception ex) {\n+                            if (logger.isDebugEnabled()) {\n+                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n+                            }\n+                        }\n+                    }\n+                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n+                }\n+                pv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n+            }\n+            Method writeMethod \u003d pd.getWriteMethod();\n+            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n+                writeMethod.setAccessible(true);\n+            }\n+            writeMethod.invoke(this.object, new Object[] { valueToApply });\n+        } catch (InvocationTargetException ex) {\n+            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            if (ex.getTargetException() instanceof ClassCastException) {\n+                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n+            } else {\n+                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n+            }\n+        } catch (IllegalArgumentException ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n+        } catch (IllegalAccessException ex) {\n+            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n+            throw new MethodInvocationException(pce, ex);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {\n    String propertyName \u003d tokens.canonicalName;\n    String actualName \u003d tokens.actualName;\n    if (tokens.keys !\u003d null) {\n        PropertyTokenHolder getterTokens \u003d new PropertyTokenHolder();\n        getterTokens.canonicalName \u003d tokens.canonicalName;\n        getterTokens.actualName \u003d tokens.actualName;\n        getterTokens.keys \u003d new String[tokens.keys.length - 1];\n        System.arraycopy(tokens.keys, 0, getterTokens.keys, 0, tokens.keys.length - 1);\n        Object propValue \u003d null;\n        try {\n            propValue \u003d getPropertyValue(getterTokens);\n        } catch (NotReadablePropertyException ex) {\n            throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027\", ex);\n        }\n        String key \u003d tokens.keys[tokens.keys.length - 1];\n        if (propValue \u003d\u003d null) {\n            throw new NullValueInNestedPathException(getRootClass(), this.nestedPath + propertyName, \"Cannot access indexed value in property referenced \" + \"in indexed property path \u0027\" + propertyName + \"\u0027: returned null\");\n        } else if (propValue.getClass().isArray()) {\n            Class requiredType \u003d propValue.getClass().getComponentType();\n            int arrayIndex \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            try {\n                if (isExtractOldValueForEditor()) {\n                    oldValue \u003d Array.get(propValue, arrayIndex);\n                }\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                Array.set(propValue, Integer.parseInt(key), convertedValue);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            } catch (IndexOutOfBoundsException ex) {\n                throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Invalid array index in property path \u0027\" + propertyName + \"\u0027\", ex);\n            }\n        } else if (propValue instanceof List) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class requiredType \u003d null;\n            if (JdkVersion.isAtLeastJava15()) {\n                requiredType \u003d GenericCollectionTypeResolver.getCollectionReturnType(pd.getReadMethod(), tokens.keys.length);\n            }\n            List list \u003d (List) propValue;\n            int index \u003d Integer.parseInt(key);\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor() \u0026\u0026 index \u003c list.size()) {\n                oldValue \u003d list.get(index);\n            }\n            try {\n                Object convertedValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), requiredType);\n                if (index \u003c list.size()) {\n                    list.set(index, convertedValue);\n                } else if (index \u003e\u003d list.size()) {\n                    for (int i \u003d list.size(); i \u003c index; i++) {\n                        try {\n                            list.add(null);\n                        } catch (NullPointerException ex) {\n                            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Cannot set element with index \" + index + \" in List of size \" + list.size() + \", accessed using property path \u0027\" + propertyName + \"\u0027: List does not support filling up gaps with null elements\");\n                        }\n                    }\n                    list.add(convertedValue);\n                }\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, requiredType, ex);\n            }\n        } else if (propValue instanceof Map) {\n            PropertyDescriptor pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            Class mapKeyType \u003d null;\n            Class mapValueType \u003d null;\n            if (JdkVersion.isAtLeastJava15()) {\n                mapKeyType \u003d GenericCollectionTypeResolver.getMapKeyReturnType(pd.getReadMethod(), tokens.keys.length);\n                mapValueType \u003d GenericCollectionTypeResolver.getMapValueReturnType(pd.getReadMethod(), tokens.keys.length);\n            }\n            Map map \u003d (Map) propValue;\n            Object convertedMapKey \u003d null;\n            Object convertedMapValue \u003d null;\n            try {\n                convertedMapKey \u003d this.typeConverterDelegate.convertIfNecessary(key, mapKeyType);\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, null, pv.getValue());\n                throw new TypeMismatchException(pce, mapKeyType, ex);\n            }\n            Object oldValue \u003d null;\n            if (isExtractOldValueForEditor()) {\n                oldValue \u003d map.get(convertedMapKey);\n            }\n            try {\n                convertedMapValue \u003d this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, pv.getValue(), mapValueType, null, new MethodParameter(pd.getReadMethod(), -1, tokens.keys.length + 1));\n            } catch (IllegalArgumentException ex) {\n                PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n                throw new TypeMismatchException(pce, mapValueType, ex);\n            }\n            map.put(convertedMapKey, convertedMapValue);\n        } else {\n            throw new InvalidPropertyException(getRootClass(), this.nestedPath + propertyName, \"Property referenced in indexed property path \u0027\" + propertyName + \"\u0027 is neither an array nor a List nor a Map; returned value was [\" + pv.getValue() + \"]\");\n        }\n    } else {\n        PropertyDescriptor pd \u003d pv.resolvedDescriptor;\n        if (pd \u003d\u003d null || !pd.getWriteMethod().getDeclaringClass().isInstance(this.object)) {\n            pd \u003d getCachedIntrospectionResults().getPropertyDescriptor(actualName);\n            if (pd \u003d\u003d null || pd.getWriteMethod() \u003d\u003d null) {\n                PropertyMatches matches \u003d PropertyMatches.forProperty(propertyName, getRootClass());\n                throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName, matches.buildErrorMessage(), matches.getPossibleMatches());\n            }\n            pv.getOriginalPropertyValue().resolvedDescriptor \u003d pd;\n        }\n        Object oldValue \u003d null;\n        try {\n            Object originalValue \u003d pv.getValue();\n            Object valueToApply \u003d originalValue;\n            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {\n                if (pv.isConverted()) {\n                    valueToApply \u003d pv.getConvertedValue();\n                } else {\n                    if (isExtractOldValueForEditor() \u0026\u0026 pd.getReadMethod() !\u003d null) {\n                        Method readMethod \u003d pd.getReadMethod();\n                        if (!Modifier.isPublic(readMethod.getDeclaringClass().getModifiers())) {\n                            readMethod.setAccessible(true);\n                        }\n                        try {\n                            oldValue \u003d readMethod.invoke(this.object, new Object[0]);\n                        } catch (Exception ex) {\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Could not read previous value of property \u0027\" + this.nestedPath + propertyName + \"\u0027\", ex);\n                            }\n                        }\n                    }\n                    valueToApply \u003d this.typeConverterDelegate.convertIfNecessary(oldValue, originalValue, pd);\n                }\n                pv.getOriginalPropertyValue().conversionNecessary \u003d Boolean.valueOf(valueToApply !\u003d originalValue);\n            }\n            Method writeMethod \u003d pd.getWriteMethod();\n            if (!Modifier.isPublic(writeMethod.getDeclaringClass().getModifiers())) {\n                writeMethod.setAccessible(true);\n            }\n            writeMethod.invoke(this.object, new Object[] { valueToApply });\n        } catch (InvocationTargetException ex) {\n            PropertyChangeEvent propertyChangeEvent \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            if (ex.getTargetException() instanceof ClassCastException) {\n                throw new TypeMismatchException(propertyChangeEvent, pd.getPropertyType(), ex.getTargetException());\n            } else {\n                throw new MethodInvocationException(propertyChangeEvent, ex.getTargetException());\n            }\n        } catch (IllegalArgumentException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new TypeMismatchException(pce, pd.getPropertyType(), ex);\n        } catch (IllegalAccessException ex) {\n            PropertyChangeEvent pce \u003d new PropertyChangeEvent(this.rootObject, this.nestedPath + propertyName, oldValue, pv.getValue());\n            throw new MethodInvocationException(pce, ex);\n        }\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/BeanWrapperImpl.java",
      "functionStartLine": 658,
      "functionName": "setPropertyValue",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}