{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "LocaleUtils.java",
  "functionName": "toLocale",
  "functionId": "toLocale___str-String(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
  "functionStartLine": 90,
  "functionEndLine": 127,
  "numCommitsSeen": 56,
  "timeTaken": 2526,
  "changeHistory": [
    "d3146a545612422d3f8078f10afa00342b327199",
    "d547412bbd2a1ca56769a2bfa13b7ed9547310ca",
    "3c89994355f3574078c832b2dcacba0e65e87ed1",
    "4bd982d1a1df87724682c17c39bf27b5cbe389be",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "15b80753a6e8f481ea5029bc278e362994cb7bee",
    "71966110f7918a6366f97ded3bab25c7b5864cb8",
    "f7e5f2c877a07c31010db8554125e77db6a605cc",
    "96c30e248d6d27a1df8e26be14aa10c633168cdb",
    "f27c439c8d8818e61c11019d1d58b311a831c301",
    "8ea0c0284810bd6ec00f608be31abd20dbd4b72b",
    "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15",
    "c99a4a3ee24758ae6e2271752d91b58c116e81e9",
    "8303f1efa3141509441c9268f292941e3b161355",
    "d77fe491fd4e5bed5319379c23893d92ed7fc9da",
    "dcde57852a97a9ac8021d2440b3de5be4870ecf6",
    "4d46f014fb8ee44386feb5fec52509f35d0e36ea",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "75d931a3264b73caa9cdd7d3373375cc33008ddf",
    "cfd9081647e732143fbdc2db99681afa5b403a0f",
    "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
    "04e1537d3c41646fdb56b60fae70a630ae177796"
  ],
  "changeHistoryShort": {
    "d3146a545612422d3f8078f10afa00342b327199": "Ybodychange",
    "d547412bbd2a1ca56769a2bfa13b7ed9547310ca": "Ybodychange",
    "3c89994355f3574078c832b2dcacba0e65e87ed1": "Ybodychange",
    "4bd982d1a1df87724682c17c39bf27b5cbe389be": "Ymultichange(Ybodychange,Ydocchange)",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "15b80753a6e8f481ea5029bc278e362994cb7bee": "Ybodychange",
    "71966110f7918a6366f97ded3bab25c7b5864cb8": "Ybodychange",
    "f7e5f2c877a07c31010db8554125e77db6a605cc": "Ybodychange",
    "96c30e248d6d27a1df8e26be14aa10c633168cdb": "Ybodychange",
    "f27c439c8d8818e61c11019d1d58b311a831c301": "Ybodychange",
    "8ea0c0284810bd6ec00f608be31abd20dbd4b72b": "Ybodychange",
    "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15": "Ymultichange(Ybodychange,Ydocchange)",
    "c99a4a3ee24758ae6e2271752d91b58c116e81e9": "Ybodychange",
    "8303f1efa3141509441c9268f292941e3b161355": "Ydocchange",
    "d77fe491fd4e5bed5319379c23893d92ed7fc9da": "Ybodychange",
    "dcde57852a97a9ac8021d2440b3de5be4870ecf6": "Ybodychange",
    "4d46f014fb8ee44386feb5fec52509f35d0e36ea": "Ymultichange(Ybodychange,Yparametermetachange)",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "75d931a3264b73caa9cdd7d3373375cc33008ddf": "Ybodychange",
    "cfd9081647e732143fbdc2db99681afa5b403a0f": "Ydocchange",
    "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4": "Ymultichange(Ybodychange,Ydocchange)",
    "04e1537d3c41646fdb56b60fae70a630ae177796": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d3146a545612422d3f8078f10afa00342b327199": {
      "type": "Ybodychange",
      "commitMessage": "Extract some helper methods to make the code better readable\n",
      "commitDate": "2017/4/17 下午6:29",
      "commitName": "d3146a545612422d3f8078f10afa00342b327199",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/4/17 下午6:09",
      "commitNameOld": "d547412bbd2a1ca56769a2bfa13b7ed9547310ca",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    return parseLocale(str);\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,37 +1,37 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n-    return parseLocale(str, len);\n+    return parseLocale(str);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d547412bbd2a1ca56769a2bfa13b7ed9547310ca": {
      "type": "Ybodychange",
      "commitMessage": "Extract method for parsing locales from string\n",
      "commitDate": "2017/4/17 下午6:09",
      "commitName": "d547412bbd2a1ca56769a2bfa13b7ed9547310ca",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/4/17 下午6:01",
      "commitNameOld": "3c89994355f3574078c832b2dcacba0e65e87ed1",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    return parseLocale(str, len);\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,57 +1,37 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n-    final String[] segments \u003d str.split(\"_\", -1);\n-    final int segmentCount \u003d segments.length - 1;\n-    final String country \u003d segments[0];\n-    switch(segmentCount) {\n-        case 0:\n-            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n-                return new Locale(str);\n-            }\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        case 1:\n-            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) || (segments[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(segments[1]))) {\n-                return new Locale(country, segments[1]);\n-            }\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        case 2:\n-            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 0 || segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) \u0026\u0026 segments[2].length() \u003e 0) {\n-                return new Locale(country, segments[1], segments[2]);\n-            }\n-        default:\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n+    return parseLocale(str, len);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3c89994355f3574078c832b2dcacba0e65e87ed1": {
      "type": "Ybodychange",
      "commitMessage": "Better local variable names\n",
      "commitDate": "2017/4/17 下午6:01",
      "commitName": "3c89994355f3574078c832b2dcacba0e65e87ed1",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2017/2/22 上午4:13",
      "commitNameOld": "4bd982d1a1df87724682c17c39bf27b5cbe389be",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 54.58,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    final String[] segments \u003d str.split(\"_\", -1);\n    final int segmentCount \u003d segments.length - 1;\n    final String country \u003d segments[0];\n    switch(segmentCount) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) || (segments[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(segments[1]))) {\n                return new Locale(country, segments[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 0 || segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) \u0026\u0026 segments[2].length() \u003e 0) {\n                return new Locale(country, segments[1], segments[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,56 +1,57 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n-    final String[] split \u003d str.split(\"_\", -1);\n-    final int occurrences \u003d split.length - 1;\n-    switch(occurrences) {\n+    final String[] segments \u003d str.split(\"_\", -1);\n+    final int segmentCount \u003d segments.length - 1;\n+    final String country \u003d segments[0];\n+    switch(segmentCount) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n-            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) || (split[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(split[1]))) {\n-                return new Locale(split[0], split[1]);\n+            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) || (segments[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(segments[1]))) {\n+                return new Locale(country, segments[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n-            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n-                return new Locale(split[0], split[1], split[2]);\n+            if (StringUtils.isAllLowerCase(country) \u0026\u0026 (country.length() \u003d\u003d 2 || country.length() \u003d\u003d 3) \u0026\u0026 (segments[1].length() \u003d\u003d 0 || segments[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(segments[1])) \u0026\u0026 segments[2].length() \u003e 0) {\n+                return new Locale(country, segments[1], segments[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4bd982d1a1df87724682c17c39bf27b5cbe389be": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-1312: LocaleUtils#toLocale does not support language followed by UN M.49 numeric-3 area code (closes #239)\n",
      "commitDate": "2017/2/22 上午4:13",
      "commitName": "4bd982d1a1df87724682c17c39bf27b5cbe389be",
      "commitAuthor": "pascalschumacher",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1312: LocaleUtils#toLocale does not support language followed by UN M.49 numeric-3 area code (closes #239)\n",
          "commitDate": "2017/2/22 上午4:13",
          "commitName": "4bd982d1a1df87724682c17c39bf27b5cbe389be",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:52",
          "commitNameOld": "4f82195afdc4279c05826fc20f8642bfdaaafec3",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 121.1,
          "commitsBetweenForRepo": 127,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) || (split[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(split[1]))) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 90,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
          "diff": "@@ -1,56 +1,56 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n-            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n+            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) || (split[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(split[1]))) {\n                 return new Locale(split[0], split[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-1312: LocaleUtils#toLocale does not support language followed by UN M.49 numeric-3 area code (closes #239)\n",
          "commitDate": "2017/2/22 上午4:13",
          "commitName": "4bd982d1a1df87724682c17c39bf27b5cbe389be",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2016/10/24 上午1:52",
          "commitNameOld": "4f82195afdc4279c05826fc20f8642bfdaaafec3",
          "commitAuthorOld": "Gary Gregory",
          "daysBetweenCommits": 121.1,
          "commitsBetweenForRepo": 127,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) || (split[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(split[1]))) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 90,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
          "diff": "@@ -1,56 +1,56 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n-            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n+            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) || (split[1].length() \u003d\u003d 3 \u0026\u0026 StringUtils.isNumeric(split[1]))) {\n                 return new Locale(split[0], split[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
            "newValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_001\")     \u003d new Locale(\"en\", \"001\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n"
          }
        }
      ]
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016/9/19 下午7:56",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016/4/14 上午4:57",
      "commitNameOld": "15b80753a6e8f481ea5029bc278e362994cb7bee",
      "commitAuthorOld": "ggregory",
      "daysBetweenCommits": 158.62,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 89,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,56 +1,56 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                 return new Locale(split[0], split[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n-            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n+            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "15b80753a6e8f481ea5029bc278e362994cb7bee": {
      "type": "Ybodychange",
      "commitMessage": "Reuse",
      "commitDate": "2016/4/14 上午4:57",
      "commitName": "15b80753a6e8f481ea5029bc278e362994cb7bee",
      "commitAuthor": "ggregory",
      "commitDateOld": "2015/5/6 上午3:12",
      "commitNameOld": "740c0f95fbd99cb7c07bcf7c54bc077c3ab27bd1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 344.07,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 89,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,56 +1,56 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n-        return new Locale(\"\", \"\");\n+        return new Locale(StringUtils.EMPTY, StringUtils.EMPTY);\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n-            return new Locale(\"\", str.substring(1, 3));\n+            return new Locale(StringUtils.EMPTY, str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n+        return new Locale(StringUtils.EMPTY, str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                 return new Locale(split[0], split[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71966110f7918a6366f97ded3bab25c7b5864cb8": {
      "type": "Ybodychange",
      "commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606089 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/6/27 下午9:18",
      "commitName": "71966110f7918a6366f97ded3bab25c7b5864cb8",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014/6/27 下午8:36",
      "commitNameOld": "f7e5f2c877a07c31010db8554125e77db6a605cc",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,57 +1,56 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n-            } else {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 1:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                 return new Locale(split[0], split[1]);\n             }\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f7e5f2c877a07c31010db8554125e77db6a605cc": {
      "type": "Ybodychange",
      "commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606066 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/6/27 下午8:36",
      "commitName": "f7e5f2c877a07c31010db8554125e77db6a605cc",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014/6/27 下午8:22",
      "commitNameOld": "96c30e248d6d27a1df8e26be14aa10c633168cdb",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            }\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,58 +1,57 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n     final String[] split \u003d str.split(\"_\", -1);\n     final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             } else {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n         case 1:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                 return new Locale(split[0], split[1]);\n-            } else {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "96c30e248d6d27a1df8e26be14aa10c633168cdb": {
      "type": "Ybodychange",
      "commitMessage": "Use final consistently. \n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1606051 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/6/27 下午8:22",
      "commitName": "96c30e248d6d27a1df8e26be14aa10c633168cdb",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2014/2/6 下午9:31",
      "commitNameOld": "f27c439c8d8818e61c11019d1d58b311a831c301",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 140.95,
      "commitsBetweenForRepo": 169,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final String[] split \u003d str.split(\"_\", -1);\n    final int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,58 +1,58 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n-    String[] split \u003d str.split(\"_\", -1);\n-    int occurrences \u003d split.length - 1;\n+    final String[] split \u003d str.split(\"_\", -1);\n+    final int occurrences \u003d split.length - 1;\n     switch(occurrences) {\n         case 0:\n             if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                 return new Locale(str);\n             } else {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n         case 1:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                 return new Locale(split[0], split[1]);\n             } else {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n         case 2:\n             if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                 return new Locale(split[0], split[1], split[2]);\n             }\n         default:\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f27c439c8d8818e61c11019d1d58b311a831c301": {
      "type": "Ybodychange",
      "commitMessage": "Fall through is intentional\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1565235 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/2/6 下午9:31",
      "commitName": "f27c439c8d8818e61c11019d1d58b311a831c301",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/1/11 下午9:06",
      "commitNameOld": "8ea0c0284810bd6ec00f608be31abd20dbd4b72b",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 26.02,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    String[] split \u003d str.split(\"_\", -1);\n    int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "",
      "extendedDetails": {}
    },
    "8ea0c0284810bd6ec00f608be31abd20dbd4b72b": {
      "type": "Ybodychange",
      "commitMessage": "LANG-915: Wrong locale handling in LocaleUtils.toLocale(). Thanks to Sergio Fernández\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1557378 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/1/11 下午9:06",
      "commitName": "8ea0c0284810bd6ec00f608be31abd20dbd4b72b",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2014/1/3 下午6:26",
      "commitNameOld": "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    String[] split \u003d str.split(\"_\", -1);\n    int occurrences \u003d split.length - 1;\n    switch(occurrences) {\n        case 0:\n            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n                return new Locale(str);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 1:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n                return new Locale(split[0], split[1]);\n            } else {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n        case 2:\n            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n                return new Locale(split[0], split[1], split[2]);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 90,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,67 +1,58 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n         return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n-    final char ch1 \u003d str.charAt(1);\n-    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    String[] split \u003d str.split(\"_\", -1);\n+    int occurrences \u003d split.length - 1;\n+    switch(occurrences) {\n+        case 0:\n+            if (StringUtils.isAllLowerCase(str) \u0026\u0026 (len \u003d\u003d 2 || len \u003d\u003d 3)) {\n+                return new Locale(str);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+        case 1:\n+            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1])) {\n+                return new Locale(split[0], split[1]);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+        case 2:\n+            if (StringUtils.isAllLowerCase(split[0]) \u0026\u0026 (split[0].length() \u003d\u003d 2 || split[0].length() \u003d\u003d 3) \u0026\u0026 (split[1].length() \u003d\u003d 0 || (split[1].length() \u003d\u003d 2 \u0026\u0026 StringUtils.isAllUpperCase(split[1]))) \u0026\u0026 split[2].length() \u003e 0) {\n+                return new Locale(split[0], split[1], split[2]);\n+            }\n+        default:\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    if (len \u003d\u003d 2) {\n-        return new Locale(str);\n-    }\n-    if (len \u003c 5) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    if (str.charAt(2) !\u003d \u0027_\u0027) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    final char ch3 \u003d str.charAt(3);\n-    if (ch3 \u003d\u003d \u0027_\u0027) {\n-        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n-    }\n-    final char ch4 \u003d str.charAt(4);\n-    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    if (len \u003d\u003d 5) {\n-        return new Locale(str.substring(0, 2), str.substring(3, 5));\n-    }\n-    if (len \u003c 7) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    if (str.charAt(5) !\u003d \u0027_\u0027) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LANG-941: Test failure in LocaleUtilsTest when building with JDK 8\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1555043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/1/3 下午6:26",
      "commitName": "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15",
      "commitAuthor": "Benedikt Ritter",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-941: Test failure in LocaleUtilsTest when building with JDK 8\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1555043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014/1/3 下午6:26",
          "commitName": "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15",
          "commitAuthor": "Benedikt Ritter",
          "commitDateOld": "2014/1/3 下午5:43",
          "commitNameOld": "c99a4a3ee24758ae6e2271752d91b58c116e81e9",
          "commitAuthorOld": "Benedikt Ritter",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final char ch1 \u003d str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str);\n    }\n    if (len \u003c 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 \u003d str.charAt(3);\n    if (ch3 \u003d\u003d \u0027_\u0027) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 \u003d str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 90,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
          "diff": "@@ -1,67 +1,67 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n-        throw new IllegalArgumentException(\"Cannot create locale from empty string\");\n+        return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n     final char ch1 \u003d str.charAt(1);\n     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 2) {\n         return new Locale(str);\n     }\n     if (len \u003c 5) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(2) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch3 \u003d str.charAt(3);\n     if (ch3 \u003d\u003d \u0027_\u0027) {\n         return new Locale(str.substring(0, 2), \"\", str.substring(4));\n     }\n     final char ch4 \u003d str.charAt(4);\n     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 5) {\n         return new Locale(str.substring(0, 2), str.substring(3, 5));\n     }\n     if (len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(5) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-941: Test failure in LocaleUtilsTest when building with JDK 8\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1555043 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2014/1/3 下午6:26",
          "commitName": "24b6a468ae6ba138c4f4a1f4793fed4e73bf3c15",
          "commitAuthor": "Benedikt Ritter",
          "commitDateOld": "2014/1/3 下午5:43",
          "commitNameOld": "c99a4a3ee24758ae6e2271752d91b58c116e81e9",
          "commitAuthorOld": "Benedikt Ritter",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new Locale(\"\", \"\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final char ch1 \u003d str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str);\n    }\n    if (len \u003c 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 \u003d str.charAt(3);\n    if (ch3 \u003d\u003d \u0027_\u0027) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 \u003d str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 90,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
          "diff": "@@ -1,67 +1,67 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.isEmpty()) {\n-        throw new IllegalArgumentException(\"Cannot create locale from empty string\");\n+        return new Locale(\"\", \"\");\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n     final char ch1 \u003d str.charAt(1);\n     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 2) {\n         return new Locale(str);\n     }\n     if (len \u003c 5) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(2) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch3 \u003d str.charAt(3);\n     if (ch3 \u003d\u003d \u0027_\u0027) {\n         return new Locale(str.substring(0, 2), \"\", str.substring(4));\n     }\n     final char ch4 \u003d str.charAt(4);\n     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 5) {\n         return new Locale(str.substring(0, 2), str.substring(3, 5));\n     }\n     if (len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(5) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
            "newValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"\")           \u003d new Locale(\"\", \"\")\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n"
          }
        }
      ]
    },
    "c99a4a3ee24758ae6e2271752d91b58c116e81e9": {
      "type": "Ybodychange",
      "commitMessage": "LANG-941: Test failure in LocaleUtilsTest when building with JDK 8 - make problem more explicit by checking for empty strings\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1555040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/1/3 下午5:43",
      "commitName": "c99a4a3ee24758ae6e2271752d91b58c116e81e9",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2013/12/19 上午5:58",
      "commitNameOld": "8303f1efa3141509441c9268f292941e3b161355",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 15.49,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        throw new IllegalArgumentException(\"Cannot create locale from empty string\");\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final char ch1 \u003d str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str);\n    }\n    if (len \u003c 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 \u003d str.charAt(3);\n    if (ch3 \u003d\u003d \u0027_\u0027) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 \u003d str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 89,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "@@ -1,64 +1,67 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n+    if (str.isEmpty()) {\n+        throw new IllegalArgumentException(\"Cannot create locale from empty string\");\n+    }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     }\n     final char ch1 \u003d str.charAt(1);\n     if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 2) {\n         return new Locale(str);\n     }\n     if (len \u003c 5) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(2) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch3 \u003d str.charAt(3);\n     if (ch3 \u003d\u003d \u0027_\u0027) {\n         return new Locale(str.substring(0, 2), \"\", str.substring(4));\n     }\n     final char ch4 \u003d str.charAt(4);\n     if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 5) {\n         return new Locale(str.substring(0, 2), str.substring(3, 5));\n     }\n     if (len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (str.charAt(5) !\u003d \u0027_\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8303f1efa3141509441c9268f292941e3b161355": {
      "type": "Ydocchange",
      "commitMessage": "Add @see in Javadoc.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1552123 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/12/19 上午5:58",
      "commitName": "8303f1efa3141509441c9268f292941e3b161355",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/6/5 上午11:37",
      "commitNameOld": "d77fe491fd4e5bed5319379c23893d92ed7fc9da",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 196.76,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final char ch1 \u003d str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str);\n    }\n    if (len \u003c 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 \u003d str.charAt(3);\n    if (ch3 \u003d\u003d \u0027_\u0027) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 \u003d str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 89,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
        "newValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n@see Locale#forLanguageTag(String)\n"
      }
    },
    "d77fe491fd4e5bed5319379c23893d92ed7fc9da": {
      "type": "Ybodychange",
      "commitMessage": "Statement unnecessarily nested within else clause.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1489693 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/6/5 上午11:37",
      "commitName": "d77fe491fd4e5bed5319379c23893d92ed7fc9da",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/5/31 上午6:12",
      "commitNameOld": "dcde57852a97a9ac8021d2440b3de5be4870ecf6",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 5.23,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    }\n    final char ch1 \u003d str.charAt(1);\n    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str);\n    }\n    if (len \u003c 5) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(2) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch3 \u003d str.charAt(3);\n    if (ch3 \u003d\u003d \u0027_\u0027) {\n        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n    }\n    final char ch4 \u003d str.charAt(4);\n    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 5) {\n        return new Locale(str.substring(0, 2), str.substring(3, 5));\n    }\n    if (len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.charAt(5) !\u003d \u0027_\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 88,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "@@ -1,65 +1,64 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     if (str.contains(\"#\")) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n-    } else {\n-        final char ch1 \u003d str.charAt(1);\n-        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        if (len \u003d\u003d 2) {\n-            return new Locale(str);\n-        }\n-        if (len \u003c 5) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        if (str.charAt(2) !\u003d \u0027_\u0027) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        final char ch3 \u003d str.charAt(3);\n-        if (ch3 \u003d\u003d \u0027_\u0027) {\n-            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n-        }\n-        final char ch4 \u003d str.charAt(4);\n-        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        if (len \u003d\u003d 5) {\n-            return new Locale(str.substring(0, 2), str.substring(3, 5));\n-        }\n-        if (len \u003c 7) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        if (str.charAt(5) !\u003d \u0027_\u0027) {\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n-        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n     }\n+    final char ch1 \u003d str.charAt(1);\n+    if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (len \u003d\u003d 2) {\n+        return new Locale(str);\n+    }\n+    if (len \u003c 5) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (str.charAt(2) !\u003d \u0027_\u0027) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    final char ch3 \u003d str.charAt(3);\n+    if (ch3 \u003d\u003d \u0027_\u0027) {\n+        return new Locale(str.substring(0, 2), \"\", str.substring(4));\n+    }\n+    final char ch4 \u003d str.charAt(4);\n+    if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (len \u003d\u003d 5) {\n+        return new Locale(str.substring(0, 2), str.substring(3, 5));\n+    }\n+    if (len \u003c 7) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (str.charAt(5) !\u003d \u0027_\u0027) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dcde57852a97a9ac8021d2440b3de5be4870ecf6": {
      "type": "Ybodychange",
      "commitMessage": "LANG-879 LocaleUtils test fails with new Locale \"ja_JP_JP_#u-ca-japanese\" of JDK7\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1488038 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/5/31 上午6:12",
      "commitName": "dcde57852a97a9ac8021d2440b3de5be4870ecf6",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2013/1/22 下午3:09",
      "commitNameOld": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 128.63,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.contains(\"#\")) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    } else {\n        final char ch1 \u003d str.charAt(1);\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 2) {\n            return new Locale(str);\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        final char ch4 \u003d str.charAt(4);\n        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n        if (len \u003c 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(5) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 88,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "@@ -1,62 +1,65 @@\n public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n+    if (str.contains(\"#\")) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n     final int len \u003d str.length();\n     if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     final char ch0 \u003d str.charAt(0);\n     if (ch0 \u003d\u003d \u0027_\u0027) {\n         if (len \u003c 3) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch1 \u003d str.charAt(1);\n         final char ch2 \u003d str.charAt(2);\n         if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 3) {\n             return new Locale(\"\", str.substring(1, 3));\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(3) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     } else {\n         final char ch1 \u003d str.charAt(1);\n         if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 2) {\n             return new Locale(str);\n         }\n         if (len \u003c 5) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch3 \u003d str.charAt(3);\n         if (ch3 \u003d\u003d \u0027_\u0027) {\n             return new Locale(str.substring(0, 2), \"\", str.substring(4));\n         }\n         final char ch4 \u003d str.charAt(4);\n         if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n         }\n         if (len \u003c 7) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (str.charAt(5) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4d46f014fb8ee44386feb5fec52509f35d0e36ea": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "[LANG-865] LocaleUtils.toLocale does not parse strings starting with an underscore.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1428174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/3 下午2:19",
      "commitName": "4d46f014fb8ee44386feb5fec52509f35d0e36ea",
      "commitAuthor": "Gary D. Gregory",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "[LANG-865] LocaleUtils.toLocale does not parse strings starting with an underscore.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1428174 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013/1/3 下午2:19",
          "commitName": "4d46f014fb8ee44386feb5fec52509f35d0e36ea",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "2012/5/25 下午10:39",
          "commitNameOld": "4c2e69797f8262cc0546131352c1c5ef6dfdc985",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 222.65,
          "commitsBetweenForRepo": 160,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    } else {\n        final char ch1 \u003d str.charAt(1);\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 2) {\n            return new Locale(str);\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        final char ch4 \u003d str.charAt(4);\n        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n        if (len \u003c 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(5) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 88,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
          "diff": "@@ -1,37 +1,62 @@\n-public static Locale toLocale(String str) {\n+public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n-    int len \u003d str.length();\n-    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n+    final int len \u003d str.length();\n+    if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    char ch0 \u003d str.charAt(0);\n-    char ch1 \u003d str.charAt(1);\n-    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    if (len \u003d\u003d 2) {\n-        return new Locale(str, \"\");\n+    final char ch0 \u003d str.charAt(0);\n+    if (ch0 \u003d\u003d \u0027_\u0027) {\n+        if (len \u003c 3) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        final char ch1 \u003d str.charAt(1);\n+        final char ch2 \u003d str.charAt(2);\n+        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 3) {\n+            return new Locale(\"\", str.substring(1, 3));\n+        }\n+        if (len \u003c 5) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (str.charAt(3) !\u003d \u0027_\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     } else {\n+        final char ch1 \u003d str.charAt(1);\n+        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 2) {\n+            return new Locale(str);\n+        }\n+        if (len \u003c 5) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n         if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        char ch3 \u003d str.charAt(3);\n+        final char ch3 \u003d str.charAt(3);\n         if (ch3 \u003d\u003d \u0027_\u0027) {\n             return new Locale(str.substring(0, 2), \"\", str.substring(4));\n         }\n-        char ch4 \u003d str.charAt(4);\n-        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n+        final char ch4 \u003d str.charAt(4);\n+        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n-        } else {\n-            if (str.charAt(5) !\u003d \u0027_\u0027) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n         }\n+        if (len \u003c 7) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (str.charAt(5) !\u003d \u0027_\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "[LANG-865] LocaleUtils.toLocale does not parse strings starting with an underscore.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1428174 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2013/1/3 下午2:19",
          "commitName": "4d46f014fb8ee44386feb5fec52509f35d0e36ea",
          "commitAuthor": "Gary D. Gregory",
          "commitDateOld": "2012/5/25 下午10:39",
          "commitNameOld": "4c2e69797f8262cc0546131352c1c5ef6dfdc985",
          "commitAuthorOld": "Sebastian Bazley",
          "daysBetweenCommits": 222.65,
          "commitsBetweenForRepo": 160,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(final String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    final int len \u003d str.length();\n    if (len \u003c 2) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    final char ch0 \u003d str.charAt(0);\n    if (ch0 \u003d\u003d \u0027_\u0027) {\n        if (len \u003c 3) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch1 \u003d str.charAt(1);\n        final char ch2 \u003d str.charAt(2);\n        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 3) {\n            return new Locale(\"\", str.substring(1, 3));\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(3) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n    } else {\n        final char ch1 \u003d str.charAt(1);\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 2) {\n            return new Locale(str);\n        }\n        if (len \u003c 5) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        final char ch4 \u003d str.charAt(4);\n        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        }\n        if (len \u003c 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.charAt(5) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n    }\n}",
          "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
          "functionStartLine": 88,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
          "diff": "@@ -1,37 +1,62 @@\n-public static Locale toLocale(String str) {\n+public static Locale toLocale(final String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n-    int len \u003d str.length();\n-    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n+    final int len \u003d str.length();\n+    if (len \u003c 2) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    char ch0 \u003d str.charAt(0);\n-    char ch1 \u003d str.charAt(1);\n-    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n-        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-    }\n-    if (len \u003d\u003d 2) {\n-        return new Locale(str, \"\");\n+    final char ch0 \u003d str.charAt(0);\n+    if (ch0 \u003d\u003d \u0027_\u0027) {\n+        if (len \u003c 3) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        final char ch1 \u003d str.charAt(1);\n+        final char ch2 \u003d str.charAt(2);\n+        if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 3) {\n+            return new Locale(\"\", str.substring(1, 3));\n+        }\n+        if (len \u003c 5) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (str.charAt(3) !\u003d \u0027_\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        return new Locale(\"\", str.substring(1, 3), str.substring(4));\n     } else {\n+        final char ch1 \u003d str.charAt(1);\n+        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 2) {\n+            return new Locale(str);\n+        }\n+        if (len \u003c 5) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n         if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        char ch3 \u003d str.charAt(3);\n+        final char ch3 \u003d str.charAt(3);\n         if (ch3 \u003d\u003d \u0027_\u0027) {\n             return new Locale(str.substring(0, 2), \"\", str.substring(4));\n         }\n-        char ch4 \u003d str.charAt(4);\n-        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n+        final char ch4 \u003d str.charAt(4);\n+        if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n-        } else {\n-            if (str.charAt(5) !\u003d \u0027_\u0027) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n         }\n+        if (len \u003c 7) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (str.charAt(5) !\u003d \u0027_\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[str-String]",
            "newValue": "[str-String(modifiers-final)]"
          }
        }
      ]
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
      "path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 95,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/LocaleUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/LocaleUtils.java"
      }
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang3/LocaleUtils.java",
      "functionStartLine": 95,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/LocaleUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/LocaleUtils.java"
      }
    },
    "75d931a3264b73caa9cdd7d3373375cc33008ddf": {
      "type": "Ybodychange",
      "commitMessage": "Applying unit test/fix for LANG-328\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@534277 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2007/5/2 上午7:50",
      "commitName": "75d931a3264b73caa9cdd7d3373375cc33008ddf",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2006/12/23 上午4:34",
      "commitNameOld": "cf20d13c64da51becd1351befe02a06144fd6fc1",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 130.14,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        if (ch3 \u003d\u003d \u0027_\u0027) {\n            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n        }\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "functionStartLine": 94,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "@@ -1,34 +1,37 @@\n public static Locale toLocale(String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n     int len \u003d str.length();\n     if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     char ch0 \u003d str.charAt(0);\n     char ch1 \u003d str.charAt(1);\n     if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n     if (len \u003d\u003d 2) {\n         return new Locale(str, \"\");\n     } else {\n         if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         char ch3 \u003d str.charAt(3);\n+        if (ch3 \u003d\u003d \u0027_\u0027) {\n+            return new Locale(str.substring(0, 2), \"\", str.substring(4));\n+        }\n         char ch4 \u003d str.charAt(4);\n         if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n         } else {\n             if (str.charAt(5) !\u003d \u0027_\u0027) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cfd9081647e732143fbdc2db99681afa5b403a0f": {
      "type": "Ydocchange",
      "commitMessage": "Handle differences between JDK1.3 and JDK1.4\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@307279 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/10/8 下午5:55",
      "commitName": "cfd9081647e732143fbdc2db99681afa5b403a0f",
      "commitAuthor": "Stephen Colebourne",
      "commitDateOld": "2005/9/24 上午7:17",
      "commitNameOld": "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
      "commitAuthorOld": "Stephen Colebourne",
      "daysBetweenCommits": 14.44,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "functionStartLine": 93,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
        "newValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")         \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")      \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")   (#)\n\u003c/pre\u003e\n\n\u003cp\u003e(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\nIn JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn\u0027t.\nThus, the result from getVariant() may vary depending on your JDK.\u003c/p\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n"
      }
    },
    "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Test LocaleUtils\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@291219 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/9/24 上午7:17",
      "commitName": "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
      "commitAuthor": "Stephen Colebourne",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Test LocaleUtils\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@291219 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/9/24 上午7:17",
          "commitName": "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/8/22 上午3:32",
          "commitNameOld": "3196dafff093c126f8fd26729334d935fe08a5e1",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 33.16,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/LocaleUtils.java",
          "functionStartLine": 89,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
          "diff": "@@ -1,23 +1,34 @@\n public static Locale toLocale(String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n-    if (str.length() !\u003d 2 \u0026\u0026 str.length() !\u003d 5 \u0026\u0026 str.length() \u003c 7) {\n+    int len \u003d str.length();\n+    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    if (Character.isLowerCase(str.charAt(0)) \u003d\u003d false || Character.isLowerCase(str.charAt(1)) \u003d\u003d false) {\n+    char ch0 \u003d str.charAt(0);\n+    char ch1 \u003d str.charAt(1);\n+    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    if (str.length() \u003d\u003d 2) {\n+    if (len \u003d\u003d 2) {\n         return new Locale(str, \"\");\n     } else {\n-        if (Character.isUpperCase(str.charAt(3)) \u003d\u003d false || Character.isUpperCase(str.charAt(4)) \u003d\u003d false) {\n+        if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (str.length() \u003d\u003d 5) {\n+        char ch3 \u003d str.charAt(3);\n+        char ch4 \u003d str.charAt(4);\n+        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n         } else {\n+            if (str.charAt(5) !\u003d \u0027_\u0027) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Test LocaleUtils\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@291219 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2005/9/24 上午7:17",
          "commitName": "d1f5ebf4122aaf0675ef5547c2a6733f52a892d4",
          "commitAuthor": "Stephen Colebourne",
          "commitDateOld": "2005/8/22 上午3:32",
          "commitNameOld": "3196dafff093c126f8fd26729334d935fe08a5e1",
          "commitAuthorOld": "Gary D. Gregory",
          "daysBetweenCommits": 33.16,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    int len \u003d str.length();\n    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    char ch0 \u003d str.charAt(0);\n    char ch1 \u003d str.charAt(1);\n    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (len \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (str.charAt(2) !\u003d \u0027_\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch3 \u003d str.charAt(3);\n        char ch4 \u003d str.charAt(4);\n        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            if (str.charAt(5) !\u003d \u0027_\u0027) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
          "path": "src/java/org/apache/commons/lang/LocaleUtils.java",
          "functionStartLine": 89,
          "functionName": "toLocale",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n",
          "diff": "@@ -1,23 +1,34 @@\n public static Locale toLocale(String str) {\n     if (str \u003d\u003d null) {\n         return null;\n     }\n-    if (str.length() !\u003d 2 \u0026\u0026 str.length() !\u003d 5 \u0026\u0026 str.length() \u003c 7) {\n+    int len \u003d str.length();\n+    if (len !\u003d 2 \u0026\u0026 len !\u003d 5 \u0026\u0026 len \u003c 7) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    if (Character.isLowerCase(str.charAt(0)) \u003d\u003d false || Character.isLowerCase(str.charAt(1)) \u003d\u003d false) {\n+    char ch0 \u003d str.charAt(0);\n+    char ch1 \u003d str.charAt(1);\n+    if (ch0 \u003c \u0027a\u0027 || ch0 \u003e \u0027z\u0027 || ch1 \u003c \u0027a\u0027 || ch1 \u003e \u0027z\u0027) {\n         throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n     }\n-    if (str.length() \u003d\u003d 2) {\n+    if (len \u003d\u003d 2) {\n         return new Locale(str, \"\");\n     } else {\n-        if (Character.isUpperCase(str.charAt(3)) \u003d\u003d false || Character.isUpperCase(str.charAt(4)) \u003d\u003d false) {\n+        if (str.charAt(2) !\u003d \u0027_\u0027) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n-        if (str.length() \u003d\u003d 5) {\n+        char ch3 \u003d str.charAt(3);\n+        char ch4 \u003d str.charAt(4);\n+        if (ch3 \u003c \u0027A\u0027 || ch3 \u003e \u0027Z\u0027 || ch4 \u003c \u0027A\u0027 || ch4 \u003e \u0027Z\u0027) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len \u003d\u003d 5) {\n             return new Locale(str.substring(0, 2), str.substring(3, 5));\n         } else {\n+            if (str.charAt(5) !\u003d \u0027_\u0027) {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale\n@throws IllegalArgumentException if the string is an invalid format\n",
            "newValue": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n\u003cp\u003eThis method validates the input strictly.\nThe language code must be lowercase.\nThe country code must be uppercase.\nThe separator must be an underscore.\nThe length must be correct.\n\u003c/p\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale, null if null input\n@throws IllegalArgumentException if the string is an invalid format\n"
          }
        }
      ]
    },
    "04e1537d3c41646fdb56b60fae70a630ae177796": {
      "type": "Yintroduced",
      "commitMessage": "Initial version of LocaleUtils for review of concept\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@233061 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2005/8/17 上午5:41",
      "commitName": "04e1537d3c41646fdb56b60fae70a630ae177796",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,23 @@\n+public static Locale toLocale(String str) {\n+    if (str \u003d\u003d null) {\n+        return null;\n+    }\n+    if (str.length() !\u003d 2 \u0026\u0026 str.length() !\u003d 5 \u0026\u0026 str.length() \u003c 7) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (Character.isLowerCase(str.charAt(0)) \u003d\u003d false || Character.isLowerCase(str.charAt(1)) \u003d\u003d false) {\n+        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+    }\n+    if (str.length() \u003d\u003d 2) {\n+        return new Locale(str, \"\");\n+    } else {\n+        if (Character.isUpperCase(str.charAt(3)) \u003d\u003d false || Character.isUpperCase(str.charAt(4)) \u003d\u003d false) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (str.length() \u003d\u003d 5) {\n+            return new Locale(str.substring(0, 2), str.substring(3, 5));\n+        } else {\n+            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static Locale toLocale(String str) {\n    if (str \u003d\u003d null) {\n        return null;\n    }\n    if (str.length() !\u003d 2 \u0026\u0026 str.length() !\u003d 5 \u0026\u0026 str.length() \u003c 7) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (Character.isLowerCase(str.charAt(0)) \u003d\u003d false || Character.isLowerCase(str.charAt(1)) \u003d\u003d false) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n    }\n    if (str.length() \u003d\u003d 2) {\n        return new Locale(str, \"\");\n    } else {\n        if (Character.isUpperCase(str.charAt(3)) \u003d\u003d false || Character.isUpperCase(str.charAt(4)) \u003d\u003d false) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (str.length() \u003d\u003d 5) {\n            return new Locale(str.substring(0, 2), str.substring(3, 5));\n        } else {\n            return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n        }\n    }\n}",
      "path": "src/java/org/apache/commons/lang/LocaleUtils.java",
      "functionStartLine": 65,
      "functionName": "toLocale",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eConverts a String to a Locale.\u003c/p\u003e\n\n\u003cp\u003eThis method takes the string format of a locale and creates the\nlocale object from it.\u003c/p\u003e\n\n\u003cpre\u003e\n  LocaleUtils.toLocale(\"en\")     \u003d new Locale(\"en\", \"\")\n  LocaleUtils.toLocale(\"en_GB\")  \u003d new Locale(\"en\", \"GB\")\n  LocaleUtils.toLocale(\"en_GB_xxx\")  \u003d new Locale(\"en\", \"GB\", \"xxx\")\n\u003c/pre\u003e\n\n@param str the locale String to convert, null returns null\n@return a Locale\n@throws IllegalArgumentException if the string is an invalid format\n"
    }
  }
}