{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "LocatableInputSplitAssigner.java",
  "functionName": "getNextInputSplit",
  "functionId": "getNextInputSplit___host-String__taskId-int",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 76,
  "functionEndLine": 203,
  "numCommitsSeen": 32,
  "timeTaken": 3285,
  "changeHistory": [
    "7452802bc25c0915b7347d4faf2d60adcfc27644",
    "e0a4ee07084bc6ab56a20fbc4a18863462da93eb",
    "a959dd5034127161aafcf9c56222c7d08aa80e54",
    "b6f599f1ed27a28ee0f8be7176f06a5fa43fa310",
    "b32e77a2d8be76aeafa28b94fd7cfbb8de80f4cb",
    "c32569aed12ffa968e2c2289c2d56db262c0eba4",
    "8563d511da8ab8ac0e1362775f11aef7b67375be",
    "e73296f3e3fad9bb715edd0ff7a0eb10ce1226b9",
    "86d206c41922a1b7b8c2839b65d3568f9be55e0c",
    "f76231c90568cbeb25d25ae1da0320226eab1c13",
    "33cb2ca9898809d2fc90765996ea56bbea458e59",
    "8f7484000ae40ae1b5c68e2d21b9e5a44d984234"
  ],
  "changeHistoryShort": {
    "7452802bc25c0915b7347d4faf2d60adcfc27644": "Yparameterchange",
    "e0a4ee07084bc6ab56a20fbc4a18863462da93eb": "Ybodychange",
    "a959dd5034127161aafcf9c56222c7d08aa80e54": "Ybodychange",
    "b6f599f1ed27a28ee0f8be7176f06a5fa43fa310": "Ybodychange",
    "b32e77a2d8be76aeafa28b94fd7cfbb8de80f4cb": "Yfilerename",
    "c32569aed12ffa968e2c2289c2d56db262c0eba4": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "8563d511da8ab8ac0e1362775f11aef7b67375be": "Yfilerename",
    "e73296f3e3fad9bb715edd0ff7a0eb10ce1226b9": "Ymovefromfile",
    "86d206c41922a1b7b8c2839b65d3568f9be55e0c": "Ybodychange",
    "f76231c90568cbeb25d25ae1da0320226eab1c13": "Ydocchange",
    "33cb2ca9898809d2fc90765996ea56bbea458e59": "Yfilerename",
    "8f7484000ae40ae1b5c68e2d21b9e5a44d984234": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7452802bc25c0915b7347d4faf2d60adcfc27644": {
      "type": "Yparameterchange",
      "commitMessage": "[FLINK-1443 [api-breaking] Extended split assigner interface by parallel task id.\n",
      "commitDate": "2015/2/5 下午6:18",
      "commitName": "7452802bc25c0915b7347d4faf2d60adcfc27644",
      "commitAuthor": "Fabian Hueske",
      "commitDateOld": "2014/12/12 下午10:53",
      "commitNameOld": "e0a4ee07084bc6ab56a20fbc4a18863462da93eb",
      "commitAuthorOld": "Fabian Hueske",
      "daysBetweenCommits": 54.81,
      "commitsBetweenForRepo": 284,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host, int taskId) {\n    if (host \u003d\u003d null) {\n        synchronized (this.remoteSplitChooser) {\n            synchronized (this.unassigned) {\n                LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n                if (split !\u003d null) {\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning split to null host (random assignment).\");\n                        }\n                        remoteAssignments++;\n                        return split.getSplit();\n                    } else {\n                        throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                    }\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"No more unassigned input splits remaining.\");\n                    }\n                    return null;\n                }\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    LocatableInputSplitChooser localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new LocatableInputSplitChooser();\n        synchronized (localSplits) {\n            LocatableInputSplitChooser prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplitWithCount[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                }\n                for (LocatableInputSplitWithCount isw : remaining) {\n                    if (isLocal(host, isw.getSplit().getHostnames())) {\n                        isw.incrementLocalCount();\n                        localSplits.addInputSplit(isw);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split \u003d localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split !\u003d null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning local split to host \" + host);\n                    }\n                    localAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            }\n        }\n    }\n    synchronized (this.remoteSplitChooser) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split !\u003d null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning remote split to host \" + host);\n                    }\n                    remoteAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
      "functionStartLine": 74,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,85 +1,85 @@\n @Override\n-public LocatableInputSplit getNextInputSplit(String host) {\n+public LocatableInputSplit getNextInputSplit(String host, int taskId) {\n     if (host \u003d\u003d null) {\n         synchronized (this.remoteSplitChooser) {\n             synchronized (this.unassigned) {\n                 LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n                 if (split !\u003d null) {\n                     if (this.unassigned.remove(split)) {\n                         if (LOG.isInfoEnabled()) {\n                             LOG.info(\"Assigning split to null host (random assignment).\");\n                         }\n                         remoteAssignments++;\n                         return split.getSplit();\n                     } else {\n                         throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                     }\n                 } else {\n                     if (LOG.isDebugEnabled()) {\n                         LOG.debug(\"No more unassigned input splits remaining.\");\n                     }\n                     return null;\n                 }\n             }\n         }\n     }\n     host \u003d host.toLowerCase(Locale.US);\n     LocatableInputSplitChooser localSplits \u003d this.localPerHost.get(host);\n     if (localSplits \u003d\u003d null) {\n         localSplits \u003d new LocatableInputSplitChooser();\n         synchronized (localSplits) {\n             LocatableInputSplitChooser prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n             if (prior \u003d\u003d null) {\n                 LocatableInputSplitWithCount[] remaining;\n                 synchronized (this.unassigned) {\n                     remaining \u003d this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                 }\n                 for (LocatableInputSplitWithCount isw : remaining) {\n                     if (isLocal(host, isw.getSplit().getHostnames())) {\n                         isw.incrementLocalCount();\n                         localSplits.addInputSplit(isw);\n                     }\n                 }\n             } else {\n                 localSplits \u003d prior;\n             }\n         }\n     }\n     synchronized (localSplits) {\n         synchronized (this.unassigned) {\n             LocatableInputSplitWithCount split \u003d localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n             if (split !\u003d null) {\n                 if (this.unassigned.remove(split)) {\n                     if (LOG.isInfoEnabled()) {\n                         LOG.info(\"Assigning local split to host \" + host);\n                     }\n                     localAssignments++;\n                     return split.getSplit();\n                 } else {\n                     throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                 }\n             }\n         }\n     }\n     synchronized (this.remoteSplitChooser) {\n         synchronized (this.unassigned) {\n             LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n             if (split !\u003d null) {\n                 if (this.unassigned.remove(split)) {\n                     if (LOG.isInfoEnabled()) {\n                         LOG.info(\"Assigning remote split to host \" + host);\n                     }\n                     remoteAssignments++;\n                     return split.getSplit();\n                 } else {\n                     throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                 }\n             } else {\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"No more input splits remaining.\");\n                 }\n                 return null;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[host-String]",
        "newValue": "[host-String, taskId-int]"
      }
    },
    "e0a4ee07084bc6ab56a20fbc4a18863462da93eb": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1287] LocalizableSplitAssigner prefers splits with less degrees of freedom\n\nThis closes #258\n",
      "commitDate": "2014/12/12 下午10:53",
      "commitName": "e0a4ee07084bc6ab56a20fbc4a18863462da93eb",
      "commitAuthor": "Fabian Hueske",
      "commitDateOld": "2014/11/6 下午9:00",
      "commitNameOld": "a959dd5034127161aafcf9c56222c7d08aa80e54",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 36.08,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.remoteSplitChooser) {\n            synchronized (this.unassigned) {\n                LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n                if (split !\u003d null) {\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning split to null host (random assignment).\");\n                        }\n                        remoteAssignments++;\n                        return split.getSplit();\n                    } else {\n                        throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                    }\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"No more unassigned input splits remaining.\");\n                    }\n                    return null;\n                }\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    LocatableInputSplitChooser localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new LocatableInputSplitChooser();\n        synchronized (localSplits) {\n            LocatableInputSplitChooser prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplitWithCount[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                }\n                for (LocatableInputSplitWithCount isw : remaining) {\n                    if (isLocal(host, isw.getSplit().getHostnames())) {\n                        isw.incrementLocalCount();\n                        localSplits.addInputSplit(isw);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split \u003d localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split !\u003d null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning local split to host \" + host);\n                    }\n                    localAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            }\n        }\n    }\n    synchronized (this.remoteSplitChooser) {\n        synchronized (this.unassigned) {\n            LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n            if (split !\u003d null) {\n                if (this.unassigned.remove(split)) {\n                    if (LOG.isInfoEnabled()) {\n                        LOG.info(\"Assigning remote split to host \" + host);\n                    }\n                    remoteAssignments++;\n                    return split.getSplit();\n                } else {\n                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n                }\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
      "functionStartLine": 74,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,78 +1,85 @@\n @Override\n public LocatableInputSplit getNextInputSplit(String host) {\n     if (host \u003d\u003d null) {\n-        synchronized (this.unassigned) {\n-            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n-            if (iter.hasNext()) {\n-                LocatableInputSplit next \u003d iter.next();\n-                iter.remove();\n-                if (LOG.isInfoEnabled()) {\n-                    LOG.info(\"Assigning split to null host (random assignment).\");\n+        synchronized (this.remoteSplitChooser) {\n+            synchronized (this.unassigned) {\n+                LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n+                if (split !\u003d null) {\n+                    if (this.unassigned.remove(split)) {\n+                        if (LOG.isInfoEnabled()) {\n+                            LOG.info(\"Assigning split to null host (random assignment).\");\n+                        }\n+                        remoteAssignments++;\n+                        return split.getSplit();\n+                    } else {\n+                        throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n+                    }\n+                } else {\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(\"No more unassigned input splits remaining.\");\n+                    }\n+                    return null;\n                 }\n-                remoteAssignments++;\n-                return next;\n-            } else {\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"No more unassigned input splits remaining.\");\n-                }\n-                return null;\n             }\n         }\n     }\n     host \u003d host.toLowerCase(Locale.US);\n-    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n+    LocatableInputSplitChooser localSplits \u003d this.localPerHost.get(host);\n     if (localSplits \u003d\u003d null) {\n-        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n+        localSplits \u003d new LocatableInputSplitChooser();\n         synchronized (localSplits) {\n-            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n+            LocatableInputSplitChooser prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n             if (prior \u003d\u003d null) {\n-                LocatableInputSplit[] remaining;\n+                LocatableInputSplitWithCount[] remaining;\n                 synchronized (this.unassigned) {\n-                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n+                    remaining \u003d this.unassigned.toArray(new LocatableInputSplitWithCount[this.unassigned.size()]);\n                 }\n-                for (LocatableInputSplit is : remaining) {\n-                    if (isLocal(host, is.getHostnames())) {\n-                        localSplits.add(is);\n+                for (LocatableInputSplitWithCount isw : remaining) {\n+                    if (isLocal(host, isw.getSplit().getHostnames())) {\n+                        isw.incrementLocalCount();\n+                        localSplits.addInputSplit(isw);\n                     }\n                 }\n             } else {\n                 localSplits \u003d prior;\n             }\n         }\n     }\n     synchronized (localSplits) {\n-        int size \u003d localSplits.size();\n-        if (size \u003e 0) {\n-            synchronized (this.unassigned) {\n-                do {\n-                    --size;\n-                    LocatableInputSplit split \u003d localSplits.remove(size);\n-                    if (this.unassigned.remove(split)) {\n-                        if (LOG.isInfoEnabled()) {\n-                            LOG.info(\"Assigning local split to host \" + host);\n-                        }\n-                        localAssignments++;\n-                        return split;\n+        synchronized (this.unassigned) {\n+            LocatableInputSplitWithCount split \u003d localSplits.getNextUnassignedMinLocalCountSplit(this.unassigned);\n+            if (split !\u003d null) {\n+                if (this.unassigned.remove(split)) {\n+                    if (LOG.isInfoEnabled()) {\n+                        LOG.info(\"Assigning local split to host \" + host);\n                     }\n-                } while (size \u003e 0);\n+                    localAssignments++;\n+                    return split.getSplit();\n+                } else {\n+                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n+                }\n             }\n         }\n     }\n-    synchronized (this.unassigned) {\n-        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n-        if (iter.hasNext()) {\n-            LocatableInputSplit next \u003d iter.next();\n-            iter.remove();\n-            if (LOG.isInfoEnabled()) {\n-                LOG.info(\"Assigning remote split to host \" + host);\n+    synchronized (this.remoteSplitChooser) {\n+        synchronized (this.unassigned) {\n+            LocatableInputSplitWithCount split \u003d this.remoteSplitChooser.getNextUnassignedMinLocalCountSplit(this.unassigned);\n+            if (split !\u003d null) {\n+                if (this.unassigned.remove(split)) {\n+                    if (LOG.isInfoEnabled()) {\n+                        LOG.info(\"Assigning remote split to host \" + host);\n+                    }\n+                    remoteAssignments++;\n+                    return split.getSplit();\n+                } else {\n+                    throw new IllegalStateException(\"Chosen InputSplit has already been assigned. This should not happen!\");\n+                }\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No more input splits remaining.\");\n+                }\n+                return null;\n             }\n-            remoteAssignments++;\n-            return next;\n-        } else {\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"No more input splits remaining.\");\n-            }\n-            return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a959dd5034127161aafcf9c56222c7d08aa80e54": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1220] Promote various log statements to INFO level. Add log statements for assignment locations\n",
      "commitDate": "2014/11/6 下午9:00",
      "commitName": "a959dd5034127161aafcf9c56222c7d08aa80e54",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014/10/18 下午11:13",
      "commitNameOld": "23e30f09d4b94e71164ba9fb71d934ebfaf124d5",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 18.91,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Assigning split to null host (random assignment).\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more unassigned input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isInfoEnabled()) {\n                            LOG.info(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
      "functionStartLine": 67,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,78 +1,78 @@\n @Override\n public LocatableInputSplit getNextInputSplit(String host) {\n     if (host \u003d\u003d null) {\n         synchronized (this.unassigned) {\n             Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n             if (iter.hasNext()) {\n                 LocatableInputSplit next \u003d iter.next();\n                 iter.remove();\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Assigning arbitrary split to null host.\");\n+                if (LOG.isInfoEnabled()) {\n+                    LOG.info(\"Assigning split to null host (random assignment).\");\n                 }\n                 remoteAssignments++;\n                 return next;\n             } else {\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"No more unassigned input splits remaining.\");\n                 }\n                 return null;\n             }\n         }\n     }\n     host \u003d host.toLowerCase(Locale.US);\n     List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n     if (localSplits \u003d\u003d null) {\n         localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n         synchronized (localSplits) {\n             List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n             if (prior \u003d\u003d null) {\n                 LocatableInputSplit[] remaining;\n                 synchronized (this.unassigned) {\n                     remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                 }\n                 for (LocatableInputSplit is : remaining) {\n                     if (isLocal(host, is.getHostnames())) {\n                         localSplits.add(is);\n                     }\n                 }\n             } else {\n                 localSplits \u003d prior;\n             }\n         }\n     }\n     synchronized (localSplits) {\n         int size \u003d localSplits.size();\n         if (size \u003e 0) {\n             synchronized (this.unassigned) {\n                 do {\n                     --size;\n                     LocatableInputSplit split \u003d localSplits.remove(size);\n                     if (this.unassigned.remove(split)) {\n-                        if (LOG.isDebugEnabled()) {\n-                            LOG.debug(\"Assigning local split to host \" + host);\n+                        if (LOG.isInfoEnabled()) {\n+                            LOG.info(\"Assigning local split to host \" + host);\n                         }\n                         localAssignments++;\n                         return split;\n                     }\n                 } while (size \u003e 0);\n             }\n         }\n     }\n     synchronized (this.unassigned) {\n         Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n         if (iter.hasNext()) {\n             LocatableInputSplit next \u003d iter.next();\n             iter.remove();\n-            if (LOG.isDebugEnabled()) {\n-                LOG.debug(\"Assigning remote split to host \" + host);\n+            if (LOG.isInfoEnabled()) {\n+                LOG.info(\"Assigning remote split to host \" + host);\n             }\n             remoteAssignments++;\n             return next;\n         } else {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"No more input splits remaining.\");\n             }\n             return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6f599f1ed27a28ee0f8be7176f06a5fa43fa310": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1170] Fix faulty input split localization\nPass hostname to split assigner\nAvoid clashes by only using the first component of the fully qualified hostname\n",
      "commitDate": "2014/10/18 下午11:13",
      "commitName": "b6f599f1ed27a28ee0f8be7176f06a5fa43fa310",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014/9/23 下午7:59",
      "commitNameOld": "b904b0041cf97b2c6181b1985afc457ed01cf626",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 25.13,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more unassigned input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
      "functionStartLine": 67,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,78 +1,78 @@\n @Override\n public LocatableInputSplit getNextInputSplit(String host) {\n     if (host \u003d\u003d null) {\n         synchronized (this.unassigned) {\n             Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n             if (iter.hasNext()) {\n                 LocatableInputSplit next \u003d iter.next();\n                 iter.remove();\n                 if (LOG.isDebugEnabled()) {\n                     LOG.debug(\"Assigning arbitrary split to null host.\");\n                 }\n                 remoteAssignments++;\n                 return next;\n             } else {\n                 if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"No more input splits remaining.\");\n+                    LOG.debug(\"No more unassigned input splits remaining.\");\n                 }\n                 return null;\n             }\n         }\n     }\n     host \u003d host.toLowerCase(Locale.US);\n     List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n     if (localSplits \u003d\u003d null) {\n         localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n         synchronized (localSplits) {\n             List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n             if (prior \u003d\u003d null) {\n                 LocatableInputSplit[] remaining;\n                 synchronized (this.unassigned) {\n                     remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                 }\n                 for (LocatableInputSplit is : remaining) {\n                     if (isLocal(host, is.getHostnames())) {\n                         localSplits.add(is);\n                     }\n                 }\n             } else {\n                 localSplits \u003d prior;\n             }\n         }\n     }\n     synchronized (localSplits) {\n         int size \u003d localSplits.size();\n         if (size \u003e 0) {\n             synchronized (this.unassigned) {\n                 do {\n                     --size;\n                     LocatableInputSplit split \u003d localSplits.remove(size);\n                     if (this.unassigned.remove(split)) {\n                         if (LOG.isDebugEnabled()) {\n                             LOG.debug(\"Assigning local split to host \" + host);\n                         }\n                         localAssignments++;\n                         return split;\n                     }\n                 } while (size \u003e 0);\n             }\n         }\n     }\n     synchronized (this.unassigned) {\n         Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n         if (iter.hasNext()) {\n             LocatableInputSplit next \u003d iter.next();\n             iter.remove();\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Assigning remote split to host \" + host);\n             }\n             remoteAssignments++;\n             return next;\n         } else {\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"No more input splits remaining.\");\n             }\n             return null;\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32e77a2d8be76aeafa28b94fd7cfbb8de80f4cb": {
      "type": "Yfilerename",
      "commitMessage": "Refactor job graph construction to incremental attachment based\n",
      "commitDate": "2014/9/21 上午2:02",
      "commitName": "b32e77a2d8be76aeafa28b94fd7cfbb8de80f4cb",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014/9/21 上午2:02",
      "commitNameOld": "c16f6d816899d8db7ff7c809d0c26be611b4d561",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java",
      "functionStartLine": 66,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/api/common/io/LocatableInputSplitAssigner.java"
      }
    },
    "c32569aed12ffa968e2c2289c2d56db262c0eba4": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "[FLINK-1094] Reworked, improved, and testes split assigners\n",
      "commitDate": "2014/9/21 上午2:02",
      "commitName": "c32569aed12ffa968e2c2289c2d56db262c0eba4",
      "commitAuthor": "Stephan Ewen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "[FLINK-1094] Reworked, improved, and testes split assigners\n",
          "commitDate": "2014/9/21 上午2:02",
          "commitName": "c32569aed12ffa968e2c2289c2d56db262c0eba4",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2014/9/5 下午5:57",
          "commitNameOld": "08188508d528c1072a746aacbf2a5c712d4f8467",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 15.34,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
          "functionStartLine": 66,
          "functionName": "getNextInputSplit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,78 @@\n @Override\n-public InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n-    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n-    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n-    if (splitStore \u003d\u003d null) {\n-        return null;\n+public LocatableInputSplit getNextInputSplit(String host) {\n+    if (host \u003d\u003d null) {\n+        synchronized (this.unassigned) {\n+            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+            if (iter.hasNext()) {\n+                LocatableInputSplit next \u003d iter.next();\n+                iter.remove();\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Assigning arbitrary split to null host.\");\n+                }\n+                remoteAssignments++;\n+                return next;\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No more input splits remaining.\");\n+                }\n+                return null;\n+            }\n+        }\n     }\n-    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n-    if (instance \u003d\u003d null) {\n-        LOG.error(\"Instance is null, returning random split\");\n-        return null;\n+    host \u003d host.toLowerCase(Locale.US);\n+    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n+    if (localSplits \u003d\u003d null) {\n+        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n+        synchronized (localSplits) {\n+            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n+            if (prior \u003d\u003d null) {\n+                LocatableInputSplit[] remaining;\n+                synchronized (this.unassigned) {\n+                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n+                }\n+                for (LocatableInputSplit is : remaining) {\n+                    if (isLocal(host, is.getHostnames())) {\n+                        localSplits.add(is);\n+                    }\n+                }\n+            } else {\n+                localSplits \u003d prior;\n+            }\n+        }\n     }\n-    return splitStore.getNextInputSplit(instance);\n+    synchronized (localSplits) {\n+        int size \u003d localSplits.size();\n+        if (size \u003e 0) {\n+            synchronized (this.unassigned) {\n+                do {\n+                    --size;\n+                    LocatableInputSplit split \u003d localSplits.remove(size);\n+                    if (this.unassigned.remove(split)) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Assigning local split to host \" + host);\n+                        }\n+                        localAssignments++;\n+                        return split;\n+                    }\n+                } while (size \u003e 0);\n+            }\n+        }\n+    }\n+    synchronized (this.unassigned) {\n+        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+        if (iter.hasNext()) {\n+            LocatableInputSplit next \u003d iter.next();\n+            iter.remove();\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Assigning remote split to host \" + host);\n+            }\n+            remoteAssignments++;\n+            return next;\n+        } else {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No more input splits remaining.\");\n+            }\n+            return null;\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[vertex-ExecutionVertex(modifiers-final)]",
            "newValue": "[host-String]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "[FLINK-1094] Reworked, improved, and testes split assigners\n",
          "commitDate": "2014/9/21 上午2:02",
          "commitName": "c32569aed12ffa968e2c2289c2d56db262c0eba4",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2014/9/5 下午5:57",
          "commitNameOld": "08188508d528c1072a746aacbf2a5c712d4f8467",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 15.34,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
          "functionStartLine": 66,
          "functionName": "getNextInputSplit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,78 @@\n @Override\n-public InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n-    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n-    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n-    if (splitStore \u003d\u003d null) {\n-        return null;\n+public LocatableInputSplit getNextInputSplit(String host) {\n+    if (host \u003d\u003d null) {\n+        synchronized (this.unassigned) {\n+            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+            if (iter.hasNext()) {\n+                LocatableInputSplit next \u003d iter.next();\n+                iter.remove();\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Assigning arbitrary split to null host.\");\n+                }\n+                remoteAssignments++;\n+                return next;\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No more input splits remaining.\");\n+                }\n+                return null;\n+            }\n+        }\n     }\n-    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n-    if (instance \u003d\u003d null) {\n-        LOG.error(\"Instance is null, returning random split\");\n-        return null;\n+    host \u003d host.toLowerCase(Locale.US);\n+    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n+    if (localSplits \u003d\u003d null) {\n+        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n+        synchronized (localSplits) {\n+            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n+            if (prior \u003d\u003d null) {\n+                LocatableInputSplit[] remaining;\n+                synchronized (this.unassigned) {\n+                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n+                }\n+                for (LocatableInputSplit is : remaining) {\n+                    if (isLocal(host, is.getHostnames())) {\n+                        localSplits.add(is);\n+                    }\n+                }\n+            } else {\n+                localSplits \u003d prior;\n+            }\n+        }\n     }\n-    return splitStore.getNextInputSplit(instance);\n+    synchronized (localSplits) {\n+        int size \u003d localSplits.size();\n+        if (size \u003e 0) {\n+            synchronized (this.unassigned) {\n+                do {\n+                    --size;\n+                    LocatableInputSplit split \u003d localSplits.remove(size);\n+                    if (this.unassigned.remove(split)) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Assigning local split to host \" + host);\n+                        }\n+                        localAssignments++;\n+                        return split;\n+                    }\n+                } while (size \u003e 0);\n+            }\n+        }\n+    }\n+    synchronized (this.unassigned) {\n+        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+        if (iter.hasNext()) {\n+            LocatableInputSplit next \u003d iter.next();\n+            iter.remove();\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Assigning remote split to host \" + host);\n+            }\n+            remoteAssignments++;\n+            return next;\n+        } else {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No more input splits remaining.\");\n+            }\n+            return null;\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "InputSplit",
            "newValue": "LocatableInputSplit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-1094] Reworked, improved, and testes split assigners\n",
          "commitDate": "2014/9/21 上午2:02",
          "commitName": "c32569aed12ffa968e2c2289c2d56db262c0eba4",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2014/9/5 下午5:57",
          "commitNameOld": "08188508d528c1072a746aacbf2a5c712d4f8467",
          "commitAuthorOld": "Till Rohrmann",
          "daysBetweenCommits": 15.34,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic LocatableInputSplit getNextInputSplit(String host) {\n    if (host \u003d\u003d null) {\n        synchronized (this.unassigned) {\n            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n            if (iter.hasNext()) {\n                LocatableInputSplit next \u003d iter.next();\n                iter.remove();\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Assigning arbitrary split to null host.\");\n                }\n                remoteAssignments++;\n                return next;\n            } else {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"No more input splits remaining.\");\n                }\n                return null;\n            }\n        }\n    }\n    host \u003d host.toLowerCase(Locale.US);\n    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n    if (localSplits \u003d\u003d null) {\n        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n        synchronized (localSplits) {\n            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n            if (prior \u003d\u003d null) {\n                LocatableInputSplit[] remaining;\n                synchronized (this.unassigned) {\n                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n                }\n                for (LocatableInputSplit is : remaining) {\n                    if (isLocal(host, is.getHostnames())) {\n                        localSplits.add(is);\n                    }\n                }\n            } else {\n                localSplits \u003d prior;\n            }\n        }\n    }\n    synchronized (localSplits) {\n        int size \u003d localSplits.size();\n        if (size \u003e 0) {\n            synchronized (this.unassigned) {\n                do {\n                    --size;\n                    LocatableInputSplit split \u003d localSplits.remove(size);\n                    if (this.unassigned.remove(split)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Assigning local split to host \" + host);\n                        }\n                        localAssignments++;\n                        return split;\n                    }\n                } while (size \u003e 0);\n            }\n        }\n    }\n    synchronized (this.unassigned) {\n        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n        if (iter.hasNext()) {\n            LocatableInputSplit next \u003d iter.next();\n            iter.remove();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Assigning remote split to host \" + host);\n            }\n            remoteAssignments++;\n            return next;\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No more input splits remaining.\");\n            }\n            return null;\n        }\n    }\n}",
          "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
          "functionStartLine": 66,
          "functionName": "getNextInputSplit",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,14 +1,78 @@\n @Override\n-public InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n-    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n-    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n-    if (splitStore \u003d\u003d null) {\n-        return null;\n+public LocatableInputSplit getNextInputSplit(String host) {\n+    if (host \u003d\u003d null) {\n+        synchronized (this.unassigned) {\n+            Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+            if (iter.hasNext()) {\n+                LocatableInputSplit next \u003d iter.next();\n+                iter.remove();\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Assigning arbitrary split to null host.\");\n+                }\n+                remoteAssignments++;\n+                return next;\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No more input splits remaining.\");\n+                }\n+                return null;\n+            }\n+        }\n     }\n-    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n-    if (instance \u003d\u003d null) {\n-        LOG.error(\"Instance is null, returning random split\");\n-        return null;\n+    host \u003d host.toLowerCase(Locale.US);\n+    List\u003cLocatableInputSplit\u003e localSplits \u003d this.localPerHost.get(host);\n+    if (localSplits \u003d\u003d null) {\n+        localSplits \u003d new ArrayList\u003cLocatableInputSplit\u003e(16);\n+        synchronized (localSplits) {\n+            List\u003cLocatableInputSplit\u003e prior \u003d this.localPerHost.putIfAbsent(host, localSplits);\n+            if (prior \u003d\u003d null) {\n+                LocatableInputSplit[] remaining;\n+                synchronized (this.unassigned) {\n+                    remaining \u003d (LocatableInputSplit[]) this.unassigned.toArray(new LocatableInputSplit[this.unassigned.size()]);\n+                }\n+                for (LocatableInputSplit is : remaining) {\n+                    if (isLocal(host, is.getHostnames())) {\n+                        localSplits.add(is);\n+                    }\n+                }\n+            } else {\n+                localSplits \u003d prior;\n+            }\n+        }\n     }\n-    return splitStore.getNextInputSplit(instance);\n+    synchronized (localSplits) {\n+        int size \u003d localSplits.size();\n+        if (size \u003e 0) {\n+            synchronized (this.unassigned) {\n+                do {\n+                    --size;\n+                    LocatableInputSplit split \u003d localSplits.remove(size);\n+                    if (this.unassigned.remove(split)) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"Assigning local split to host \" + host);\n+                        }\n+                        localAssignments++;\n+                        return split;\n+                    }\n+                } while (size \u003e 0);\n+            }\n+        }\n+    }\n+    synchronized (this.unassigned) {\n+        Iterator\u003cLocatableInputSplit\u003e iter \u003d this.unassigned.iterator();\n+        if (iter.hasNext()) {\n+            LocatableInputSplit next \u003d iter.next();\n+            iter.remove();\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Assigning remote split to host \" + host);\n+            }\n+            remoteAssignments++;\n+            return next;\n+        } else {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No more input splits remaining.\");\n+            }\n+            return null;\n+        }\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8563d511da8ab8ac0e1362775f11aef7b67375be": {
      "type": "Yfilerename",
      "commitMessage": "Rename POMs, scripts, quickstarts and other minor renames\n",
      "commitDate": "2014/7/11 上午4:35",
      "commitName": "8563d511da8ab8ac0e1362775f11aef7b67375be",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014/7/10 下午10:46",
      "commitNameOld": "5f011547378ad03c033770503c6dcfd6b64e9647",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 96,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
        "newPath": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java"
      }
    },
    "e73296f3e3fad9bb715edd0ff7a0eb10ce1226b9": {
      "type": "Ymovefromfile",
      "commitMessage": "Renaming part 3 (runtime)\n",
      "commitDate": "2014/7/10 上午2:25",
      "commitName": "e73296f3e3fad9bb715edd0ff7a0eb10ce1226b9",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014/7/10 上午1:14",
      "commitNameOld": "24eb47ac86299920aa137d5b6394a248ff58d19e",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "stratosphere-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 96,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-runtime/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
        "newPath": "stratosphere-runtime/src/main/java/org/apache/flink/runtime/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
        "oldMethodName": "getNextInputSplit",
        "newMethodName": "getNextInputSplit"
      }
    },
    "86d206c41922a1b7b8c2839b65d3568f9be55e0c": {
      "type": "Ybodychange",
      "commitMessage": "Rework the Taskmanager to a slot based model and remove legacy cloud code\n\nSquashed commit of the following:\n\n  - Post merge cleanup\n  - Renamed fractionMemory into memoryFraction.\n  - Removed Local and QueueScheduler and replaced it instead with an unified DefaultScheduler.\n  - Removed Local and ClusterManager and inserted instead an unified DefaultInstanceManager.\n  - Removed connection IDs from execution edges\n  - Removed InstanceType, InstanceRequestMap, InstanceTypeDescription, InstanceTypeDescriptionTypeFactory, PendingRequestsMap\n  - Fixed problems with test cases.\n  - introduced simple slot system for scheduling.\n  - Removed subtasks per instance\n  - Added registerTaskManager to the JobManager RPC calls. RegisterTaskManager is called only once where the hardware description information is sent.\n\nAdd: Merging cloudmodel remove with new network stack\n",
      "commitDate": "2014/6/23 上午3:07",
      "commitName": "86d206c41922a1b7b8c2839b65d3568f9be55e0c",
      "commitAuthor": "Till Rohrmann",
      "commitDateOld": "2013/12/20 上午7:05",
      "commitNameOld": "5e1853b64e9f3ad8498e677e681d2a5b4d49101b",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 184.83,
      "commitsBetweenForRepo": 646,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "stratosphere-runtime/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 109,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,14 @@\n @Override\n public InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n     final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n     final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n     if (splitStore \u003d\u003d null) {\n         return null;\n     }\n-    final AbstractInstance instance \u003d vertex.getAllocatedResource().getInstance();\n+    final Instance instance \u003d vertex.getAllocatedResource().getInstance();\n     if (instance \u003d\u003d null) {\n         LOG.error(\"Instance is null, returning random split\");\n         return null;\n     }\n     return splitStore.getNextInputSplit(instance);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f76231c90568cbeb25d25ae1da0320226eab1c13": {
      "type": "Ydocchange",
      "commitMessage": "Remove non-javadoc comments\n",
      "commitDate": "2013/12/18 下午6:55",
      "commitName": "f76231c90568cbeb25d25ae1da0320226eab1c13",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013/12/14 上午10:09",
      "commitNameOld": "fc6b5168684ca298d8b025c839d9a4e48e470790",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final AbstractInstance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "stratosphere-runtime/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 112,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldValue": "@inheritDoc}\n",
        "newValue": ""
      }
    },
    "33cb2ca9898809d2fc90765996ea56bbea458e59": {
      "type": "Yfilerename",
      "commitMessage": "Reorganized basic project structures. No renamings yet.\n",
      "commitDate": "2013/12/14 上午3:52",
      "commitName": "33cb2ca9898809d2fc90765996ea56bbea458e59",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013/12/14 上午1:11",
      "commitNameOld": "0ad1dcc7dbd432d01d3cb4ed2db86b79534c68ad",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final AbstractInstance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "stratosphere-runtime/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 118,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
        "newPath": "stratosphere-runtime/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java"
      }
    },
    "8f7484000ae40ae1b5c68e2d21b9e5a44d984234": {
      "type": "Yintroduced",
      "commitMessage": "Added HBase table formats (patch by Marcus, slightly adjusted).\n",
      "commitDate": "2013/8/22 下午2:36",
      "commitName": "8f7484000ae40ae1b5c68e2d21b9e5a44d984234",
      "commitAuthor": "StephanEwen",
      "diff": "@@ -0,0 +1,14 @@\n+@Override\n+public InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n+    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n+    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n+    if (splitStore \u003d\u003d null) {\n+        return null;\n+    }\n+    final AbstractInstance instance \u003d vertex.getAllocatedResource().getInstance();\n+    if (instance \u003d\u003d null) {\n+        LOG.error(\"Instance is null, returning random split\");\n+        return null;\n+    }\n+    return splitStore.getNextInputSplit(instance);\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic InputSplit getNextInputSplit(final ExecutionVertex vertex) {\n    final ExecutionGroupVertex groupVertex \u003d vertex.getGroupVertex();\n    final LocatableInputSplitList splitStore \u003d this.vertexMap.get(groupVertex);\n    if (splitStore \u003d\u003d null) {\n        return null;\n    }\n    final AbstractInstance instance \u003d vertex.getAllocatedResource().getInstance();\n    if (instance \u003d\u003d null) {\n        LOG.error(\"Instance is null, returning random split\");\n        return null;\n    }\n    return splitStore.getNextInputSplit(instance);\n}",
      "path": "nephele/nephele-server/src/main/java/eu/stratosphere/nephele/jobmanager/splitassigner/LocatableInputSplitAssigner.java",
      "functionStartLine": 118,
      "functionName": "getNextInputSplit",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n"
    }
  }
}