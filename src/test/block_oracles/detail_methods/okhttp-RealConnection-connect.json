{
  "origin": "codeshovel",
  "repositoryName": "okhttp",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/okhttp/.git",
  "startCommitName": "5224f3045ba9b171fce521777edf389f9206173c",
  "sourceFileName": "RealConnection.java",
  "functionName": "connect",
  "functionId": "connect___connectTimeout-int__readTimeout-int__writeTimeout-int__pingIntervalMillis-int__connectionRetryEnabled-boolean__call-Call__eventListener-EventListener",
  "sourceFilePath": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 130,
  "functionEndLine": 206,
  "numCommitsSeen": 482,
  "timeTaken": 3102,
  "changeHistory": [
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
    "abb0a790802996d1039c35424b70b0f3f06b94b7",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
    "29267ac4e8eae099064483dc4c4b246690a92009",
    "c7d508b79c9e201c91ec23f5eec47c18be206567",
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
    "8331b2d75a51631bee622daf2175854fe49ce29a",
    "1f58b14bd18565b3dc4aaf15c072033e68b69660",
    "c5187583bbfe93fe58db80f95b5b478c84180c29",
    "576408374d58a3e9a63714b6f7761cb42a315102",
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
    "c9a89876de476983f273edbf108c365127c18c5e",
    "b63841d3a3922440c258098190371f1e17d977c1",
    "71ae4df298f42039579fd6e3c6d9d9060ac91214",
    "c5f58e45454d1ffc621c65e377cb91345018e087",
    "ee87f8036f99fdfd63f8ef145f4478907682db29",
    "c358656c8799d30fd422448153e99a5dd37e298a",
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
    "457fb428a729c50c562822571ea9b13e689648f3",
    "b42e73f497eafe147667117202267ec756adff26",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c",
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
    "b60875421b0f67575970b6b63582b7e5e31c4a06",
    "da484932625ab15681e469c1680b6371b8f67080",
    "41aa4b6805141369d614964152d329a686aabdb8",
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad",
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4",
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
    "a669069599893a774748181a238e0b009a4f3e87",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9",
    "ed2ee02570bac36b89bd93836e200840cb8fa59d",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa",
    "13c06879f4e98c86436bdca765046ef815e34838",
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65",
    "3ba54eed34c9d5e41965587660a76a06806180a0",
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961",
    "1ece746c815a26782042b1fca6069eb527d1029b",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3",
    "194290e5f3819bf91d87c5d08c152946b6aa3509",
    "78c6624b11d5f33504dae8211b4592383468343e",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
    "5aa2456a145883f6688c6ee325635ed0c6339076",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e"
  ],
  "changeHistoryShort": {
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84": "Ybodychange",
    "abb0a790802996d1039c35424b70b0f3f06b94b7": "Ymultichange(Yparameterchange,Ybodychange)",
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": "Ybodychange",
    "29267ac4e8eae099064483dc4c4b246690a92009": "Ybodychange",
    "c7d508b79c9e201c91ec23f5eec47c18be206567": "Ybodychange",
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7": "Ymultichange(Yparameterchange,Ybodychange)",
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": "Ymultichange(Yparameterchange,Ybodychange)",
    "8331b2d75a51631bee622daf2175854fe49ce29a": "Ybodychange",
    "1f58b14bd18565b3dc4aaf15c072033e68b69660": "Ybodychange",
    "c5187583bbfe93fe58db80f95b5b478c84180c29": "Yfilerename",
    "576408374d58a3e9a63714b6f7761cb42a315102": "Yexceptionschange",
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4": "Ybodychange",
    "c9a89876de476983f273edbf108c365127c18c5e": "Ymultichange(Ymovefromfile,Ybodychange)",
    "b63841d3a3922440c258098190371f1e17d977c1": "Ybodychange",
    "71ae4df298f42039579fd6e3c6d9d9060ac91214": "Ybodychange",
    "c5f58e45454d1ffc621c65e377cb91345018e087": "Ybodychange",
    "ee87f8036f99fdfd63f8ef145f4478907682db29": "Ybodychange",
    "c358656c8799d30fd422448153e99a5dd37e298a": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d": "Ybodychange",
    "457fb428a729c50c562822571ea9b13e689648f3": "Ymultichange(Yparameterchange,Ybodychange)",
    "b42e73f497eafe147667117202267ec756adff26": "Ybodychange",
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": "Ybodychange",
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c": "Ybodychange",
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3": "Ymodifierchange",
    "b60875421b0f67575970b6b63582b7e5e31c4a06": "Ybodychange",
    "da484932625ab15681e469c1680b6371b8f67080": "Yparameterchange",
    "41aa4b6805141369d614964152d329a686aabdb8": "Ymultichange(Yparameterchange,Ybodychange)",
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f": "Ybodychange",
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad": "Ybodychange",
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4": "Ybodychange",
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e": "Ybodychange",
    "a669069599893a774748181a238e0b009a4f3e87": "Ybodychange",
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": "Ybodychange",
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9": "Ybodychange",
    "ed2ee02570bac36b89bd93836e200840cb8fa59d": "Ybodychange",
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": "Ybodychange",
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa": "Ybodychange",
    "13c06879f4e98c86436bdca765046ef815e34838": "Ybodychange",
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65": "Ybodychange",
    "3ba54eed34c9d5e41965587660a76a06806180a0": "Ybodychange",
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc": "Ybodychange",
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961": "Ybodychange",
    "1ece746c815a26782042b1fca6069eb527d1029b": "Ybodychange",
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": "Yfilerename",
    "194290e5f3819bf91d87c5d08c152946b6aa3509": "Ybodychange",
    "78c6624b11d5f33504dae8211b4592383468343e": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": "Yfilerename",
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": "Ymultichange(Yparameterchange,Ybodychange)",
    "5aa2456a145883f6688c6ee325635ed0c6339076": "Ymultichange(Yparameterchange,Ybodychange)",
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db18f0e404ab35c7b23e8ecc27913d717e96eb84": {
      "type": "Ybodychange",
      "commitMessage": "Rename H2C to H2_PRIOR_KNOWLEDGE. (#3996)\n\nThe string h2c is used with cleartext upgrades. We\u0027re not doing those here,\r\nso that identifier isn\u0027t appropriate.",
      "commitDate": "2018/5/12 下午4:29",
      "commitName": "db18f0e404ab35c7b23e8ecc27913d717e96eb84",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2018/2/27 上午7:55",
      "commitNameOld": "9a6f88dc34cb68d341ec1a7e4c79546fa1c18c96",
      "commitAuthorOld": "Jaye Pitzeruse",
      "daysBetweenCommits": 74.36,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    } else {\n        if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n            throw new RouteException(new UnknownServiceException(\"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 130,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,63 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n+    } else {\n+        if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {\n+            throw new RouteException(new UnknownServiceException(\"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\"));\n+        }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                 if (rawSocket \u003d\u003d null) {\n                     break;\n                 }\n             } else {\n                 connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n             establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n             eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n         ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n         throw new RouteException(exception);\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "abb0a790802996d1039c35424b70b0f3f06b94b7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
      "commitDate": "2018/2/22 上午9:17",
      "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
          "commitDate": "2018/2/22 上午9:17",
          "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2018/2/17 下午6:24",
          "commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
          "commitAuthorOld": "Yuri Schimke",
          "daysBetweenCommits": 4.62,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 130,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,59 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                 if (rawSocket \u003d\u003d null) {\n                     break;\n                 }\n             } else {\n                 connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n-            establishProtocol(connectionSpecSelector, call, eventListener);\n+            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n             eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n         ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n         throw new RouteException(exception);\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, pingIntervalMillis-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "First step towards HTTP/2 automatic pings. (#3874)\n\nThis changes the executor services in HTTP/2 connection to split up\r\nlistener executors (of which there may be many threads) from writer\r\nexecutors (of which there is one per connection).\r\n\r\nThis adds a scheduled executor job to send pings on an interval. We\r\ndon\u0027t yet fail the connection if pongs are not received.\r\n\r\nFor follow-up there\u0027s some work to remove exising APIs to send pings\r\nthrough the HTTP/2 APIs. These are unused and make it awkard to\r\nconfirm that only the automatic pings are being replied to.\r\n\r\nSee https://github.com/square/okhttp/issues/3261",
          "commitDate": "2018/2/22 上午9:17",
          "commitName": "abb0a790802996d1039c35424b70b0f3f06b94b7",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2018/2/17 下午6:24",
          "commitNameOld": "19726969aabbd0791d315994384a0cc46bf41648",
          "commitAuthorOld": "Yuri Schimke",
          "daysBetweenCommits": 4.62,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 130,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,59 +1,59 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                 if (rawSocket \u003d\u003d null) {\n                     break;\n                 }\n             } else {\n                 connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n-            establishProtocol(connectionSpecSelector, call, eventListener);\n+            establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);\n             eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n         ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n         throw new RouteException(exception);\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "1c98464839434a0fe7c7581cdae44bd3f2e6edd3": {
      "type": "Ybodychange",
      "commitMessage": "Move all failures into connectFailed and callFailed. (#3550)\n\nI think applications might be simple by tracking successful events\r\nseparately from failure events.",
      "commitDate": "2017/8/30 上午4:14",
      "commitName": "1c98464839434a0fe7c7581cdae44bd3f2e6edd3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2017/8/29 上午12:35",
      "commitNameOld": "cdc48ba8b0e4bdfccc208985bfef200220096d9d",
      "commitAuthorOld": "Yuri Schimke",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                 if (rawSocket \u003d\u003d null) {\n                     break;\n                 }\n             } else {\n                 connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n             establishProtocol(connectionSpecSelector, call, eventListener);\n-            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n+            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n-            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n+            eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n         ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n         throw new RouteException(exception);\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29267ac4e8eae099064483dc4c4b246690a92009": {
      "type": "Ybodychange",
      "commitMessage": "Fill out documentation for EventListener (#3475)\n\n* Fill out documentation for EventListener\r\n\r\n* rename connectionFound\r\n\r\n* tests for connectionFound updated\r\n\r\n* cleanup\r\n\r\n* address comment on body calls\r\n\r\n* Update EventListener.java\r\n\r\n* connect end event added a Proxy to match against start event\r\n",
      "commitDate": "2017/7/29 下午10:32",
      "commitName": "29267ac4e8eae099064483dc4c4b246690a92009",
      "commitAuthor": "Yuri Schimke",
      "commitDateOld": "2017/7/24 上午6:59",
      "commitNameOld": "1d8233ddb7a0dfa490a340a06433909148f21610",
      "commitAuthorOld": "ericaschulz",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,59 +1,59 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                 if (rawSocket \u003d\u003d null) {\n                     break;\n                 }\n             } else {\n                 connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n             establishProtocol(connectionSpecSelector, call, eventListener);\n-            eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n+            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol, null);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n-            eventListener.connectEnd(call, route.socketAddress(), null, e);\n+            eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n         ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n         throw new RouteException(exception);\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c7d508b79c9e201c91ec23f5eec47c18be206567": {
      "type": "Ybodychange",
      "commitMessage": "Add support for connect start/end events. (#3434)\n\n",
      "commitDate": "2017/7/6 下午9:55",
      "commitName": "c7d508b79c9e201c91ec23f5eec47c18be206567",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2017/7/2 下午10:10",
      "commitNameOld": "a32b1044a480aabbf4716d5c90b907c5ec46056c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n                if (rawSocket \u003d\u003d null) {\n                    break;\n                }\n            } else {\n                connectSocket(connectTimeout, readTimeout, call, eventListener);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            eventListener.connectEnd(call, route.socketAddress(), null, e);\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n        throw new RouteException(exception);\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 129,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,50 +1,59 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n-                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n+                connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);\n+                if (rawSocket \u003d\u003d null) {\n+                    break;\n+                }\n             } else {\n-                connectSocket(connectTimeout, readTimeout);\n+                connectSocket(connectTimeout, readTimeout, call, eventListener);\n             }\n             establishProtocol(connectionSpecSelector, call, eventListener);\n+            eventListener.connectEnd(call, route.socketAddress(), protocol, null);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n+            eventListener.connectEnd(call, route.socketAddress(), null, e);\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n+    if (route.requiresTunnel() \u0026\u0026 rawSocket \u003d\u003d null) {\n+        ProtocolException exception \u003d new ProtocolException(\"Too many tunnel connections attempted: \" + MAX_TUNNEL_ATTEMPTS);\n+        throw new RouteException(exception);\n+    }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5fb5ab50a77efc761489493d4a0b8b9de85feec7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
      "commitDate": "2017/6/20 下午9:14",
      "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
      "commitAuthor": "Dave Roberge",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
          "commitDate": "2017/6/20 下午9:14",
          "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
          "commitAuthor": "Dave Roberge",
          "commitDateOld": "2017/5/12 上午6:53",
          "commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
          "commitAuthorOld": "Kasra Bigdeli",
          "daysBetweenCommits": 39.6,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 126,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,50 +1,50 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout);\n             } else {\n                 connectSocket(connectTimeout, readTimeout);\n             }\n-            establishProtocol(connectionSpecSelector);\n+            establishProtocol(connectionSpecSelector, call, eventListener);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean, call-Call, eventListener-EventListener]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Added support for secure connect events.\n\nhttps://github.com/square/okhttp/issues/270\n",
          "commitDate": "2017/6/20 下午9:14",
          "commitName": "5fb5ab50a77efc761489493d4a0b8b9de85feec7",
          "commitAuthor": "Dave Roberge",
          "commitDateOld": "2017/5/12 上午6:53",
          "commitNameOld": "b8a0352d524b3d339e71a83b04c63eee8aa3f291",
          "commitAuthorOld": "Kasra Bigdeli",
          "daysBetweenCommits": 39.6,
          "commitsBetweenForRepo": 20,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector, call, eventListener);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 126,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,50 +1,50 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, Call call, EventListener eventListener) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout);\n             } else {\n                 connectSocket(connectTimeout, readTimeout);\n             }\n-            establishProtocol(connectionSpecSelector);\n+            establishProtocol(connectionSpecSelector, call, eventListener);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "98443a9ca8ca9ad82d5fb9b05b32f180bb510601": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017/1/8 上午3:15",
      "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
          "commitDate": "2017/1/8 上午3:15",
          "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
          "commitAuthor": "jwilson",
          "commitDateOld": "2017/1/3 上午1:36",
          "commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 121,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,50 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n+    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout);\n             } else {\n                 connectSocket(connectTimeout, readTimeout);\n             }\n             establishProtocol(connectionSpecSelector);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Release duplicated multiplexed connections.\n\nIf we make concurrent requests to an HTTP/2 server, close all but\nthe first connection. Creating multiple connections and then later\nreleasing them is somewhat pessimistic; it\u0027s also much safer for\nawkward cases like connect attempts being canceled.\n\nCloses: https://github.com/square/okhttp/issues/373\n",
          "commitDate": "2017/1/8 上午3:15",
          "commitName": "98443a9ca8ca9ad82d5fb9b05b32f180bb510601",
          "commitAuthor": "jwilson",
          "commitDateOld": "2017/1/3 上午1:36",
          "commitNameOld": "8331b2d75a51631bee622daf2175854fe49ce29a",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 5.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
          "functionStartLine": 121,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,50 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n+    List\u003cConnectionSpec\u003e connectionSpecs \u003d route.address().connectionSpecs();\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n     while (true) {\n         try {\n             if (route.requiresTunnel()) {\n                 connectTunnel(connectTimeout, readTimeout, writeTimeout);\n             } else {\n                 connectSocket(connectTimeout, readTimeout);\n             }\n             establishProtocol(connectionSpecSelector);\n             break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             http2Connection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n     if (http2Connection !\u003d null) {\n         synchronized (connectionPool) {\n             allocationLimit \u003d http2Connection.maxConcurrentStreams();\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "8331b2d75a51631bee622daf2175854fe49ce29a": {
      "type": "Ybodychange",
      "commitMessage": "Fix RealConnection to guard allocationLimit by connectionPool.\n\nI\u0027m working towards making OkHttp limit itself to a single HTTP/2 connection\nto a single host. In this work I found we\u0027re not sufficiently safe on\nallocationLimit - connections are added to the pool when this is 0, and\nthe value is updated without any synchronization.\n\nThis change also reduces the visibility of some connection fields in\nRealConnection and organizes the fields into two sets: those that are\nimmutable after connect and those that are guarded by connectionPool.\n\nhttps://github.com/square/okhttp/issues/373\n",
      "commitDate": "2017/1/3 上午1:36",
      "commitName": "8331b2d75a51631bee622daf2175854fe49ce29a",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/12/27 上午9:24",
      "commitNameOld": "a589b8170333476233d48476587a1d4363c90bd0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.68,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (true) {\n        try {\n            if (route.requiresTunnel()) {\n                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n            } else {\n                connectSocket(connectTimeout, readTimeout);\n            }\n            establishProtocol(connectionSpecSelector);\n            break;\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            http2Connection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n    if (http2Connection !\u003d null) {\n        synchronized (connectionPool) {\n            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 121,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,49 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null) {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n         }\n         String host \u003d route.address().url().host();\n         if (!Platform.get().isCleartextTrafficPermitted(host)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n         }\n     }\n-    while (protocol \u003d\u003d null) {\n+    while (true) {\n         try {\n             if (route.requiresTunnel()) {\n-                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+                connectTunnel(connectTimeout, readTimeout, writeTimeout);\n             } else {\n-                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+                connectSocket(connectTimeout, readTimeout);\n             }\n+            establishProtocol(connectionSpecSelector);\n+            break;\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n+            http2Connection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n+    if (http2Connection !\u003d null) {\n+        synchronized (connectionPool) {\n+            allocationLimit \u003d http2Connection.maxConcurrentStreams();\n+        }\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1f58b14bd18565b3dc4aaf15c072033e68b69660": {
      "type": "Ybodychange",
      "commitMessage": "Always pass a host to NetworkSecurityPolicy.isCleartextTrafficPermitted().\n\nPreviously we were misinterpretting which hosts this method applied to.\nSuppose an Android app was configured to require TLS for bank.com and\nnot for any other address. The NetworkSecurityPolicy.isCleartextTrafficPermitted()\nmethod would return false because cleartext traffic wasn\u0027t universally\npermitted. And OkHttp would incorrectly forbid cleartext communication\nto other hosts like puppies.com.\n\nCloses: https://github.com/square/okhttp/issues/2640\n",
      "commitDate": "2016/7/3 上午1:39",
      "commitName": "1f58b14bd18565b3dc4aaf15c072033e68b69660",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/27 上午11:04",
      "commitNameOld": "c5187583bbfe93fe58db80f95b5b478c84180c29",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 5.61,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null) {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n        }\n        String host \u003d route.address().url().host();\n        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n        }\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,41 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n-    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n+    if (route.address().sslSocketFactory() \u003d\u003d null) {\n+        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not enabled for client\"));\n+        }\n+        String host \u003d route.address().url().host();\n+        if (!Platform.get().isCleartextTrafficPermitted(host)) {\n+            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication to \" + host + \" not permitted by network security policy\"));\n+        }\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             if (route.requiresTunnel()) {\n                 buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             } else {\n                 buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             }\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5187583bbfe93fe58db80f95b5b478c84180c29": {
      "type": "Yfilerename",
      "commitMessage": "Add connection, cache, and platform subpackages.\n",
      "commitDate": "2016/6/27 上午11:04",
      "commitName": "c5187583bbfe93fe58db80f95b5b478c84180c29",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/6/27 上午9:10",
      "commitNameOld": "81b3a99aea8571942e5fb18b5c189c4596087076",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
        "newPath": "okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java"
      }
    },
    "576408374d58a3e9a63714b6f7761cb42a315102": {
      "type": "Yexceptionschange",
      "commitMessage": "Begin to fold together parts of RealCall and HttpEngine.\n\nPreviously we had an awkward, arbitrary separation because RealCall contained\nthe stuff that wasn\u0027t in HttpURLConnection, and HttpEngine contained everything\nthat was shared.\n\nIt was also awkward because HttpEngine could be interrupted in various parts\nof the HttpURLConnection flow: after connecting, while transmitting the request\nbody, etc. With this change we no longer need to handle API calls while we\u0027re\nin these intermediate states, which means we can reduce the scope of certain\nthings from fields to local variables.\n\nThere\u0027s still a way to go here but this is more easy wins.\n",
      "commitDate": "2016/6/24 上午10:54",
      "commitName": "576408374d58a3e9a63714b6f7761cb42a315102",
      "commitAuthor": "jwilson",
      "commitDateOld": "2016/4/11 上午3:02",
      "commitNameOld": "c9ad163e92fe252f23b743d694f68967a29eae7c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 74.33,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             if (route.requiresTunnel()) {\n                 buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             } else {\n                 buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             }\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[RouteException]",
        "newValue": "[]"
      }
    },
    "03a840de533b1f1c201aa4e99f95f42f9a8269a4": {
      "type": "Ybodychange",
      "commitMessage": "Accommodate tunneling proxies that close the connection after an auth challenge.\n",
      "commitDate": "2016/4/8 下午7:56",
      "commitName": "03a840de533b1f1c201aa4e99f95f42f9a8269a4",
      "commitAuthor": "Dave Roberge",
      "commitDateOld": "2016/2/22 下午1:13",
      "commitNameOld": "7ceaa2387f0be853222f5a1496f1f743fa6f8c6d",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 46.28,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            if (route.requiresTunnel()) {\n                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            } else {\n                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            }\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,35 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy \u003d route.proxy();\n-    Address address \u003d route.address();\n     if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n-            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n-            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+            if (route.requiresTunnel()) {\n+                buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+            } else {\n+                buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n+            }\n         } catch (IOException e) {\n             closeQuietly(socket);\n             closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9a89876de476983f273edbf108c365127c18c5e": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
      "commitDate": "2015/12/16 下午2:34",
      "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
          "commitDate": "2015/12/16 下午2:34",
          "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/16 上午10:36",
          "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
          "functionStartLine": 88,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,34 +1,34 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n     if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n-            Util.closeQuietly(socket);\n-            Util.closeQuietly(rawSocket);\n+            closeQuietly(socket);\n+            closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
            "newPath": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
            "oldMethodName": "connect",
            "newMethodName": "connect"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Rename com.squareup.okhttp to okhttp3\n\nMaven group changes will come in follow up.\n",
          "commitDate": "2015/12/16 下午2:34",
          "commitName": "c9a89876de476983f273edbf108c365127c18c5e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/12/16 上午10:36",
          "commitNameOld": "54dc2df914f2aae37fb48cc2c2f7560ee664bc2b",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            closeQuietly(socket);\n            closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/okhttp3/internal/io/RealConnection.java",
          "functionStartLine": 88,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,34 +1,34 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n     if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n-            Util.closeQuietly(socket);\n-            Util.closeQuietly(rawSocket);\n+            closeQuietly(socket);\n+            closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b63841d3a3922440c258098190371f1e17d977c1": {
      "type": "Ybodychange",
      "commitMessage": "Drop \u0027get\u0027 prefixed on Address value type.\n",
      "commitDate": "2015/12/15 下午1:57",
      "commitName": "b63841d3a3922440c258098190371f1e17d977c1",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015/12/15 下午1:45",
      "commitNameOld": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 88,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.proxy();\n     Address address \u003d route.address();\n-    if (route.address().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+    if (route.address().sslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n-            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n+            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             Util.closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "71ae4df298f42039579fd6e3c6d9d9060ac91214": {
      "type": "Ybodychange",
      "commitMessage": "Drop \u0027get\u0027 prefixed on Route value type.\n",
      "commitDate": "2015/12/15 下午1:45",
      "commitName": "71ae4df298f42039579fd6e3c6d9d9060ac91214",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015/12/15 上午4:11",
      "commitNameOld": "93d547dcdaecddfa456aee0571131db2342e5abb",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.4,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.proxy();\n    Address address \u003d route.address();\n    if (route.address().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 88,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,34 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n-    Proxy proxy \u003d route.getProxy();\n-    Address address \u003d route.getAddress();\n-    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+    Proxy proxy \u003d route.proxy();\n+    Address address \u003d route.address();\n+    if (route.address().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             Util.closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c5f58e45454d1ffc621c65e377cb91345018e087": {
      "type": "Ybodychange",
      "commitMessage": "Honor the max concurrent streams setting.\n\nCloses https://github.com/square/okhttp/issues/1484\n",
      "commitDate": "2015/12/3 上午1:44",
      "commitName": "c5f58e45454d1ffc621c65e377cb91345018e087",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/12/1 上午11:57",
      "commitNameOld": "7fc2993c427ef7c36430a4efa5d5c1d5dd5e0dc9",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.57,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 84,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,34 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n     if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             Util.closeQuietly(rawSocket);\n             socket \u003d null;\n             rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n-            framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee87f8036f99fdfd63f8ef145f4478907682db29": {
      "type": "Ybodychange",
      "commitMessage": "Change async cancel to cancel the raw socket only.\n\nPreviously we could close an SSL socket which does synchronous I/O. This\nmade it unreasonable to cancel a call on a UI thread.\n\nCloses: https://github.com/square/okhttp/issues/1592\n",
      "commitDate": "2015/11/30 上午11:58",
      "commitName": "ee87f8036f99fdfd63f8ef145f4478907682db29",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/11/28 下午10:36",
      "commitNameOld": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 1.56,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            Util.closeQuietly(rawSocket);\n            socket \u003d null;\n            rawSocket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            framedConnection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
      "functionStartLine": 86,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,35 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n     if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n-            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n+            rawSocket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n+            Util.closeQuietly(rawSocket);\n             socket \u003d null;\n+            rawSocket \u003d null;\n             source \u003d null;\n             sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n             framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c358656c8799d30fd422448153e99a5dd37e298a": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "First draft of the new new stream allocations model.\n",
      "commitDate": "2015/11/28 下午10:36",
      "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015/11/28 下午10:36",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/11/27 下午12:28",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            framedConnection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,32 +1,33 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n-    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n+            source \u003d null;\n+            sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n-            httpConnection \u003d null;\n             framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
            "newPath": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
            "oldMethodName": "connect",
            "newMethodName": "connect"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015/11/28 下午10:36",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/11/27 下午12:28",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            framedConnection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,32 +1,33 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n-    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n+            source \u003d null;\n+            sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n-            httpConnection \u003d null;\n             framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "First draft of the new new stream allocations model.\n",
          "commitDate": "2015/11/28 下午10:36",
          "commitName": "c358656c8799d30fd422448153e99a5dd37e298a",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/11/27 下午12:28",
          "commitNameOld": "e0d34ebdd7aba18149d195804075a87b97f3c02d",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            source \u003d null;\n            sink \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            framedConnection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/internal/io/RealConnection.java",
          "functionStartLine": 78,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,32 +1,33 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n-    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+    if (route.getAddress().getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (protocol \u003d\u003d null) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n+            source \u003d null;\n+            sink \u003d null;\n             handshake \u003d null;\n             protocol \u003d null;\n-            httpConnection \u003d null;\n             framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d": {
      "type": "Ybodychange",
      "commitMessage": "Stop returning HTTP/1.0 from Connection.getProtocol().\n\nThis was updating the protocol as a side-effect of an HTTP/1.0 response.\nThis made the protocol field mutable, and the code more difficult to\ntrace.\n\nOne consequence of this change is that OkHttp will attempt HTTP/1.1 for\nall requests, even if a server returns HTTP/1.0 from the first response.\nThis is closer to our implementation anyway.\n",
      "commitDate": "2015/11/18 下午1:01",
      "commitName": "529c4a36bb21b3fb7717c27f8a31c39c1b603e9d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/11/15 上午11:28",
      "commitNameOld": "457fb428a729c50c562822571ea9b13e689648f3",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (protocol !\u003d null)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (protocol \u003d\u003d null) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            handshake \u003d null;\n            protocol \u003d null;\n            httpConnection \u003d null;\n            framedConnection \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 152,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,29 +1,32 @@\n void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n-    if (connected)\n+    if (protocol !\u003d null)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n     if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n-    while (!connected) {\n+    while (protocol \u003d\u003d null) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n             connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n-            connected \u003d true;\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n+            handshake \u003d null;\n+            protocol \u003d null;\n+            httpConnection \u003d null;\n+            framedConnection \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "457fb428a729c50c562822571ea9b13e689648f3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
      "commitDate": "2015/11/15 上午11:28",
      "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
          "commitDate": "2015/11/15 上午11:28",
          "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/8/25 上午10:43",
          "commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 82.03,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (!connected) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            connected \u003d true;\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 153,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,29 +1,29 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n     if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (!connected) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n-            connectSocket(connectTimeout, readTimeout, writeTimeout, request, connectionSpecSelector);\n+            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             connected \u003d true;\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Don\u0027t use the request to build the proxy tunnel.\n\nThe tunnel is shared between requests, and it\u0027s awkward to build that with the\nfirst request that needs it.\n",
          "commitDate": "2015/11/15 上午11:28",
          "commitName": "457fb428a729c50c562822571ea9b13e689648f3",
          "commitAuthor": "jwilson",
          "commitDateOld": "2015/8/25 上午10:43",
          "commitNameOld": "ebaaf10ec1f861b2d4b455e01d3118568f4c6f51",
          "commitAuthorOld": "jwilson",
          "daysBetweenCommits": 82.03,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (!connected) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n            connected \u003d true;\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 153,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,29 +1,29 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     RouteException routeException \u003d null;\n     ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n     Proxy proxy \u003d route.getProxy();\n     Address address \u003d route.getAddress();\n     if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n         throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n     while (!connected) {\n         try {\n             socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n-            connectSocket(connectTimeout, readTimeout, writeTimeout, request, connectionSpecSelector);\n+            connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);\n             connected \u003d true;\n         } catch (IOException e) {\n             Util.closeQuietly(socket);\n             socket \u003d null;\n             if (routeException \u003d\u003d null) {\n                 routeException \u003d new RouteException(e);\n             } else {\n                 routeException.addConnectException(e);\n             }\n             if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                 throw routeException;\n             }\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "b42e73f497eafe147667117202267ec756adff26": {
      "type": "Ybodychange",
      "commitMessage": "Make call canceling more reliable.\n\nWe had a bug where the socket-being-connected wasn\u0027t being closed when the\napplication used Call.cancel(). The problem is that the SocketConnector model\nassumes the Connection doesn\u0027t want a Socket instance until it\u0027s fully\nconnected.\n\nThis moves the SocketConnector code back into Connection, removes a lot of\nnested try/catch blocks, and assigns a Socket instance as soon as its created.\n\nThis also likely fixes some bugs where sockets weren\u0027t being closed when\nan IOException or RouteException was thrown during connection. Now we always\nclose at the top level of connect() unless the connection is successful.\n\nhttps://github.com/square/okhttp/issues/1779\n",
      "commitDate": "2015/8/2 上午7:54",
      "commitName": "b42e73f497eafe147667117202267ec756adff26",
      "commitAuthor": "jwilson",
      "commitDateOld": "2015/6/18 上午6:40",
      "commitNameOld": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 45.05,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    RouteException routeException \u003d null;\n    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n    Proxy proxy \u003d route.getProxy();\n    Address address \u003d route.getAddress();\n    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n    }\n    while (!connected) {\n        try {\n            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n            connectSocket(connectTimeout, readTimeout, writeTimeout, request, connectionSpecSelector);\n            connected \u003d true;\n        } catch (IOException e) {\n            Util.closeQuietly(socket);\n            socket \u003d null;\n            if (routeException \u003d\u003d null) {\n                routeException \u003d new RouteException(e);\n            } else {\n                routeException.addConnectException(e);\n            }\n            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n                throw routeException;\n            }\n        }\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 153,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,29 +1,29 @@\n void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n-    SocketConnector.ConnectedSocket connectedSocket;\n-    if (route.address.getSslSocketFactory() !\u003d null) {\n-        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n-    } else {\n-        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n-            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n-        }\n-        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n+    RouteException routeException \u003d null;\n+    ConnectionSpecSelector connectionSpecSelector \u003d new ConnectionSpecSelector(connectionSpecs);\n+    Proxy proxy \u003d route.getProxy();\n+    Address address \u003d route.getAddress();\n+    if (route.address.getSslSocketFactory() \u003d\u003d null \u0026\u0026 !connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+        throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n     }\n-    socket \u003d connectedSocket.socket;\n-    handshake \u003d connectedSocket.handshake;\n-    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n-    try {\n-        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n-            socket.setSoTimeout(0);\n-            framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n-            framedConnection.sendConnectionPreface();\n-        } else {\n-            httpConnection \u003d new HttpConnection(pool, this, socket);\n+    while (!connected) {\n+        try {\n+            socket \u003d proxy.type() \u003d\u003d Proxy.Type.DIRECT || proxy.type() \u003d\u003d Proxy.Type.HTTP ? address.getSocketFactory().createSocket() : new Socket(proxy);\n+            connectSocket(connectTimeout, readTimeout, writeTimeout, request, connectionSpecSelector);\n+            connected \u003d true;\n+        } catch (IOException e) {\n+            Util.closeQuietly(socket);\n+            socket \u003d null;\n+            if (routeException \u003d\u003d null) {\n+                routeException \u003d new RouteException(e);\n+            } else {\n+                routeException.addConnectException(e);\n+            }\n+            if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {\n+                throw routeException;\n+            }\n         }\n-    } catch (IOException e) {\n-        throw new RouteException(e);\n     }\n-    connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c753d2e41ba667f9b5a31451a16ecbaecdc65d80": {
      "type": "Ybodychange",
      "commitMessage": "Rename \u0027spdy\u0027 references to \u0027framed\u0027 where appropriate.\n",
      "commitDate": "2015/6/18 上午6:40",
      "commitName": "c753d2e41ba667f9b5a31451a16ecbaecdc65d80",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2015/4/21 上午10:09",
      "commitNameOld": "b0b000e29668517d21c37c696100bc8331117516",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 57.85,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            framedConnection.sendConnectionPreface();\n        } else {\n            httpConnection \u003d new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 135,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,29 +1,29 @@\n void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n     SocketConnector.ConnectedSocket connectedSocket;\n     if (route.address.getSslSocketFactory() !\u003d null) {\n         connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n         if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n             throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n         }\n         connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n     socket \u003d connectedSocket.socket;\n     handshake \u003d connectedSocket.handshake;\n     protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n     try {\n         if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n             socket.setSoTimeout(0);\n-            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n-            spdyConnection.sendConnectionPreface();\n+            framedConnection \u003d new FramedConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n+            framedConnection.sendConnectionPreface();\n         } else {\n             httpConnection \u003d new HttpConnection(pool, this, socket);\n         }\n     } catch (IOException e) {\n         throw new RouteException(e);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "60f5406dcc094d0431420139bd002e8bdd4ea5d5": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
      "commitDate": "2015/3/18 下午11:59",
      "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
      "commitAuthor": "Neil Fuller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015/3/18 下午11:59",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015/2/10 下午12:30",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            spdyConnection.sendConnectionPreface();\n        } else {\n            httpConnection \u003d new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected \u003d true;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,17 +1,29 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-        socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-        socket \u003d new Socket(route.proxy);\n+        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n+        }\n+        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n-    if (route.address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n+    try {\n+        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+            socket.setSoTimeout(0);\n+            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n+            spdyConnection.sendConnectionPreface();\n+        } else {\n+            httpConnection \u003d new HttpConnection(pool, this, socket);\n+        }\n+    } catch (IOException e) {\n+        throw new RouteException(e);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, request-Request, connectionSpecs-List\u003cConnectionSpec\u003e, connectionRetryEnabled-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015/3/18 下午11:59",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015/2/10 下午12:30",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            spdyConnection.sendConnectionPreface();\n        } else {\n            httpConnection \u003d new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected \u003d true;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,17 +1,29 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-        socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-        socket \u003d new Socket(route.proxy);\n+        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n+        }\n+        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n-    if (route.address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n+    try {\n+        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+            socket.setSoTimeout(0);\n+            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n+            spdyConnection.sendConnectionPreface();\n+        } else {\n+            httpConnection \u003d new HttpConnection(pool, this, socket);\n+        }\n+    } catch (IOException e) {\n+        throw new RouteException(e);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[RouteException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Move TLS retries / fallback into Connection.\n\nAPI changes:\n1) Added: Address.getCertificatePinner()\n2) Incompatible API change: Address constructor no longer\nincludes ConnectionSpecs. Removed getConnectionSpecs().\n3) Added: ConnectionSpec.isCompatible(SSLSocket)\n4) Added: TlsVersion.javaName()\n\nImplicit / semantic / internal changes:\n\n1) Connection now handles all attempts to connect via a route\n(effectively a {proxy, socket address} pair), rather than just\none attempt. i.e. Connection now handles all the TLS negotiation\nfallbacks internally.\n\n2) Route no longer deals with TLS versions. Individual TLS\nfailures are not counted against a Route. If no connection\nattempts to a route were successful the failure is counted\nagainst the route.\n\n3) The code makes a distinction between when various\nIOExceptions occur, with the intention making retries a bit\nsmarter. It is now more obvious which exceptions happen during\nsetup (RequestException), connection (RouteException),\nHTTP communication and thus which can be retried and whether\nthe request might have been sent.\n",
          "commitDate": "2015/3/18 下午11:59",
          "commitName": "60f5406dcc094d0431420139bd002e8bdd4ea5d5",
          "commitAuthor": "Neil Fuller",
          "commitDateOld": "2015/2/10 下午12:30",
          "commitNameOld": "cc94dea6d7fad79e531ee723c31e2d92fb7ccf98",
          "commitAuthorOld": "Kirill Boyarshinov",
          "daysBetweenCommits": 36.48,
          "commitsBetweenForRepo": 41,
          "commitsBetweenForFile": 1,
          "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n    SocketConnector.ConnectedSocket connectedSocket;\n    if (route.address.getSslSocketFactory() !\u003d null) {\n        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n    } else {\n        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n        }\n        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n    }\n    socket \u003d connectedSocket.socket;\n    handshake \u003d connectedSocket.handshake;\n    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n    try {\n        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n            socket.setSoTimeout(0);\n            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n            spdyConnection.sendConnectionPreface();\n        } else {\n            httpConnection \u003d new HttpConnection(pool, this, socket);\n        }\n    } catch (IOException e) {\n        throw new RouteException(e);\n    }\n    connected \u003d true;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 133,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,17 +1,29 @@\n-void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, Request request, List\u003cConnectionSpec\u003e connectionSpecs, boolean connectionRetryEnabled) throws RouteException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n-        socket \u003d route.address.socketFactory.createSocket();\n+    SocketConnector socketConnector \u003d new SocketConnector(this, pool);\n+    SocketConnector.ConnectedSocket connectedSocket;\n+    if (route.address.getSslSocketFactory() !\u003d null) {\n+        connectedSocket \u003d socketConnector.connectTls(connectTimeout, readTimeout, writeTimeout, request, route, connectionSpecs, connectionRetryEnabled);\n     } else {\n-        socket \u003d new Socket(route.proxy);\n+        if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) {\n+            throw new RouteException(new UnknownServiceException(\"CLEARTEXT communication not supported: \" + connectionSpecs));\n+        }\n+        connectedSocket \u003d socketConnector.connectCleartext(connectTimeout, readTimeout, route);\n     }\n-    socket.setSoTimeout(readTimeout);\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n-    if (route.address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n-    } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+    socket \u003d connectedSocket.socket;\n+    handshake \u003d connectedSocket.handshake;\n+    protocol \u003d connectedSocket.alpnProtocol \u003d\u003d null ? Protocol.HTTP_1_1 : connectedSocket.alpnProtocol;\n+    try {\n+        if (protocol \u003d\u003d Protocol.SPDY_3 || protocol \u003d\u003d Protocol.HTTP_2) {\n+            socket.setSoTimeout(0);\n+            spdyConnection \u003d new SpdyConnection.Builder(route.address.uriHost, true, socket).protocol(protocol).build();\n+            spdyConnection.sendConnectionPreface();\n+        } else {\n+            httpConnection \u003d new HttpConnection(pool, this, socket);\n+        }\n+    } catch (IOException e) {\n+        throw new RouteException(e);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6d9f9cbdf8069e504cb58908db23b4f327d1826c": {
      "type": "Ybodychange",
      "commitMessage": "Use the socket factory for direct connections as well.\n\nCurrently, the passed-in socket factory is only used for\nconnections to HTTP proxies. I think this was not the intent of\nthe original socket factory change, because the commit message\nsaid that the \"socket factory will be used for all non-proxy\nconnections and HTTP proxy connections\".  So use it for DIRECT\nconnections as well.\n\nAlso add a test to check that a socket factory is used if\nspecified.\n\nChange-Id: I811b08442d1c80be1a0a268eb51c9aa365febf00\n",
      "commitDate": "2014/7/22 上午3:34",
      "commitName": "6d9f9cbdf8069e504cb58908db23b4f327d1826c",
      "commitAuthor": "Lorenzo Colitti",
      "commitDateOld": "2014/6/28 下午10:57",
      "commitNameOld": "7bb06e78bac05e0e24c6ea81b34aa11f498ad61f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 23.19,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n        socket \u003d route.address.socketFactory.createSocket();\n    } else {\n        socket \u003d new Socket(route.proxy);\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 139,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n-        socket \u003d new Socket(route.proxy);\n-    } else {\n+    if (route.proxy.type() \u003d\u003d Proxy.Type.DIRECT || route.proxy.type() \u003d\u003d Proxy.Type.HTTP) {\n         socket \u003d route.address.socketFactory.createSocket();\n+    } else {\n+        socket \u003d new Socket(route.proxy);\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n         httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1044d9eea21d8be54c195fff75ca0a7b9bba79b3": {
      "type": "Ymodifierchange",
      "commitMessage": "Hide more APIs with Internal.access.\n\nThe callsite is uglier but the API is neater. I think overall\nit\u0027s a small win.\n",
      "commitDate": "2014/5/1 上午9:36",
      "commitName": "1044d9eea21d8be54c195fff75ca0a7b9bba79b3",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/5/1 上午12:16",
      "commitNameOld": "853b4e35f1ddbf3c5db1d91c7ff02c2d979da86f",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 138,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n+void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n         socket \u003d new Socket(route.proxy);\n     } else {\n         socket \u003d route.address.socketFactory.createSocket();\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n         httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[]"
      }
    },
    "b60875421b0f67575970b6b63582b7e5e31c4a06": {
      "type": "Ybodychange",
      "commitMessage": "Update Okio timeouts when recycling connections.\n",
      "commitDate": "2014/4/20 下午11:49",
      "commitName": "b60875421b0f67575970b6b63582b7e5e31c4a06",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/4/20 下午10:10",
      "commitNameOld": "da484932625ab15681e469c1680b6371b8f67080",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n         socket \u003d new Socket(route.proxy);\n     } else {\n         socket \u003d route.address.socketFactory.createSocket();\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n+        httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "da484932625ab15681e469c1680b6371b8f67080": {
      "type": "Yparameterchange",
      "commitMessage": "Replace TunnelRequest with a regular Request.\n",
      "commitDate": "2014/4/20 下午10:10",
      "commitName": "da484932625ab15681e469c1680b6371b8f67080",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/4/20 下午3:27",
      "commitNameOld": "a9b4ec6bb771472136fb86562ab4a3d9baee0390",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,17 @@\n-public void connect(int connectTimeout, int readTimeout, int writeTimeout, TunnelRequest tunnelRequest) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n         socket \u003d new Socket(route.proxy);\n     } else {\n         socket \u003d route.address.socketFactory.createSocket();\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n         httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]",
        "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-Request]"
      }
    },
    "41aa4b6805141369d614964152d329a686aabdb8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
      "commitDate": "2014/4/19 上午5:06",
      "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
          "commitDate": "2014/4/19 上午5:06",
          "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2014/4/15 下午3:53",
          "commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 3.55,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 137,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,17 +1,17 @@\n-public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n         socket \u003d new Socket(route.proxy);\n     } else {\n         socket \u003d route.address.socketFactory.createSocket();\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelRequest);\n+        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]",
            "newValue": "[connectTimeout-int, readTimeout-int, writeTimeout-int, tunnelRequest-TunnelRequest]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Implement write timeouts for HTTP/1.1 streams.\n",
          "commitDate": "2014/4/19 上午5:06",
          "commitName": "41aa4b6805141369d614964152d329a686aabdb8",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2014/4/15 下午3:53",
          "commitNameOld": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 3.55,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, int writeTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n    }\n    connected \u003d true;\n}",
          "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 137,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,17 +1,17 @@\n-public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, int writeTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n         socket \u003d new Socket(route.proxy);\n     } else {\n         socket \u003d route.address.socketFactory.createSocket();\n     }\n     socket.setSoTimeout(readTimeout);\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelRequest);\n+        upgradeToTls(tunnelRequest, readTimeout, writeTimeout);\n     } else {\n-        httpConnection \u003d new HttpConnection(pool, this, socket);\n+        httpConnection \u003d new HttpConnection(pool, this, socket, readTimeout, writeTimeout);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f": {
      "type": "Ybodychange",
      "commitMessage": "Allow specifying a socket factory for connections.\n\nThis socket factory will be used for all non-proxy connections and HTTP proxy connections.\n",
      "commitDate": "2014/4/15 下午3:53",
      "commitName": "ff5390d6dcaf79ef09a3ef94dbb7e8ac39572a7f",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2014/3/31 上午8:09",
      "commitNameOld": "6c57d76915a7e79cc8b8f743ccd8ecc35889ce7c",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 15.32,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n        socket \u003d new Socket(route.proxy);\n    } else {\n        socket \u003d route.address.socketFactory.createSocket();\n    }\n    socket.setSoTimeout(readTimeout);\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 137,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,13 +1,17 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n+    if (route.proxy.type() !\u003d Proxy.Type.HTTP) {\n+        socket \u003d new Socket(route.proxy);\n+    } else {\n+        socket \u003d route.address.socketFactory.createSocket();\n+    }\n     socket.setSoTimeout(readTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d78da7ce7e60d93fe8e299a83b963cd220a60ad": {
      "type": "Ybodychange",
      "commitMessage": "Push Socket into HttpConnection/SpdyConnection.\n",
      "commitDate": "2014/3/12 下午12:20",
      "commitName": "8d78da7ce7e60d93fe8e299a83b963cd220a60ad",
      "commitAuthor": "Jesse Wilson",
      "commitDateOld": "2014/3/3 下午3:14",
      "commitNameOld": "98f60cc9f0b1af08803dde269386877b9cf1c7d3",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 8.88,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        httpConnection \u003d new HttpConnection(pool, this, socket);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 80,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,13 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n-    in \u003d socket.getInputStream();\n-    out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n-        initSourceAndSink();\n-        httpConnection \u003d new HttpConnection(pool, this, source, sink);\n+        httpConnection \u003d new HttpConnection(pool, this, socket);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4": {
      "type": "Ybodychange",
      "commitMessage": "Use BufferedSink in HttpConnection.\n",
      "commitDate": "2014/2/24 上午1:55",
      "commitName": "c16436f8b2020e4bb2cbdddbd0eddd5ae5c528c4",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/2/24 上午12:42",
      "commitNameOld": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        initSourceAndSink();\n        httpConnection \u003d new HttpConnection(pool, this, source, sink);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n-        streamWrapper(true);\n-        httpConnection \u003d new HttpConnection(pool, this, source, out);\n+        initSourceAndSink();\n+        httpConnection \u003d new HttpConnection(pool, this, source, sink);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ab78dadb4bb94db74770e179e04e2ed791c4a51e": {
      "type": "Ybodychange",
      "commitMessage": "Use BufferedSink in SPDY and HTTP/2.\n",
      "commitDate": "2014/2/24 上午12:42",
      "commitName": "ab78dadb4bb94db74770e179e04e2ed791c4a51e",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/2/23 上午5:08",
      "commitNameOld": "095448552ee41e62e58994be0f424df750c6822f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper(true);\n        httpConnection \u003d new HttpConnection(pool, this, source, out);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 90,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n-        streamWrapper();\n+        streamWrapper(true);\n         httpConnection \u003d new HttpConnection(pool, this, source, out);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a669069599893a774748181a238e0b009a4f3e87": {
      "type": "Ybodychange",
      "commitMessage": "Use OkBuffer+Source in HttpEngine.\n",
      "commitDate": "2014/2/18 下午3:33",
      "commitName": "a669069599893a774748181a238e0b009a4f3e87",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/2/16 上午7:44",
      "commitNameOld": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 2.33,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n        httpConnection \u003d new HttpConnection(pool, this, source, out);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 89,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         streamWrapper();\n-        httpConnection \u003d new HttpConnection(pool, this, in, out);\n+        httpConnection \u003d new HttpConnection(pool, this, source, out);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3": {
      "type": "Ybodychange",
      "commitMessage": "Move connection pooling logic.\n\nPreviously we had this ugly, awkward release() method that\nattempted to manage connection pooling, discarding streams\nfor caching, and closing broken streams.\n\nMove connection reuse to HttpConnection, with policy informed\nby HttpEngine. It specifies what to do when the connection\nbecomes idle: pool, close or hold. The connection does what\nit\u0027s told.\n",
      "commitDate": "2014/2/16 上午7:44",
      "commitName": "dac5aed3d5f9307b9d1ab0a8c7840b232d053ef3",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/2/16 上午2:30",
      "commitNameOld": "322e9f3700be4b9ebcf8b004d82868da71f919c5",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n        httpConnection \u003d new HttpConnection(pool, this, in, out);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 86,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         streamWrapper();\n-        httpConnection \u003d new HttpConnection(in, out);\n+        httpConnection \u003d new HttpConnection(pool, this, in, out);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "504b9cf55afd9d642e2a5323e18f79db607ad1a9": {
      "type": "Ybodychange",
      "commitMessage": "Split HttpTransport in two.\n\nThe new (awkwardly-named) HttpConnection class now owns the\nsocket, and stays around between HTTP requests. It matches\nSpdyConnection in lifecycle: it is tied to the socket.\n\nThe HTTP transport class is a dumb adapter that adapts the\nprotocol-specific decisions (chunked-encoding, content-length\nstuff).\n\nThis should make it possible to make significant simplifications\nto how connection recycling works: in a follow up change the\nHttpConnection class will know when it can be recycled and take\nthat action automatically.\n",
      "commitDate": "2014/2/15 上午5:23",
      "commitName": "504b9cf55afd9d642e2a5323e18f79db607ad1a9",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/27 上午7:09",
      "commitNameOld": "32a2b1d8d000a19d4a340cc1d77a68973a9d65dc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 18.93,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n        httpConnection \u003d new HttpConnection(in, out);\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 85,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         streamWrapper();\n+        httpConnection \u003d new HttpConnection(in, out);\n     }\n     connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ed2ee02570bac36b89bd93836e200840cb8fa59d": {
      "type": "Ybodychange",
      "commitMessage": "Connected after everything is initialized\n",
      "commitDate": "2014/1/9 上午11:10",
      "commitName": "ed2ee02570bac36b89bd93836e200840cb8fa59d",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2014/1/6 上午7:56",
      "commitNameOld": "656bca2dc8bc9f2f13b8aa42e0bdd3b94202f527",
      "commitAuthorOld": "Adrian Cole",
      "daysBetweenCommits": 3.13,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n    }\n    connected \u003d true;\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 108,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,15 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         streamWrapper();\n     }\n+    connected \u003d true;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dbca0acc6f8c188dfa48f07bb5886606bec8d28f": {
      "type": "Ybodychange",
      "commitMessage": "Kill the Policy interface.\n\nThis interface was necessary while cleaning up the delicate\nintertwined relationship between HttpURLConnection and HttpEngine.\nWith this change HttpEngine no longer has a reverse dependency\non HttpURLConnection.\n",
      "commitDate": "2014/1/1 下午11:30",
      "commitName": "dbca0acc6f8c188dfa48f07bb5886606bec8d28f",
      "commitAuthor": "jwilson",
      "commitDateOld": "2014/1/1 上午9:52",
      "commitNameOld": "957537774b319bb0109819258a11af78a98bcb97",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected)\n        throw new IllegalStateException(\"already connected\");\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,15 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n-    if (connected) {\n+    if (connected)\n         throw new IllegalStateException(\"already connected\");\n-    }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n         streamWrapper();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa": {
      "type": "Ybodychange",
      "commitMessage": "extract a method\n",
      "commitDate": "2013/12/23 下午5:02",
      "commitName": "35ead0f5d17b0c53610b0947aa9bd8fee6da50fa",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2013/12/22 上午11:22",
      "commitNameOld": "13c06879f4e98c86436bdca765046ef815e34838",
      "commitAuthorOld": "lingming.yb",
      "daysBetweenCommits": 1.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        streamWrapper();\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 94,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,16 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     } else {\n-        int mtu \u003d Platform.get().getMtu(socket);\n-        if (mtu \u003c 1024)\n-            mtu \u003d 1024;\n-        if (mtu \u003e 8192)\n-            mtu \u003d 8192;\n-        in \u003d new BufferedInputStream(in, mtu);\n-        out \u003d new BufferedOutputStream(out, mtu);\n+        streamWrapper();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13c06879f4e98c86436bdca765046ef815e34838": {
      "type": "Ybodychange",
      "commitMessage": "Buffered Stream wrapper should be taken place before SpdyConnection build.\n",
      "commitDate": "2013/12/22 上午11:22",
      "commitName": "13c06879f4e98c86436bdca765046ef815e34838",
      "commitAuthor": "lingming.yb",
      "commitDateOld": "2013/9/30 上午4:08",
      "commitNameOld": "29ab48bf0dfbac1b249f2233de08fa948bad11d8",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 83.3,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    } else {\n        int mtu \u003d Platform.get().getMtu(socket);\n        if (mtu \u003c 1024)\n            mtu \u003d 1024;\n        if (mtu \u003e 8192)\n            mtu \u003d 8192;\n        in \u003d new BufferedInputStream(in, mtu);\n        out \u003d new BufferedOutputStream(out, mtu);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 94,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,22 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n+    } else {\n+        int mtu \u003d Platform.get().getMtu(socket);\n+        if (mtu \u003c 1024)\n+            mtu \u003d 1024;\n+        if (mtu \u003e 8192)\n+            mtu \u003d 8192;\n+        in \u003d new BufferedInputStream(in, mtu);\n+        out \u003d new BufferedOutputStream(out, mtu);\n     }\n-    int mtu \u003d Platform.get().getMtu(socket);\n-    if (mtu \u003c 1024)\n-        mtu \u003d 1024;\n-    if (mtu \u003e 8192)\n-        mtu \u003d 8192;\n-    in \u003d new BufferedInputStream(in, mtu);\n-    out \u003d new BufferedOutputStream(out, mtu);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d66810bf0efbfad5c2afb9b304e1091ac6107a65": {
      "type": "Ybodychange",
      "commitMessage": "Catch SecurityExceptions from socket connects.\n\nVersions of android prior to 4.3 would throw RTEs\nif the underlying socket threw an EACCES error.\n\nSee change 50144 on the Android Open Source Project.\n",
      "commitDate": "2013/7/11 下午6:39",
      "commitName": "d66810bf0efbfad5c2afb9b304e1091ac6107a65",
      "commitAuthor": "Narayan Kamath",
      "commitDateOld": "2013/5/10 下午9:06",
      "commitNameOld": "3ba54eed34c9d5e41965587660a76a06806180a0",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 61.9,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 1024)\n        mtu \u003d 1024;\n    if (mtu \u003e 8192)\n        mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n-    socket.connect(route.inetSocketAddress, connectTimeout);\n+    Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n     int mtu \u003d Platform.get().getMtu(socket);\n     if (mtu \u003c 1024)\n         mtu \u003d 1024;\n     if (mtu \u003e 8192)\n         mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3ba54eed34c9d5e41965587660a76a06806180a0": {
      "type": "Ybodychange",
      "commitMessage": "Bump the minimum MTU up to 1KiB.\n\nIf anyone is getting -1 from getMtu, we should give them a more\nreasonable default.\n",
      "commitDate": "2013/5/10 下午9:06",
      "commitName": "3ba54eed34c9d5e41965587660a76a06806180a0",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/5/10 下午8:53",
      "commitNameOld": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 1024)\n        mtu \u003d 1024;\n    if (mtu \u003e 8192)\n        mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,21 +1,21 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n     int mtu \u003d Platform.get().getMtu(socket);\n-    if (mtu \u003c 256)\n-        mtu \u003d 256;\n+    if (mtu \u003c 1024)\n+        mtu \u003d 1024;\n     if (mtu \u003e 8192)\n         mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc": {
      "type": "Ybodychange",
      "commitMessage": "Clamp the MTU to a reasonable range.\n\nhttps://github.com/square/okhttp/issues/183\n",
      "commitDate": "2013/5/10 下午8:53",
      "commitName": "bb1b1a2c5c6c93df75526a2d5bf5c19817402fbc",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/5/4 上午7:36",
      "commitNameOld": "aee4bff8044f4189eedacb78be37d48cc7ef226f",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 6.55,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    int mtu \u003d Platform.get().getMtu(socket);\n    if (mtu \u003c 256)\n        mtu \u003d 256;\n    if (mtu \u003e 8192)\n        mtu \u003d 8192;\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,17 +1,21 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n     int mtu \u003d Platform.get().getMtu(socket);\n+    if (mtu \u003c 256)\n+        mtu \u003d 256;\n+    if (mtu \u003e 8192)\n+        mtu \u003d 8192;\n     in \u003d new BufferedInputStream(in, mtu);\n     out \u003d new BufferedOutputStream(out, mtu);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d8b5f7bfc73c8f4064a57f634b6155991eb961": {
      "type": "Ybodychange",
      "commitMessage": "Use an MTU-sized buffer for socket access.\n\nPreviously we attempted to avoid buffers in some situations\nand create aggressive buffers in other situations. This was\na bad policy, and meant we had some subtle performance bugs.\nThe one that prompted this is that chunked uploads make\nseparate network writes for the chunk size, chunk, and newline\nseparators.\n\nThis avoids that problem and the corresponding complexity.\nUnfortunately getting the MTU isn\u0027t a standard API until\nJava 6 / Gingerbread. I tested my own networks and saw 1500\nin use (for 3G and WiFi) and 1400 (for VPN over WiFi).\n",
      "commitDate": "2013/4/22 上午11:10",
      "commitName": "13d8b5f7bfc73c8f4064a57f634b6155991eb961",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/4/15 下午9:42",
      "commitNameOld": "242be7e5781be67fc0b570f02adaa522e48ee49a",
      "commitAuthorOld": "Marcelo Cortes",
      "daysBetweenCommits": 6.56,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    int mtu \u003d Platform.get().getMtu(socket);\n    in \u003d new BufferedInputStream(in, mtu);\n    out \u003d new BufferedOutputStream(out, mtu);\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 93,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,17 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n     socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n     socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n-    if (!isSpdy()) {\n-        int bufferSize \u003d 128;\n-        in \u003d new BufferedInputStream(in, bufferSize);\n-    }\n+    int mtu \u003d Platform.get().getMtu(socket);\n+    in \u003d new BufferedInputStream(in, mtu);\n+    out \u003d new BufferedOutputStream(out, mtu);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ece746c815a26782042b1fca6069eb527d1029b": {
      "type": "Ybodychange",
      "commitMessage": "RouteSelector tries previously failed routes last #106\n",
      "commitDate": "2013/4/11 上午6:19",
      "commitName": "1ece746c815a26782042b1fca6069eb527d1029b",
      "commitAuthor": "Marcelo Cortes",
      "commitDateOld": "2013/3/26 上午11:04",
      "commitNameOld": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthorOld": "Jake Wharton",
      "daysBetweenCommits": 15.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n    socket.connect(route.inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (route.address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 92,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,18 +1,18 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     if (connected) {\n         throw new IllegalStateException(\"already connected\");\n     }\n     connected \u003d true;\n-    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n-    socket.connect(inetSocketAddress, connectTimeout);\n+    socket \u003d (route.proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();\n+    socket.connect(route.inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n-    if (address.sslSocketFactory !\u003d null) {\n+    if (route.address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n     if (!isSpdy()) {\n         int bufferSize \u003d 128;\n         in \u003d new BufferedInputStream(in, bufferSize);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ccbf48838b7cfe42759c67790636d442ea5daa3": {
      "type": "Yfilerename",
      "commitMessage": "Move library into a module. Introduce sample module with simple GitHub client.\n",
      "commitDate": "2013/3/26 上午11:04",
      "commitName": "7ccbf48838b7cfe42759c67790636d442ea5daa3",
      "commitAuthor": "Jake Wharton",
      "commitDateOld": "2013/3/15 下午10:39",
      "commitNameOld": "ba2b7432cb9fabfc725b09a9f14878cb128ef208",
      "commitAuthorOld": "Jesse Wilson",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
      "path": "okhttp/src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 103,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/com/squareup/okhttp/Connection.java",
        "newPath": "okhttp/src/main/java/com/squareup/okhttp/Connection.java"
      }
    },
    "194290e5f3819bf91d87c5d08c152946b6aa3509": {
      "type": "Ybodychange",
      "commitMessage": "Improve SPDY+HTTP integration.\n\nWriting tests shook out a few bugs:\n - Pooling wasn\u0027t working well. We were trying to connect\n   after already having been connected.\n - We weren\u0027t writing response bodies to the cache.\n - We weren\u0027t capturing the request time for the cache.\n - MockSpdyServer wasn\u0027t trimming headers.\n\nNew files in this change aren\u0027t new, they\u0027re just inner classes promoted\nto top-level classes for better sharing.\n",
      "commitDate": "2013/1/23 上午5:14",
      "commitName": "194290e5f3819bf91d87c5d08c152946b6aa3509",
      "commitAuthor": "jwilson",
      "commitDateOld": "2013/1/7 上午7:30",
      "commitNameOld": "06579c5bfb6a051a9fbca5be2d15a52fcf77f38c",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 15.91,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    if (connected) {\n        throw new IllegalStateException(\"already connected\");\n    }\n    connected \u003d true;\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
      "path": "src/main/java/com/squareup/okhttp/Connection.java",
      "functionStartLine": 102,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,18 @@\n public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n+    if (connected) {\n+        throw new IllegalStateException(\"already connected\");\n+    }\n+    connected \u003d true;\n     socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n     socket.connect(inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (address.sslSocketFactory !\u003d null) {\n         upgradeToTls(tunnelRequest);\n     }\n     if (!isSpdy()) {\n         int bufferSize \u003d 128;\n         in \u003d new BufferedInputStream(in, bufferSize);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "78c6624b11d5f33504dae8211b4592383468343e": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yparameterchange)",
      "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
      "commitDate": "2012/12/24 下午1:39",
      "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
      "commitAuthor": "jwilson",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,12 +1,14 @@\n-public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n     socket.connect(inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelConfig);\n+        upgradeToTls(tunnelRequest);\n     }\n-    int bufferSize \u003d 128;\n-    in \u003d new BufferedInputStream(in, bufferSize);\n+    if (!isSpdy()) {\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java",
            "newPath": "src/main/java/com/squareup/okhttp/Connection.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,12 +1,14 @@\n-public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n     socket.connect(inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelConfig);\n+        upgradeToTls(tunnelRequest);\n     }\n-    int bufferSize \u003d 128;\n-    in \u003d new BufferedInputStream(in, bufferSize);\n+    if (!isSpdy()) {\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Promote Connection, ConnectionPool and Address APIs.\n\nThis moves HttpConnection.Address and HttpConnection.TunnelConfig\nto their own top-level classes.\n",
          "commitDate": "2012/12/24 下午1:39",
          "commitName": "78c6624b11d5f33504dae8211b4592383468343e",
          "commitAuthor": "jwilson",
          "commitDateOld": "2012/12/24 上午5:38",
          "commitNameOld": "73291e89c43de449949450c216a5220d9b903da6",
          "commitAuthorOld": "Jake Wharton",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelRequest);\n    }\n    if (!isSpdy()) {\n        int bufferSize \u003d 128;\n        in \u003d new BufferedInputStream(in, bufferSize);\n    }\n}",
          "path": "src/main/java/com/squareup/okhttp/Connection.java",
          "functionStartLine": 101,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,12 +1,14 @@\n-public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelRequest) throws IOException {\n     socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n     socket.connect(inetSocketAddress, connectTimeout);\n     socket.setSoTimeout(readTimeout);\n     in \u003d socket.getInputStream();\n     out \u003d socket.getOutputStream();\n     if (address.sslSocketFactory !\u003d null) {\n-        upgradeToTls(tunnelConfig);\n+        upgradeToTls(tunnelRequest);\n     }\n-    int bufferSize \u003d 128;\n-    in \u003d new BufferedInputStream(in, bufferSize);\n+    if (!isSpdy()) {\n+        int bufferSize \u003d 128;\n+        in \u003d new BufferedInputStream(in, bufferSize);\n+    }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
            "newValue": "[connectTimeout-int, readTimeout-int, tunnelRequest-TunnelRequest]"
          }
        }
      ]
    },
    "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d": {
      "type": "Yfilerename",
      "commitMessage": "Move out of the libcore package.\n\nTo promote the code into AOSP, we\u0027ll keep this package as-is\nand do the jarjar in Android instead.\n",
      "commitDate": "2012/12/16 上午5:55",
      "commitName": "50999cceb5f5bcdaf79baa5ac7eeef90c72bda8d",
      "commitAuthor": "jwilson",
      "commitDateOld": "2012/12/16 上午5:17",
      "commitNameOld": "7f7aa90bc5d41d8f818fc988d2a91d22393c7329",
      "commitAuthorOld": "jwilson",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelConfig);\n    }\n    int bufferSize \u003d 128;\n    in \u003d new BufferedInputStream(in, bufferSize);\n}",
      "path": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java",
      "functionStartLine": 105,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/libcore/net/http/HttpConnection.java",
        "newPath": "src/main/java/com/squareup/okhttp/internal/net/http/HttpConnection.java"
      }
    },
    "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "New route selector to support multiple routes.\n",
      "commitDate": "2012/11/11 上午5:05",
      "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012/11/11 上午5:05",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/11/8 上午6:18",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelConfig);\n    }\n    int bufferSize \u003d 128;\n    in \u003d new BufferedInputStream(in, bufferSize);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,5 +1,12 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n-    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n-    result.socket.setSoTimeout(readTimeout);\n-    return result;\n+public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n+    socket.connect(inetSocketAddress, connectTimeout);\n+    socket.setSoTimeout(readTimeout);\n+    in \u003d socket.getInputStream();\n+    out \u003d socket.getOutputStream();\n+    if (address.sslSocketFactory !\u003d null) {\n+        upgradeToTls(tunnelConfig);\n+    }\n+    int bufferSize \u003d 128;\n+    in \u003d new BufferedInputStream(in, bufferSize);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]",
            "newValue": "[connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012/11/11 上午5:05",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/11/8 上午6:18",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelConfig);\n    }\n    int bufferSize \u003d 128;\n    in \u003d new BufferedInputStream(in, bufferSize);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,5 +1,12 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n-    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n-    result.socket.setSoTimeout(readTimeout);\n-    return result;\n+public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n+    socket.connect(inetSocketAddress, connectTimeout);\n+    socket.setSoTimeout(readTimeout);\n+    in \u003d socket.getInputStream();\n+    out \u003d socket.getOutputStream();\n+    if (address.sslSocketFactory !\u003d null) {\n+        upgradeToTls(tunnelConfig);\n+    }\n+    int bufferSize \u003d 128;\n+    in \u003d new BufferedInputStream(in, bufferSize);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "HttpConnection",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012/11/11 上午5:05",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/11/8 上午6:18",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelConfig);\n    }\n    int bufferSize \u003d 128;\n    in \u003d new BufferedInputStream(in, bufferSize);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,5 +1,12 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n-    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n-    result.socket.setSoTimeout(readTimeout);\n-    return result;\n+public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n+    socket.connect(inetSocketAddress, connectTimeout);\n+    socket.setSoTimeout(readTimeout);\n+    in \u003d socket.getInputStream();\n+    out \u003d socket.getOutputStream();\n+    if (address.sslSocketFactory !\u003d null) {\n+        upgradeToTls(tunnelConfig);\n+    }\n+    int bufferSize \u003d 128;\n+    in \u003d new BufferedInputStream(in, bufferSize);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "New route selector to support multiple routes.\n",
          "commitDate": "2012/11/11 上午5:05",
          "commitName": "3355d0c99bb946a6441f08fe6fd1c9881a9ea96a",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/11/8 上午6:18",
          "commitNameOld": "e5b78cabad22ffdfbbe2755fece9c6c535438cdc",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 2.95,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n    socket.connect(inetSocketAddress, connectTimeout);\n    socket.setSoTimeout(readTimeout);\n    in \u003d socket.getInputStream();\n    out \u003d socket.getOutputStream();\n    if (address.sslSocketFactory !\u003d null) {\n        upgradeToTls(tunnelConfig);\n    }\n    int bufferSize \u003d 128;\n    in \u003d new BufferedInputStream(in, bufferSize);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 104,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,5 +1,12 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n-    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n-    result.socket.setSoTimeout(readTimeout);\n-    return result;\n+public void connect(int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    socket \u003d (proxy.type() !\u003d Proxy.Type.HTTP) ? new Socket(proxy) : new Socket();\n+    socket.connect(inetSocketAddress, connectTimeout);\n+    socket.setSoTimeout(readTimeout);\n+    in \u003d socket.getInputStream();\n+    out \u003d socket.getOutputStream();\n+    if (address.sslSocketFactory !\u003d null) {\n+        upgradeToTls(tunnelConfig);\n+    }\n+    int bufferSize \u003d 128;\n+    in \u003d new BufferedInputStream(in, bufferSize);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "40ff76547064c3fb5acb9047a6f679dd4379a4d0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
      "commitDate": "2012/11/6 下午12:25",
      "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012/11/6 下午12:25",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/10/26 上午12:03",
          "commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 11.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n    result.socket.setSoTimeout(readTimeout);\n    return result;\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 89,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,5 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n-    if (proxy !\u003d null) {\n-        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n-        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-    }\n-    ProxySelector selector \u003d ProxySelector.getDefault();\n-    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n-    if (proxyList !\u003d null) {\n-        for (Proxy selectedProxy : proxyList) {\n-            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n-                continue;\n-            }\n-            try {\n-                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n-                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-            } catch (IOException e) {\n-                selector.connectFailed(uri, selectedProxy.address(), e);\n-            }\n-        }\n-    }\n-    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n+    result.socket.setSoTimeout(readTimeout);\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]",
            "newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, hostnameVerifier-HostnameVerifier, proxy-Proxy, connectTimeout-int, readTimeout-int, tunnelConfig-TunnelConfig]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make HttpConnection.connect return full working connections.\n\nPreviously the returned connections required the caller to\ndo extra work: setting up tunnels (which could require auth)\nand performing an SSL handshake. With this change we make a\ncomplete working connection in HttpConnection.connect().\n\nThis will make it easier to fix fallback when a single domain\nhas multiple IP addresses and some of those addresses are not\nreachable.\n\nThis will also make it easier to do SPDY through HTTP proxies.\n",
          "commitDate": "2012/11/6 下午12:25",
          "commitName": "40ff76547064c3fb5acb9047a6f679dd4379a4d0",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/10/26 上午12:03",
          "commitNameOld": "2f5e25e4dcac2f7d62a4ac5ee8d49e92de005866",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 11.52,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n    result.socket.setSoTimeout(readTimeout);\n    return result;\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 89,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,5 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n-    if (proxy !\u003d null) {\n-        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n-        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-    }\n-    ProxySelector selector \u003d ProxySelector.getDefault();\n-    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n-    if (proxyList !\u003d null) {\n-        for (Proxy selectedProxy : proxyList) {\n-            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n-                continue;\n-            }\n-            try {\n-                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n-                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n-            } catch (IOException e) {\n-                selector.connectFailed(uri, selectedProxy.address(), e);\n-            }\n-        }\n-    }\n-    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier, Proxy proxy, int connectTimeout, int readTimeout, TunnelConfig tunnelConfig) throws IOException {\n+    HttpConnection result \u003d getConnection(uri, sslSocketFactory, hostnameVerifier, proxy, connectTimeout, tunnelConfig);\n+    result.socket.setSoTimeout(readTimeout);\n+    return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5aa2456a145883f6688c6ee325635ed0c6339076": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
      "commitDate": "2012/9/21 上午4:01",
      "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
      "commitAuthor": "Jesse Wilson",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
          "commitDate": "2012/9/21 上午4:01",
          "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/9/20 上午3:48",
          "commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.01,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n    if (proxy !\u003d null) {\n        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n    }\n    ProxySelector selector \u003d ProxySelector.getDefault();\n    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n    if (proxyList !\u003d null) {\n        for (Proxy selectedProxy : proxyList) {\n            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                continue;\n            }\n            try {\n                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n            } catch (IOException e) {\n                selector.connectFailed(uri, selectedProxy.address(), e);\n            }\n        }\n    }\n    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 125,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,22 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n     if (proxy !\u003d null) {\n-        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n         return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n     }\n     ProxySelector selector \u003d ProxySelector.getDefault();\n     List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n     if (proxyList !\u003d null) {\n         for (Proxy selectedProxy : proxyList) {\n             if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                 continue;\n             }\n             try {\n-                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy, requiresTunnel);\n+                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                 return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n             } catch (IOException e) {\n                 selector.connectFailed(uri, selectedProxy.address(), e);\n             }\n         }\n     }\n     return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, requiresTunnel-boolean, connectTimeout-int]",
            "newValue": "[uri-URI, sslSocketFactory-SSLSocketFactory, proxy-Proxy, connectTimeout-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix TLS requiresTunnel which was being computed incorrectly.\n\nWe were only returning \u0027true\u0027 once we were already in a tunnel.\nThis was bogus. In theory a TLS tunnel sending extra data could\nbe corrupted due to this bug.\n\nAlso migrate one of the TLS tunnel tests to use SslContextBuilder\ninstead of TestSSLContext.\n",
          "commitDate": "2012/9/21 上午4:01",
          "commitName": "5aa2456a145883f6688c6ee325635ed0c6339076",
          "commitAuthor": "Jesse Wilson",
          "commitDateOld": "2012/9/20 上午3:48",
          "commitNameOld": "faeff7f10548151cb2310351b3975f719037f217",
          "commitAuthorOld": "Jesse Wilson",
          "daysBetweenCommits": 1.01,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n    if (proxy !\u003d null) {\n        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n    }\n    ProxySelector selector \u003d ProxySelector.getDefault();\n    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n    if (proxyList !\u003d null) {\n        for (Proxy selectedProxy : proxyList) {\n            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                continue;\n            }\n            try {\n                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n            } catch (IOException e) {\n                selector.connectFailed(uri, selectedProxy.address(), e);\n            }\n        }\n    }\n    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n}",
          "path": "src/main/java/libcore/net/http/HttpConnection.java",
          "functionStartLine": 125,
          "functionName": "connect",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,22 +1,22 @@\n-public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, int connectTimeout) throws IOException {\n     if (proxy !\u003d null) {\n-        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy);\n         return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n     }\n     ProxySelector selector \u003d ProxySelector.getDefault();\n     List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n     if (proxyList !\u003d null) {\n         for (Proxy selectedProxy : proxyList) {\n             if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                 continue;\n             }\n             try {\n-                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy, requiresTunnel);\n+                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy);\n                 return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n             } catch (IOException e) {\n                 selector.connectFailed(uri, selectedProxy.address(), e);\n             }\n         }\n     }\n     return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e": {
      "type": "Yintroduced",
      "commitMessage": "Initial import.\n\nThis is a fork of okhttp from http://code.google.com/p/okhttp.\nI\u0027m moving it to Github since that\u0027s where my code reviewers\nare. I\u0027ve renamed the core package from com.google.okhttp to\ncom.squareup.okhttp because Square is where I expect ongoing\ndevelopment of this project to take place.\n\nAll code in this project is subject to be contributed upstream\nto AOSP. In particular, all code in the libcore package is\nderived from AOSP and intended to be contributed back to AOSP\non an ongoing basis.\n",
      "commitDate": "2012/7/23 下午10:02",
      "commitName": "ea63463c2ff8a67f63e541036f0d5998b5bb1f3e",
      "commitAuthor": "Jesse Wilson",
      "diff": "@@ -0,0 +1,22 @@\n+public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n+    if (proxy !\u003d null) {\n+        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n+        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+    }\n+    ProxySelector selector \u003d ProxySelector.getDefault();\n+    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n+    if (proxyList !\u003d null) {\n+        for (Proxy selectedProxy : proxyList) {\n+            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n+                continue;\n+            }\n+            try {\n+                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy, requiresTunnel);\n+                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n+            } catch (IOException e) {\n+                selector.connectFailed(uri, selectedProxy.address(), e);\n+            }\n+        }\n+    }\n+    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static HttpConnection connect(URI uri, SSLSocketFactory sslSocketFactory, Proxy proxy, boolean requiresTunnel, int connectTimeout) throws IOException {\n    if (proxy !\u003d null) {\n        Address address \u003d (proxy.type() \u003d\u003d Proxy.Type.DIRECT) ? new Address(uri, sslSocketFactory) : new Address(uri, sslSocketFactory, proxy, requiresTunnel);\n        return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n    }\n    ProxySelector selector \u003d ProxySelector.getDefault();\n    List\u003cProxy\u003e proxyList \u003d selector.select(uri);\n    if (proxyList !\u003d null) {\n        for (Proxy selectedProxy : proxyList) {\n            if (selectedProxy.type() \u003d\u003d Proxy.Type.DIRECT) {\n                continue;\n            }\n            try {\n                Address address \u003d new Address(uri, sslSocketFactory, selectedProxy, requiresTunnel);\n                return HttpConnectionPool.INSTANCE.get(address, connectTimeout);\n            } catch (IOException e) {\n                selector.connectFailed(uri, selectedProxy.address(), e);\n            }\n        }\n    }\n    return HttpConnectionPool.INSTANCE.get(new Address(uri, sslSocketFactory), connectTimeout);\n}",
      "path": "src/main/java/libcore/net/http/HttpConnection.java",
      "functionStartLine": 126,
      "functionName": "connect",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}