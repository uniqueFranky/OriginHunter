{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "PullCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n",
  "functionStartLine": 206,
  "functionEndLine": 360,
  "numCommitsSeen": 38,
  "timeTaken": 2935,
  "changeHistory": [
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
    "df638e0cfc628469eee9a91df5b2b65634e274d7",
    "0d447b16604d934675d2dc8e958fa043e945dfc6",
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
    "5f902f07ccae32b82a36c05e1eca23b21a27da99",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
    "1cda4faed425286fe5230a6b2b8454c376ba79f1",
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
    "2390531888af6dc9e4fda6cb026271dc068c40ab",
    "48544e27ae3808807dc1960083d8e42c05e62af3",
    "7424d58255340fa44d9191a7436fbe70d72a457c",
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
    "fa5231191d530afb24810080e89990913c8e8054",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8",
    "b61d35e848e637ef85fde4ebe95d60ced171e963",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
    "791a9fd691e5ae101650f27f39366ec7b23f3955",
    "6d293c7b06e219086959e80d495b5febe8ae530d",
    "770c733687d9f2f71f30822f9691427bf83b7577",
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
    "724af77c65c27eb24d41989bed3229910dbe063c",
    "b15b9d5df25b375108ca125b31338df637454865",
    "9fbda2239202ca9d3a20c84d7326f47c667aa920",
    "14ca80bc90ed85e3484fa28aa665fa0538096d30",
    "013cb8de3824c304645a9c5db87c2e80286872d1",
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
    "7668a462829b12e4f6a192c43157152ef63ff305",
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6"
  ],
  "changeHistoryShort": {
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": "Ydocchange",
    "df638e0cfc628469eee9a91df5b2b65634e274d7": "Ybodychange",
    "0d447b16604d934675d2dc8e958fa043e945dfc6": "Ybodychange",
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5f902f07ccae32b82a36c05e1eca23b21a27da99": "Ybodychange",
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": "Yannotationchange",
    "1cda4faed425286fe5230a6b2b8454c376ba79f1": "Ybodychange",
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c": "Ybodychange",
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": "Ybodychange",
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "2390531888af6dc9e4fda6cb026271dc068c40ab": "Ybodychange",
    "48544e27ae3808807dc1960083d8e42c05e62af3": "Ybodychange",
    "7424d58255340fa44d9191a7436fbe70d72a457c": "Ybodychange",
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782": "Ybodychange",
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": "Ybodychange",
    "fa5231191d530afb24810080e89990913c8e8054": "Ybodychange",
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": "Ybodychange",
    "b61d35e848e637ef85fde4ebe95d60ced171e963": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": "Yexceptionschange",
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a": "Ymultichange(Yexceptionschange,Ybodychange)",
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3": "Ybodychange",
    "791a9fd691e5ae101650f27f39366ec7b23f3955": "Ybodychange",
    "6d293c7b06e219086959e80d495b5febe8ae530d": "Ybodychange",
    "770c733687d9f2f71f30822f9691427bf83b7577": "Ybodychange",
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d": "Ymultichange(Yexceptionschange,Ybodychange)",
    "724af77c65c27eb24d41989bed3229910dbe063c": "Ybodychange",
    "b15b9d5df25b375108ca125b31338df637454865": "Ybodychange",
    "9fbda2239202ca9d3a20c84d7326f47c667aa920": "Ybodychange",
    "14ca80bc90ed85e3484fa28aa665fa0538096d30": "Ybodychange",
    "013cb8de3824c304645a9c5db87c2e80286872d1": "Ybodychange",
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31": "Ybodychange",
    "7668a462829b12e4f6a192c43157152ef63ff305": "Ybodychange",
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0210e0e299bed69176e0a929d0b67f3cf9fb1e37": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit annotations and api packages\n\nChange-Id: I2761ea91f8dfed16ea54e7a6646af03a30c15ec9\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/18 下午5:45",
      "commitName": "0210e0e299bed69176e0a929d0b67f3cf9fb1e37",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/6/17 上午5:20",
      "commitNameOld": "df638e0cfc628469eee9a91df5b2b65634e274d7",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 184.52,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig \u003d repo.getConfig();\n    String branchName \u003d null;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d branchName;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null) {\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        MergeResult mergeRes \u003d merge.include(upstreamName, commitToMerge).setStrategy(strategy).setProgressMonitor(monitor).setFastForward(getFastForwardMode()).call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 206,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
        "newValue": "@inheritDoc}\n\u003cp\u003e\nExecute the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n"
      }
    },
    "df638e0cfc628469eee9a91df5b2b65634e274d7": {
      "type": "Ybodychange",
      "commitMessage": "Allow to programmatically set FastForwardMode for PullCommand\n\nBug: 517847\nChange-Id: I70d12dbe347a3d7a3528687ee04e52a2052bfb93\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/6/17 上午5:20",
      "commitName": "df638e0cfc628469eee9a91df5b2b65634e274d7",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/6/17 上午5:20",
      "commitNameOld": "0d447b16604d934675d2dc8e958fa043e945dfc6",
      "commitAuthorOld": "Mattias Neuling",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig \u003d repo.getConfig();\n    String branchName \u003d null;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d branchName;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null) {\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        MergeResult mergeRes \u003d merge.include(upstreamName, commitToMerge).setStrategy(strategy).setProgressMonitor(monitor).setFastForward(getFastForwardMode()).call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 209,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,96 +1,92 @@\n @Override\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     Config repoConfig \u003d repo.getConfig();\n     String branchName \u003d null;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n             branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d branchName;\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null) {\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     }\n     if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n-        merge.include(upstreamName, commitToMerge);\n-        merge.setStrategy(strategy);\n-        merge.setProgressMonitor(monitor);\n-        merge.setFastForward(getFastForwardMode());\n-        MergeResult mergeRes \u003d merge.call();\n+        MergeResult mergeRes \u003d merge.include(upstreamName, commitToMerge).setStrategy(strategy).setProgressMonitor(monitor).setFastForward(getFastForwardMode()).call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0d447b16604d934675d2dc8e958fa043e945dfc6": {
      "type": "Ybodychange",
      "commitMessage": "Add support for config \"pull.ff\n\nWhen the configuration entry \u0027pull.ff\u0027 exists the merge of the pull will\nuse the value as fast forward option.\n\nBug: 474174\nChange-Id: Ic8db2f00095ed81528667b064ff523911e6c122e\nSigned-off-by: Mattias Neuling \u003cneuling@dakosy.de\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/6/17 上午5:20",
      "commitName": "0d447b16604d934675d2dc8e958fa043e945dfc6",
      "commitAuthor": "Mattias Neuling",
      "commitDateOld": "2017/6/16 上午11:52",
      "commitNameOld": "b4a46b5ed0e33f0a958ba809c648f46e5a19abd7",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig \u003d repo.getConfig();\n    String branchName \u003d null;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d branchName;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null) {\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        merge.setFastForward(getFastForwardMode());\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 207,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,95 +1,96 @@\n @Override\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     Config repoConfig \u003d repo.getConfig();\n     String branchName \u003d null;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n             branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n         }\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d branchName;\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null) {\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     }\n     if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n+        merge.setFastForward(getFastForwardMode());\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/5/8 上午6:38",
      "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
      "commitAuthor": "Mickael Istria",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2017/5/8 上午6:38",
          "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
          "commitAuthor": "Mickael Istria",
          "commitDateOld": "2017/3/24 上午7:02",
          "commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
          "commitAuthorOld": "David Pursehouse",
          "daysBetweenCommits": 44.98,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig \u003d repo.getConfig();\n    String branchName \u003d null;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d branchName;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null) {\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 204,
          "functionName": "call",
          "functionAnnotation": "@Override",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,92 +1,95 @@\n @Override\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n-    String branchName;\n+    Config repoConfig \u003d repo.getConfig();\n+    String branchName \u003d null;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n-        if (fullBranch \u003d\u003d null)\n-            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n-            throw new DetachedHeadException();\n+        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n+            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n         }\n-        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n+    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n+        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+    }\n+    if (remoteBranchName \u003d\u003d null) {\n+        remoteBranchName \u003d branchName;\n+    }\n+    if (remoteBranchName \u003d\u003d null) {\n+        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n+    }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n-    Config repoConfig \u003d repo.getConfig();\n-    if (remote \u003d\u003d null) {\n+    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n-    if (remote \u003d\u003d null)\n+    if (remote \u003d\u003d null) {\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n-    if (remoteBranchName \u003d\u003d null)\n-        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n-    if (pullRebaseMode \u003d\u003d null) {\n+    }\n+    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n-    if (remoteBranchName \u003d\u003d null)\n-        remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support pull on detached HEAD\n\nBug: 485396\nChange-Id: I82be09385c9b0bcc0054fea5a9cb9d178a41e278\nSigned-off-by: Mickael Istria \u003cmistria@redhat.com\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2017/5/8 上午6:38",
          "commitName": "5b84e25fa3afe66bbfa7eb953ea0bd332c745ecd",
          "commitAuthor": "Mickael Istria",
          "commitDateOld": "2017/3/24 上午7:02",
          "commitNameOld": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
          "commitAuthorOld": "David Pursehouse",
          "daysBetweenCommits": 44.98,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    Config repoConfig \u003d repo.getConfig();\n    String branchName \u003d null;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n        }\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d branchName;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null) {\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    }\n    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 204,
          "functionName": "call",
          "functionAnnotation": "@Override",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,92 +1,95 @@\n @Override\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n-    String branchName;\n+    Config repoConfig \u003d repo.getConfig();\n+    String branchName \u003d null;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n-        if (fullBranch \u003d\u003d null)\n-            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n-        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n-            throw new DetachedHeadException();\n+        if (fullBranch !\u003d null \u0026\u0026 fullBranch.startsWith(Constants.R_HEADS)) {\n+            branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n         }\n-        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n+    if (remoteBranchName \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n+        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+    }\n+    if (remoteBranchName \u003d\u003d null) {\n+        remoteBranchName \u003d branchName;\n+    }\n+    if (remoteBranchName \u003d\u003d null) {\n+        throw new NoHeadException(JGitText.get().cannotCheckoutFromUnbornBranch);\n+    }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n-    Config repoConfig \u003d repo.getConfig();\n-    if (remote \u003d\u003d null) {\n+    if (remote \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n-    if (remote \u003d\u003d null)\n+    if (remote \u003d\u003d null) {\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n-    if (remoteBranchName \u003d\u003d null)\n-        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n-    if (pullRebaseMode \u003d\u003d null) {\n+    }\n+    if (pullRebaseMode \u003d\u003d null \u0026\u0026 branchName !\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n-    if (remoteBranchName \u003d\u003d null)\n-        remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "5f902f07ccae32b82a36c05e1eca23b21a27da99": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Add support for recursing into submodules\n\nAdd a new API method to set the recurse mode, and pass the mode into\nthe fetch command.\n\nExtend the existing FetchCommandRecurseSubmodulesTest to also perform\nthe same tests for fetch. Rename the test class accordingly.\n\nChange-Id: I12553af47774b4778f7011e1018bd575a7909bd0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/3/24 上午7:02",
      "commitName": "5f902f07ccae32b82a36c05e1eca23b21a27da99",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 31.96,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 204,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,92 +1,92 @@\n @Override\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n-        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n+        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption).setRecurseSubmodules(submoduleRecurseMode);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0": {
      "type": "Yannotationchange",
      "commitMessage": "Enable and fix \u0027Should be tagged with @Override\u0027 warning\n\nSet missingOverrideAnnotation\u003dwarning in Eclipse compiler preferences\nwhich enables the warning:\n\n  The method \u003cmethod\u003e of type \u003ctype\u003e should be tagged with @Override\n  since it actually overrides a superclass method\n\nJustification for this warning is described in:\n\n  http://stackoverflow.com/a/94411/381622\n\nEnabling this causes in excess of 1000 warnings across the entire\ncode-base. They are very easy to fix automatically with Eclipse\u0027s\n\"Quick Fix\" tool.\n\nFix all of them except 2 which cause compilation failure when the\nproject is built with mvn; add TODO comments on those for further\ninvestigation.\n\nChange-Id: I5772061041fd361fe93137fd8b0ad356e748a29c\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/20 上午8:05",
      "commitName": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/19 下午11:46",
      "commitNameOld": "0a4cf573d345e9509b689af141f4dbfa1f63dc3b",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 0.35,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 201,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,91 +1,92 @@\n+@Override\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Override"
      }
    },
    "1cda4faed425286fe5230a6b2b8454c376ba79f1": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Allow to set tag behavior\n\nAdd a new method setTagOpt which sets the annotated tag behavior during\nfetch. Pass the option to the fetch command.\n\nNo explicit tests are added; the fetch with tags functionality is already\ncovered by the tests of the fetch command.\n\nChange-Id: I131e1f68d8fcced178d8fa48abf7ffab17f8e173\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/18 下午10:21",
      "commitName": "1cda4faed425286fe5230a6b2b8454c376ba79f1",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2016/9/15 上午6:44",
      "commitNameOld": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
      "commitAuthorOld": "Thomas Wolf",
      "daysBetweenCommits": 156.65,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 200,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,93 +1,91 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n-        FetchCommand fetch \u003d new FetchCommand(repo);\n-        fetch.setRemote(remote);\n-        fetch.setProgressMonitor(monitor);\n+        FetchCommand fetch \u003d new FetchCommand(repo).setRemote(remote).setProgressMonitor(monitor).setTagOpt(tagOption);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c": {
      "type": "Ybodychange",
      "commitMessage": "Handle all values of branch.[name].rebase\n\nBranchConfig treated this config property as a boolean, but git also\nallows the values \"preserve\" and \"interactive\". Config property\npull.rebase also allows the same values.\n\nReplace private enum PullCommand.PullRebaseMode by new public enum\nBranchConfig.BranchRebaseMode and adapt all uses. Add a new setter to\nPullCommand.\n\nNote: PullCommand will treat \"interactive\" like \"true\", i.e., as a\nnon-interactive rebase. Not sure how \"interactive\" should be handled.\nAt least it won\u0027t balk on it.\n\nBug: 499482\nChange-Id: I7309360f5662b2c2efa1bd8ea6f112c63cf064af\nSigned-off-by: Thomas Wolf \u003cthomas.wolf@paranor.ch\u003e",
      "commitDate": "2016/9/15 上午6:44",
      "commitName": "aadbb158e10ccc3194c4e7f2c1b3885b3c40571c",
      "commitAuthor": "Thomas Wolf",
      "commitDateOld": "2016/1/21 下午6:37",
      "commitNameOld": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthorOld": "Laurent Delaigue",
      "daysBetweenCommits": 237.5,
      "commitsBetweenForRepo": 328,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 197,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,93 +1,93 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n-    if (pullRebaseMode.rebase) {\n+    if (pullRebaseMode !\u003d BranchRebaseMode.NONE) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode \u003d\u003d BranchRebaseMode.PRESERVE).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1e1fb9fc596603a44b0fff6d19eeba2b005d659d": {
      "type": "Ybodychange",
      "commitMessage": "Add progress monitor to Merger\n\nMonitoring progress of merges can be useful for users for large\nrepositories or complex merge processes that take some time.\n\nThis enables setting a monitor. Existing merge implementations in jgit\ndo not yet report progress if a monitor is set. This will be added in a\nlater change.\n\nChange-Id: I17b978b3fc91750dd88649638b90a46820a0877c\nSigned-off-by: Laurent Delaigue \u003claurent.delaigue@obeo.fr\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2016/1/21 下午6:37",
      "commitName": "1e1fb9fc596603a44b0fff6d19eeba2b005d659d",
      "commitAuthor": "Laurent Delaigue",
      "commitDateOld": "2015/6/12 上午1:44",
      "commitNameOld": "bbfd9b0e5fc0160f5a1034ce23958a8040e88748",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 223.7,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        merge.setProgressMonitor(monitor);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 184,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,92 +1,93 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null) {\n             throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n         } else {\n             commitToMerge \u003d r.getObjectId();\n         }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n+        merge.setProgressMonitor(monitor);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "efacad0fc8e98505be6f007230ab2b1cdc1684f3": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/29 上午6:15",
      "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
      "commitAuthor": "Matthias Sohn",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/5/29 上午6:15",
          "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
          "commitAuthor": "Matthias Sohn",
          "commitDateOld": "2015/5/26 下午4:52",
          "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
          "commitAuthorOld": "Matthias Sohn",
          "daysBetweenCommits": 2.56,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 180,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,91 +1,92 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n-        if (r \u003d\u003d null)\n-            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n-        else\n+        if (r \u003d\u003d null) {\n+            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n+        } else {\n             commitToMerge \u003d r.getObjectId();\n+        }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/5/29 上午6:15",
          "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
          "commitAuthor": "Matthias Sohn",
          "commitDateOld": "2015/5/26 下午4:52",
          "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
          "commitAuthorOld": "Matthias Sohn",
          "daysBetweenCommits": 2.56,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 180,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,91 +1,92 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n-        if (r \u003d\u003d null)\n-            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n-        else\n+        if (r \u003d\u003d null) {\n+            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n+        } else {\n             commitToMerge \u003d r.getObjectId();\n+        }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Improve exception thrown when pull can\u0027t find advertised ref\n\n- throw an API exception instead of an internal exception to allow\napplications to handle this problem\n- improve error message to give hints about possible root causes\n\nBug: 464660\nChange-Id: Ib7d18bb2eeeac0fc218daea375b290ea5034bda1\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2015/5/29 上午6:15",
          "commitName": "efacad0fc8e98505be6f007230ab2b1cdc1684f3",
          "commitAuthor": "Matthias Sohn",
          "commitDateOld": "2015/5/26 下午4:52",
          "commitNameOld": "2390531888af6dc9e4fda6cb026271dc068c40ab",
          "commitAuthorOld": "Matthias Sohn",
          "daysBetweenCommits": 2.56,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null) {\n            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n        } else {\n            commitToMerge \u003d r.getObjectId();\n        }\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 180,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,91 +1,92 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, RefNotAdvertisedException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n-        if (r \u003d\u003d null)\n-            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n-        else\n+        if (r \u003d\u003d null) {\n+            throw new RefNotAdvertisedException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remote, remoteBranchName));\n+        } else {\n             commitToMerge \u003d r.getObjectId();\n+        }\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
            "newValue": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws RefNotAdvertisedException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n"
          }
        }
      ]
    },
    "2390531888af6dc9e4fda6cb026271dc068c40ab": {
      "type": "Ybodychange",
      "commitMessage": "Externalize translatable texts in org.eclipse.jgit\n\nChange-Id: Ibf4c299f9d203c78cae79e61f88d4bea60ea2795\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/26 下午4:52",
      "commitName": "2390531888af6dc9e4fda6cb026271dc068c40ab",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2014/7/16 上午7:08",
      "commitNameOld": "48544e27ae3808807dc1960083d8e42c05e62af3",
      "commitAuthorOld": "Konrad Kügler",
      "daysBetweenCommits": 314.41,
      "commitsBetweenForRepo": 408,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d JGitText.get().localRepository;\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 178,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,91 +1,91 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (pullRebaseMode \u003d\u003d null) {\n         pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n-        remoteUri \u003d \"local repository\";\n+        remoteUri \u003d JGitText.get().localRepository;\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n-    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n+    String upstreamName \u003d MessageFormat.format(JGitText.get().upstreamBranchName, Repository.shortenRefName(remoteBranchName), remoteUri);\n     PullResult result;\n     if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "48544e27ae3808807dc1960083d8e42c05e62af3": {
      "type": "Ybodychange",
      "commitMessage": "Preserve merges during pull if configured to do so\n\nSetting branch.\u003cname\u003e.rebase or pull.rebase to \u0027preserve\u0027 will preserve\nmerges during rebase. Also, pull.rebase is now consulted if there is no\nbranch-specific configuration.\n\nBug: 429664\nChange-Id: I345fa295c7e774e0d0a8e6aba30fbfc3552e0084\nSigned-off-by: Konrad Kügler \u003cswamblumat-eclipsebugs@yahoo.de\u003e\n",
      "commitDate": "2014/7/16 上午7:08",
      "commitName": "48544e27ae3808807dc1960083d8e42c05e62af3",
      "commitAuthor": "Konrad Kügler",
      "commitDateOld": "2014/5/6 下午10:30",
      "commitNameOld": "7424d58255340fa44d9191a7436fbe70d72a457c",
      "commitAuthorOld": "Laurent Goubet",
      "daysBetweenCommits": 70.36,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (pullRebaseMode \u003d\u003d null) {\n        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (pullRebaseMode.rebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 178,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,101 +1,91 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n-    boolean doRebase \u003d false;\n-    switch(pullRebaseMode) {\n-        case REBASE:\n-            doRebase \u003d true;\n-            break;\n-        case NO_REBASE:\n-            doRebase \u003d false;\n-            break;\n-        case USE_CONFIG:\n-        default:\n-            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n-            break;\n+    if (pullRebaseMode \u003d\u003d null) {\n+        pullRebaseMode \u003d getRebaseMode(branchName, repoConfig);\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n     PullResult result;\n-    if (doRebase) {\n+    if (pullRebaseMode.rebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).call();\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).setPreserveMerges(pullRebaseMode.preserveMerges).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7424d58255340fa44d9191a7436fbe70d72a457c": {
      "type": "Ybodychange",
      "commitMessage": "Allow callers to use different merging strategies\n\nSigned-off-by: Laurent Goubet \u003claurent.goubet@obeo.fr\u003e\nChange-Id: I84e9d7b4b772b4ad7d3e7010aad78291d4d178fe\n",
      "commitDate": "2014/5/6 下午10:30",
      "commitName": "7424d58255340fa44d9191a7436fbe70d72a457c",
      "commitAuthor": "Laurent Goubet",
      "commitDateOld": "2014/3/30 上午1:34",
      "commitNameOld": "32ff57a2b2b9480f4d374a2592fada7f720b124f",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 37.87,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase \u003d true;\n            break;\n        case NO_REBASE:\n            doRebase \u003d false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        merge.setStrategy(strategy);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 157,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,100 +1,101 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     if (remote \u003d\u003d null) {\n         remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d false;\n     switch(pullRebaseMode) {\n         case REBASE:\n             doRebase \u003d true;\n             break;\n         case NO_REBASE:\n             doRebase \u003d false;\n             break;\n         case USE_CONFIG:\n         default:\n             doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n             break;\n     }\n     if (remoteBranchName \u003d\u003d null)\n         remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).setStrategy(strategy).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n+        merge.setStrategy(strategy);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eae309723be301a4f2fc12a3e07e7e7c9f30782": {
      "type": "Ybodychange",
      "commitMessage": "Allow programmatic remote configuration for PullCommand\n\nAlso imply remoteBranchName to match current branch name if it wasn\u0027t\nconfigured in branch configuration.\n\nBug: 424812\nChange-Id: Id852cedaefb2a537b6aa3c330b9861efad052f11\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2014/2/14 下午11:10",
      "commitName": "1eae309723be301a4f2fc12a3e07e7e7c9f30782",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2012/12/27 下午11:57",
      "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 413.97,
      "commitsBetweenForRepo": 508,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    if (remote \u003d\u003d null) {\n        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    }\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase \u003d true;\n            break;\n        case NO_REBASE:\n            doRebase \u003d false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName \u003d\u003d null)\n        remoteBranchName \u003d branchName;\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 152,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,99 +1,100 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n-    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n+    if (remote \u003d\u003d null) {\n+        remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n+    }\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n-    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+    if (remoteBranchName \u003d\u003d null)\n+        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d false;\n     switch(pullRebaseMode) {\n         case REBASE:\n             doRebase \u003d true;\n             break;\n         case NO_REBASE:\n             doRebase \u003d false;\n             break;\n         case USE_CONFIG:\n         default:\n             doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n             break;\n     }\n-    if (remoteBranchName \u003d\u003d null) {\n-        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n-        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n-    }\n+    if (remoteBranchName \u003d\u003d null)\n+        remoteBranchName \u003d branchName;\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c310fa0c802f40a774edb58641de3ac5bfad0e2c": {
      "type": "Ybodychange",
      "commitMessage": "Mark non-externalizable strings as such\n\nA few classes such as Constanrs are marked with @SuppressWarnings, as are\ntoString() methods with many liternal, but otherwise $NLS-n$ is used for\nstring containing text that should not be translated. A few literals may\nfall into the gray zone, but mostly I\u0027ve tried to only tag the obvious\nones.\n\nChange-Id: I22e50a77e2bf9e0b842a66bdf674e8fa1692f590\n",
      "commitDate": "2012/12/27 下午11:57",
      "commitName": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/11/17 上午4:51",
      "commitNameOld": "fa5231191d530afb24810080e89990913c8e8054",
      "commitAuthorOld": "Mikael Karlsson",
      "daysBetweenCommits": 40.8,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase \u003d true;\n            break;\n        case NO_REBASE:\n            doRebase \u003d false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "",
      "extendedDetails": {}
    },
    "fa5231191d530afb24810080e89990913c8e8054": {
      "type": "Ybodychange",
      "commitMessage": "Add support for pull with --rebase and --no-rebase\n\nBug: 394501\nChange-Id: I697e2fc82a46c03762111eb1de93e673a2643b4f\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2012/11/17 上午4:51",
      "commitName": "fa5231191d530afb24810080e89990913c8e8054",
      "commitAuthor": "Mikael Karlsson",
      "commitDateOld": "2012/8/18 上午6:11",
      "commitNameOld": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 90.94,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    switch(pullRebaseMode) {\n        case REBASE:\n            doRebase \u003d true;\n            break;\n        case NO_REBASE:\n            doRebase \u003d false;\n            break;\n        case USE_CONFIG:\n        default:\n            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n            break;\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 148,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,87 +1,99 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n-    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n+    boolean doRebase \u003d false;\n+    switch(pullRebaseMode) {\n+        case REBASE:\n+            doRebase \u003d true;\n+            break;\n+        case NO_REBASE:\n+            doRebase \u003d false;\n+            break;\n+        case USE_CONFIG:\n+        default:\n+            doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n+            break;\n+    }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(upstreamName, commitToMerge);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5854ca091a22346e1c710ca9f875165afb3f2cc8": {
      "type": "Ybodychange",
      "commitMessage": "Improve ours/theirs conflict markers for rebase, cherry-pick\n\nOn conflicts in rebase or cherry-pick, the conflict markers were like\nthis:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c OURS\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e THEIRS\n\nThis is technically correct, but it could be better.\n\nIt\u0027s especially confusing during a rebase, where the meaning of\nOURS/THEIRS is not obvious. The intuition is that \"ours\" is the commits\nthat \"I\" did before the rebase, but it\u0027s the other way around because of\nthe way rebase works. See various bug reports and stackoverflow\ndiscussions.\n\nWith this change, in the case of a cherry-pick while on master, the\nmarkers will be like this:\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e bad1dea Message of the commit I\u0027m cherry-picking\n\nIn the case of a \"git rebase master\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on master\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nIt\u0027s not \"master\" because that would only be correct for the first\ncherry-pick during a rebase, after that, it\u0027s master + already\ncherry-picked commits.\n\nAnd in the case of a \"git pull --rebase\":\n\n    \u003c\u003c\u003c\u003c\u003c\u003c\u003c Upstream, based on branch \u0027master\u0027 of git@example.org:repo\n    a\n    \u003d\u003d\u003d\u003d\u003d\u003d\u003d\n    b\n    \u003e\u003e\u003e\u003e\u003e\u003e\u003e b161dea Message of a commit I\u0027m rebasing\n\nBug: 336819\nChange-Id: I1333a8dd170bb0077f491962013485efb6f2a926\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012/8/18 上午6:11",
      "commitName": "5854ca091a22346e1c710ca9f875165afb3f2cc8",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2012/6/5 下午10:55",
      "commitNameOld": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 73.3,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(upstreamName, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 118,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
      "diff": "@@ -1,87 +1,87 @@\n public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n+    String upstreamName \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setUpstreamName(upstreamName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n         result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n-        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n-        merge.include(name, commitToMerge);\n+        merge.include(upstreamName, commitToMerge);\n         MergeResult mergeRes \u003d merge.call();\n         monitor.update(1);\n         result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b61d35e848e637ef85fde4ebe95d60ced171e963": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange,Ydocchange)",
      "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2012/6/5 下午10:55",
      "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
      "commitAuthor": "Robin Rosenberg",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012/6/5 下午10:55",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/5/31 上午4:08",
          "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 5.78,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 118,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,112 +1,87 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        try {\n-            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n-            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (RefNotFoundException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (JGitInternalException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (GitAPIException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n-        MergeResult mergeRes;\n-        try {\n-            mergeRes \u003d merge.call();\n-            monitor.update(1);\n-            result \u003d new PullResult(fetchRes, remote, mergeRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (ConcurrentRefUpdateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (CheckoutConflictException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (InvalidMergeHeadsException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (WrongRepositoryStateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (NoMessageException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        MergeResult mergeRes \u003d merge.call();\n+        monitor.update(1);\n+        result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
            "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012/6/5 下午10:55",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/5/31 上午4:08",
          "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 5.78,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 118,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,112 +1,87 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        try {\n-            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n-            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (RefNotFoundException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (JGitInternalException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (GitAPIException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n-        MergeResult mergeRes;\n-        try {\n-            mergeRes \u003d merge.call();\n-            monitor.update(1);\n-            result \u003d new PullResult(fetchRes, remote, mergeRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (ConcurrentRefUpdateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (CheckoutConflictException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (InvalidMergeHeadsException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (WrongRepositoryStateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (NoMessageException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        MergeResult mergeRes \u003d merge.call();\n+        monitor.update(1);\n+        result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Further cleanup of exceptions in Git API\n\n- Translate internal exceptions to corresponding API exception\n- Do not catch GitAPI exceptions internally to an internal\nexception. Just pass them to caller\n- Mention thrown exceptions in javadoc\n\nChange-Id: I9044cf86d2b0bcc8b63b7cc016e1bf0055a62053\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
          "commitDate": "2012/6/5 下午10:55",
          "commitName": "b61d35e848e637ef85fde4ebe95d60ced171e963",
          "commitAuthor": "Robin Rosenberg",
          "commitDateOld": "2012/5/31 上午4:08",
          "commitNameOld": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
          "commitAuthorOld": "Robin Rosenberg",
          "daysBetweenCommits": 5.78,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes \u003d merge.call();\n        monitor.update(1);\n        result \u003d new PullResult(fetchRes, remote, mergeRes);\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 118,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n",
          "diff": "@@ -1,112 +1,87 @@\n-public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException, org.eclipse.jgit.api.errors.TransportException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n-        try {\n-            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n-            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (RefNotFoundException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (JGitInternalException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (GitAPIException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+        result \u003d new PullResult(fetchRes, remote, rebaseRes);\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n-        MergeResult mergeRes;\n-        try {\n-            mergeRes \u003d merge.call();\n-            monitor.update(1);\n-            result \u003d new PullResult(fetchRes, remote, mergeRes);\n-        } catch (NoHeadException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (ConcurrentRefUpdateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (CheckoutConflictException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (InvalidMergeHeadsException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (WrongRepositoryStateException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        } catch (NoMessageException e) {\n-            throw new JGitInternalException(e.getMessage(), e);\n-        }\n+        MergeResult mergeRes \u003d merge.call();\n+        monitor.update(1);\n+        result \u003d new PullResult(fetchRes, remote, mergeRes);\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
            "newValue": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n@throws WrongRepositoryStateException\n@throws InvalidConfigurationException\n@throws DetachedHeadException\n@throws InvalidRemoteException\n@throws CanceledException\n@throws RefNotFoundException\n@throws NoHeadException\n@throws org.eclipse.jgit.api.errors.TransportException\n@throws GitAPIException\n"
          }
        }
      ]
    },
    "4e1454ded6e2fcf6cb789c004756883c3ea5f77e": {
      "type": "Yexceptionschange",
      "commitMessage": "Git API does not declare GitAPIException call() and related cleanups\n\nAll commands should throw a GitAPIException so new exceptions can be\nadded without breaking the builds of old code, i.e. anyone that calls\na Git API should catch GitAPIException and not just the currently known\nexceptions.\n\nNow the only checked exceptions on Git API calls are GitException and\nsubclasses of it. New checked exceptions that are subclasses of\nGitException may be added without breaking the API.\n\nJavadoc for GitAPIException is declared on GitCommand and\ninherited to subclasses. JGitInternalException is not explicitly\ndocumented anymore.\n\nUnfortunately this change itself breaks the API. The intention is\nthat it shall be possible to add new checked subclasses of\nGitAPIException without breaking the API.\n\nBug: 366914\nEGit-Change-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nChange-Id: I50380f13fc82c22d0036f47c7859cc3a77e767c5\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e\n",
      "commitDate": "2012/5/31 上午4:08",
      "commitName": "4e1454ded6e2fcf6cb789c004756883c3ea5f77e",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2012/3/12 下午10:20",
      "commitNameOld": "95d311f8886f42f31a4475f84aa23c6345ab7059",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 79.24,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,112 +1,112 @@\n-public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n+public PullResult call() throws GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (fullBranch \u003d\u003d null)\n             throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]",
        "newValue": "[GitAPIException, WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
      }
    },
    "c3fe50bb18ed4e4e5e563172be4076fa5901a18a": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
      "commitDate": "2011/11/23 上午8:29",
      "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
      "commitAuthor": "Kevin Sawicki",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
          "commitDate": "2011/11/23 上午8:29",
          "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
          "commitAuthor": "Kevin Sawicki",
          "commitDateOld": "2011/11/11 上午2:57",
          "commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 12.23,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 113,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
          "diff": "@@ -1,110 +1,112 @@\n-public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n+public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n+        if (fullBranch \u003d\u003d null)\n+            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]",
            "newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Guard against null branch in PullCommand\n\nThrow a NoHeadException when Repository.getFullBranch\nreturns null\n\nBug: 351543\nChange-Id: I666cd5b67781508a293ae553c6fe5c080c8f4d99\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e",
          "commitDate": "2011/11/23 上午8:29",
          "commitName": "c3fe50bb18ed4e4e5e563172be4076fa5901a18a",
          "commitAuthor": "Kevin Sawicki",
          "commitDateOld": "2011/11/11 上午2:57",
          "commitNameOld": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
          "commitAuthorOld": "Kevin Sawicki",
          "daysBetweenCommits": 12.23,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (fullBranch \u003d\u003d null)\n            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 113,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
          "diff": "@@ -1,110 +1,112 @@\n-public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n+public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException, NoHeadException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n+        if (fullBranch \u003d\u003d null)\n+            throw new NoHeadException(JGitText.get().pullOnRepoWithoutHEADCurrentlyNotSupported);\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "da901c49688ef72858cd2b6904e0f8e478fa0ec3": {
      "type": "Ybodychange",
      "commitMessage": "Support a configured credentials provider in LsRemoteCommand\n\nRefactored the three common transport configuration options:\ncredentials provider, timeout, and transport config callback\ninto a new TransportCommand base class which is now extended\nby all commands that use a Transport object during execution.\n\nBug: 349188\nChange-Id: I90c2c14fb4e3cc4712905158f9047153a0c235c2\nSigned-off-by: Kevin Sawicki \u003ckevin@github.com\u003e\nSigned-off-by: Chris Aniszczyk \u003czx@twitter.com\u003e\n",
      "commitDate": "2011/11/11 上午2:57",
      "commitName": "da901c49688ef72858cd2b6904e0f8e478fa0ec3",
      "commitAuthor": "Kevin Sawicki",
      "commitDateOld": "2011/9/16 下午11:04",
      "commitNameOld": "791a9fd691e5ae101650f27f39366ec7b23f3955",
      "commitAuthorOld": "Roberto Tyley",
      "daysBetweenCommits": 55.16,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        configure(fetch);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 113,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,112 +1,110 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n-        fetch.setTimeout(this.timeout);\n-        fetch.setCredentialsProvider(credentialsProvider);\n-        fetch.setTransportConfigCallback(transportConfigCallback);\n+        configure(fetch);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "791a9fd691e5ae101650f27f39366ec7b23f3955": {
      "type": "Ybodychange",
      "commitMessage": "Enable full Transport configuration for JGit API commands\n\nAdd a TransportConfigCallback parameter to JGit API commands, to allow\nconsumers of the JGit command API to perform custom Transport configuration\nthat would be otherwise difficult to anticipate \u0026 expose on the API command\nbuilders.\n\n\nMy specific use-case is configuring additional properties on SshTransport\n- I need to take over the SshSessionFactory used by the transport. Using\nTransportConfigCallback I can simply do this (rather than reimplement the\nAPI command classes):\n\npublic void configure(Transport tn) {\n  if (tn instanceof SshTransport) {\n    ((SshTransport) tn).setSshSessionFactory(factoryProvider.get());\n  }\n}\n\nAdding an explicit setSshSessionFactory() method to the JGit command\nclasses would bloat the API. Also, creating the replacement\nSshSessionFactory is unnecessary if the transport is not SSH, but the type\nof the Transport is only known once the remote has been resolved and the\nURI parsed - consequently it makes sense to perform this step in a\ncallback, where the transport instance can be inspected to determine if\nit\u0027s of a relevant type.\n\n\nA note about where this leaves the API - there are now 4 commands:\n\nCloneCommand\nPullCommand\nFetchCommand\nPushCommand\n\n-that share 3 identical transport-related parameters:\n\ntimeout\ncredentialsProvider\ntransportConfigurator\n\nI think there\u0027s potential for introducing an interface or val-object to\nidentify/encapsulate this repetition, which I\u0027d be happy to do in a\nsubsequent commit.\n\nChange-Id: I8983c3627cdd7d7b2aeb0b6a3dadee553378b951\nSigned-off-by: Roberto Tyley \u003croberto.tyley@gmail.com\u003e\n",
      "commitDate": "2011/9/16 下午11:04",
      "commitName": "791a9fd691e5ae101650f27f39366ec7b23f3955",
      "commitAuthor": "Roberto Tyley",
      "commitDateOld": "2011/8/2 下午10:19",
      "commitNameOld": "6d293c7b06e219086959e80d495b5febe8ae530d",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 45.03,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetch.setTransportConfigCallback(transportConfigCallback);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 156,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,111 +1,112 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n+        fetch.setTransportConfigCallback(transportConfigCallback);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d293c7b06e219086959e80d495b5febe8ae530d": {
      "type": "Ybodychange",
      "commitMessage": "Don\u0027t hard-code section names, use ConfigConstants instead\n\nChange-Id: Ie2dde43da491fa27b25a2ad8014866d77d484b24\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2011/8/2 下午10:19",
      "commitName": "6d293c7b06e219086959e80d495b5febe8ae530d",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011/3/23 上午2:46",
      "commitNameOld": "770c733687d9f2f71f30822f9691427bf83b7577",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 132.81,
      "commitsBetweenForRepo": 160,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,111 +1,111 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n-        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n+        remoteUri \u003d repoConfig.getString(ConfigConstants.CONFIG_REMOTE_SECTION, remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n         merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "770c733687d9f2f71f30822f9691427bf83b7577": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: Use short ref name in merge message\n\nAdd a test case for PullCommand for the successful merge case and test\nthat the short ref name is used.\n\nChange-Id: I16cbbc88595f73e5512f984e67f93f87ee0fe242\nSigned-off-by: Robin Stocker \u003crobin@nibor.org\u003e\n",
      "commitDate": "2011/3/23 上午2:46",
      "commitName": "770c733687d9f2f71f30822f9691427bf83b7577",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2011/2/16 下午10:46",
      "commitNameOld": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
      "commitAuthorOld": "Stefan Lay",
      "daysBetweenCommits": 34.17,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n        merge.include(name, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,110 +1,111 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n             if (commitToMerge \u003d\u003d null)\n                 throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n-        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n+        String name \u003d \"branch \\\u0027\" + Repository.shortenRefName(remoteBranchName) + \"\\\u0027 of \" + remoteUri;\n+        merge.include(name, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68459b646e6c8243dc5650cbe08ce1bcdb8a621d": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
      "commitDate": "2011/2/16 下午10:46",
      "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
      "commitAuthor": "Stefan Lay",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
          "commitDate": "2011/2/16 下午10:46",
          "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
          "commitAuthor": "Stefan Lay",
          "commitDateOld": "2011/2/8 下午3:56",
          "commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
          "commitAuthorOld": "Mathias Kinzler",
          "daysBetweenCommits": 8.28,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 139,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
          "diff": "@@ -1,108 +1,110 @@\n-public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n+public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n+            if (commitToMerge \u003d\u003d null)\n+                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException]",
            "newValue": "[WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix NullPointer when pulling from a deleted local branch\n\nA checked Exception is thrown instead. \n\nThe reason for throwing an Exception is that the state of the\nrepository is inconsistent in this case: There is a merge\nconfiguration containing a non-existing local branch. Ideally the\ndeletion of a local branch should also delete the corresponding\nmerge configuration.\n\nBug: 337315\nChange-Id: I71e56ffb90e11e6e3c1bbd964ad63972d67990c0\nSigned-off-by: Stefan Lay \u003cstefan.lay@sap.com\u003e",
          "commitDate": "2011/2/16 下午10:46",
          "commitName": "68459b646e6c8243dc5650cbe08ce1bcdb8a621d",
          "commitAuthor": "Stefan Lay",
          "commitDateOld": "2011/2/8 下午3:56",
          "commitNameOld": "724af77c65c27eb24d41989bed3229910dbe063c",
          "commitAuthorOld": "Mathias Kinzler",
          "daysBetweenCommits": 8.28,
          "commitsBetweenForRepo": 23,
          "commitsBetweenForFile": 1,
          "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n            if (commitToMerge \u003d\u003d null)\n                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
          "functionStartLine": 139,
          "functionName": "call",
          "functionAnnotation": "",
          "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
          "diff": "@@ -1,108 +1,110 @@\n-public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n+public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException, RefNotFoundException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null)\n         remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n+            if (commitToMerge \u003d\u003d null)\n+                throw new RefNotFoundException(MessageFormat.format(JGitText.get().refNotResolved, remoteBranchName));\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "724af77c65c27eb24d41989bed3229910dbe063c": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: use default remote instead of throwing Exception\n\nWhen pulling into a local branch that has no upstream configuration,\npull should try to used the default remote (\"origin\") instead of\nthrowing an Exception.\n\nBug: 336504\nChange-Id: Ife75858e89ea79c0d6d88ba73877fe8400448e34\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011/2/8 下午3:56",
      "commitName": "724af77c65c27eb24d41989bed3229910dbe063c",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011/1/31 下午7:12",
      "commitNameOld": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null)\n        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,110 +1,108 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n-    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n-    if (remote \u003d\u003d null) {\n-        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n-        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n-    }\n+    String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n+    if (remote \u003d\u003d null)\n+        remote \u003d Constants.DEFAULT_REMOTE_NAME;\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b15b9d5df25b375108ca125b31338df637454865": {
      "type": "Ybodychange",
      "commitMessage": "Proper handling of rebase during pull\n\nAfter consulting with Christian Halstrick, it turned out that the\nhandling of rebase during pull was implemented incorrectly.\n\nChange-Id: I40f03409e080cdfeceb21460150f5e02a016e7f4\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011/1/31 下午7:12",
      "commitName": "b15b9d5df25b375108ca125b31338df637454865",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2011/1/29 上午4:06",
      "commitNameOld": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
      "commitAuthorOld": "Tomasz Zarna",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,116 +1,110 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n-    boolean doRebase \u003d false;\n-    if (remoteBranchName \u003d\u003d null) {\n-        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n-        if (remoteBranchName !\u003d null) {\n-            doRebase \u003d true;\n-        }\n-    }\n+    boolean doRebase \u003d repoConfig.getBoolean(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE, false);\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n+    AnyObjectId commitToMerge;\n+    if (isRemote) {\n+        Ref r \u003d null;\n+        if (fetchRes !\u003d null) {\n+            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+            if (r \u003d\u003d null)\n+                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n+        }\n+        if (r \u003d\u003d null)\n+            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n+        else\n+            commitToMerge \u003d r.getObjectId();\n+    } else {\n+        try {\n+            commitToMerge \u003d repo.resolve(remoteBranchName);\n+        } catch (IOException e) {\n+            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n+        }\n+    }\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n-            RebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+            RebaseResult rebaseRes \u003d rebase.setUpstream(commitToMerge).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n-        AnyObjectId commitToMerge;\n-        if (isRemote) {\n-            Ref r \u003d null;\n-            if (fetchRes !\u003d null) {\n-                r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-                if (r \u003d\u003d null)\n-                    r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n-            }\n-            if (r \u003d\u003d null)\n-                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n-            else\n-                commitToMerge \u003d r.getObjectId();\n-        } else {\n-            try {\n-                commitToMerge \u003d repo.resolve(remoteBranchName);\n-            } catch (IOException e) {\n-                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n-            }\n-        }\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9fbda2239202ca9d3a20c84d7326f47c667aa920": {
      "type": "Ybodychange",
      "commitMessage": "Add setCredentialsProvider to PullCommand\n\nBug: 335703\nChange-Id: Id9713a4849c772e030fca23dd64b993264f28366\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2011/1/29 上午4:06",
      "commitName": "9fbda2239202ca9d3a20c84d7326f47c667aa920",
      "commitAuthor": "Tomasz Zarna",
      "commitDateOld": "2011/1/28 下午10:04",
      "commitNameOld": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName !\u003d null) {\n            doRebase \u003d true;\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetch.setCredentialsProvider(credentialsProvider);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        AnyObjectId commitToMerge;\n        if (isRemote) {\n            Ref r \u003d null;\n            if (fetchRes !\u003d null) {\n                r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n                if (r \u003d\u003d null)\n                    r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n            }\n            if (r \u003d\u003d null)\n                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n            else\n                commitToMerge \u003d r.getObjectId();\n        } else {\n            try {\n                commitToMerge \u003d repo.resolve(remoteBranchName);\n            } catch (IOException e) {\n                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n            }\n        }\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 139,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,115 +1,116 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     boolean doRebase \u003d false;\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n         if (remoteBranchName !\u003d null) {\n             doRebase \u003d true;\n         }\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n+        fetch.setCredentialsProvider(credentialsProvider);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     PullResult result;\n     if (doRebase) {\n         RebaseCommand rebase \u003d new RebaseCommand(repo);\n         try {\n             RebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n             result \u003d new PullResult(fetchRes, remote, rebaseRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (RefNotFoundException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (JGitInternalException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (GitAPIException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     } else {\n         AnyObjectId commitToMerge;\n         if (isRemote) {\n             Ref r \u003d null;\n             if (fetchRes !\u003d null) {\n                 r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n                 if (r \u003d\u003d null)\n                     r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n             }\n             if (r \u003d\u003d null)\n                 throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n             else\n                 commitToMerge \u003d r.getObjectId();\n         } else {\n             try {\n                 commitToMerge \u003d repo.resolve(remoteBranchName);\n             } catch (IOException e) {\n                 throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n             }\n         }\n         MergeCommand merge \u003d new MergeCommand(repo);\n         merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n         MergeResult mergeRes;\n         try {\n             mergeRes \u003d merge.call();\n             monitor.update(1);\n             result \u003d new PullResult(fetchRes, remote, mergeRes);\n         } catch (NoHeadException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (ConcurrentRefUpdateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (CheckoutConflictException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (InvalidMergeHeadsException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (WrongRepositoryStateException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         } catch (NoMessageException e) {\n             throw new JGitInternalException(e.getMessage(), e);\n         }\n     }\n     monitor.endTask();\n     return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14ca80bc90ed85e3484fa28aa665fa0538096d30": {
      "type": "Ybodychange",
      "commitMessage": "Make PullCommand work with Rebase\n\nRebase must honor the upstream configuration\n\nbranch.\u003cbranchname\u003e.rebase\n\nChange-Id: Ic94f263d3f47b630ad75bd5412cb4741bb1109ca\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2011/1/28 下午10:04",
      "commitName": "14ca80bc90ed85e3484fa28aa665fa0538096d30",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/12/16 上午7:14",
      "commitNameOld": "013cb8de3824c304645a9c5db87c2e80286872d1",
      "commitAuthorOld": "Shawn O. Pearce",
      "daysBetweenCommits": 43.62,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    boolean doRebase \u003d false;\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName !\u003d null) {\n            doRebase \u003d true;\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    PullResult result;\n    if (doRebase) {\n        RebaseCommand rebase \u003d new RebaseCommand(repo);\n        try {\n            RebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (RefNotFoundException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (JGitInternalException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (GitAPIException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    } else {\n        AnyObjectId commitToMerge;\n        if (isRemote) {\n            Ref r \u003d null;\n            if (fetchRes !\u003d null) {\n                r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n                if (r \u003d\u003d null)\n                    r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n            }\n            if (r \u003d\u003d null)\n                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n            else\n                commitToMerge \u003d r.getObjectId();\n        } else {\n            try {\n                commitToMerge \u003d repo.resolve(remoteBranchName);\n            } catch (IOException e) {\n                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n            }\n        }\n        MergeCommand merge \u003d new MergeCommand(repo);\n        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n        MergeResult mergeRes;\n        try {\n            mergeRes \u003d merge.call();\n            monitor.update(1);\n            result \u003d new PullResult(fetchRes, remote, mergeRes);\n        } catch (NoHeadException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (ConcurrentRefUpdateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (CheckoutConflictException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (InvalidMergeHeadsException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (WrongRepositoryStateException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        } catch (NoMessageException e) {\n            throw new JGitInternalException(e.getMessage(), e);\n        }\n    }\n    monitor.endTask();\n    return result;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 124,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,96 +1,115 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+    boolean doRebase \u003d false;\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n         if (remoteBranchName !\u003d null) {\n-            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n+            doRebase \u003d true;\n         }\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n-    AnyObjectId commitToMerge;\n-    if (isRemote) {\n-        Ref r \u003d null;\n-        if (fetchRes !\u003d null) {\n-            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-            if (r \u003d\u003d null)\n-                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n-        }\n-        if (r \u003d\u003d null)\n-            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n-        else\n-            commitToMerge \u003d r.getObjectId();\n-    } else {\n-        try {\n-            commitToMerge \u003d repo.resolve(remoteBranchName);\n-        } catch (IOException e) {\n-            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n-        }\n-    }\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n-    MergeCommand merge \u003d new MergeCommand(repo);\n-    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n-    MergeResult mergeRes;\n-    try {\n-        mergeRes \u003d merge.call();\n-        monitor.update(1);\n-    } catch (NoHeadException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n-    } catch (ConcurrentRefUpdateException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n-    } catch (CheckoutConflictException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n-    } catch (InvalidMergeHeadsException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n-    } catch (WrongRepositoryStateException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n-    } catch (NoMessageException e) {\n-        throw new JGitInternalException(e.getMessage(), e);\n+    PullResult result;\n+    if (doRebase) {\n+        RebaseCommand rebase \u003d new RebaseCommand(repo);\n+        try {\n+            RebaseResult rebaseRes \u003d rebase.setUpstream(remoteBranchName).setProgressMonitor(monitor).setOperation(Operation.BEGIN).call();\n+            result \u003d new PullResult(fetchRes, remote, rebaseRes);\n+        } catch (NoHeadException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (RefNotFoundException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (JGitInternalException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (GitAPIException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        }\n+    } else {\n+        AnyObjectId commitToMerge;\n+        if (isRemote) {\n+            Ref r \u003d null;\n+            if (fetchRes !\u003d null) {\n+                r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+                if (r \u003d\u003d null)\n+                    r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n+            }\n+            if (r \u003d\u003d null)\n+                throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n+            else\n+                commitToMerge \u003d r.getObjectId();\n+        } else {\n+            try {\n+                commitToMerge \u003d repo.resolve(remoteBranchName);\n+            } catch (IOException e) {\n+                throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n+            }\n+        }\n+        MergeCommand merge \u003d new MergeCommand(repo);\n+        merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n+        MergeResult mergeRes;\n+        try {\n+            mergeRes \u003d merge.call();\n+            monitor.update(1);\n+            result \u003d new PullResult(fetchRes, remote, mergeRes);\n+        } catch (NoHeadException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (ConcurrentRefUpdateException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (CheckoutConflictException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (InvalidMergeHeadsException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (WrongRepositoryStateException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        } catch (NoMessageException e) {\n+            throw new JGitInternalException(e.getMessage(), e);\n+        }\n     }\n     monitor.endTask();\n-    return new PullResult(fetchRes, remote, mergeRes);\n+    return result;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "013cb8de3824c304645a9c5db87c2e80286872d1": {
      "type": "Ybodychange",
      "commitMessage": "Reduce calls to Repository.getConfig\n\nEach time getConfig() is called on FileRepository, it checks the\nlast modified time of both ~/.gitconfig and $GIT_DIR?config.  If\n$GIT_DIR/config appears to have been modified, it is read back in\nfrom disk and the current config is wiped out.\n\nWhen mutating a configuration file, this may cause in-memory edits\nto disappear.  To avoid that callers need to avoid calling getConfig\nuntil after the configuration has been saved to disk.\n\nUnfortunately the API is still horribly broken.  Configuration should\nbe modified only while a lock is held on the configuration file, very\nsimilar to the way a ref is updated via its locking protocol.  But our\nexisting API is really broken for that so we\u0027ll have to defer cleaning\nup the edit path for a future change.\n\nChange-Id: I5888dd97bac20ddf60456c81ffc1eb8df04ef410\nSigned-off-by: Shawn O. Pearce \u003cspearce@spearce.org\u003e\n",
      "commitDate": "2010/12/16 上午7:14",
      "commitName": "013cb8de3824c304645a9c5db87c2e80286872d1",
      "commitAuthor": "Shawn O. Pearce",
      "commitDateOld": "2010/10/29 下午9:12",
      "commitNameOld": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
      "commitAuthorOld": "Robin Stocker",
      "daysBetweenCommits": 47.42,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName !\u003d null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge \u003d new MergeCommand(repo);\n    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes \u003d merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,96 +1,96 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n         if (remoteBranchName !\u003d null) {\n             throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n         }\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n-        remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n+        remoteUri \u003d repoConfig.getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n         fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     MergeCommand merge \u003d new MergeCommand(repo);\n     merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n     MergeResult mergeRes;\n     try {\n         mergeRes \u003d merge.call();\n         monitor.update(1);\n     } catch (NoHeadException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (ConcurrentRefUpdateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (CheckoutConflictException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (InvalidMergeHeadsException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (WrongRepositoryStateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (NoMessageException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     }\n     monitor.endTask();\n     return new PullResult(fetchRes, remote, mergeRes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary null check\n\nThe field monitor is never null, it\u0027s a NullProgressMonitor when not\nexplicitly set.\n\nChange-Id: I8ce703a32c28ce5c3455efeb7ed5f5c9a443cbef\n",
      "commitDate": "2010/10/29 下午9:12",
      "commitName": "d36c80fd048fc55d7ac31ae62eb67fbac9b12e31",
      "commitAuthor": "Robin Stocker",
      "commitDateOld": "2010/10/29 上午12:18",
      "commitNameOld": "7668a462829b12e4f6a192c43157152ef63ff305",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName !\u003d null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge \u003d new MergeCommand(repo);\n    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes \u003d merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,97 +1,96 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (remoteBranchName \u003d\u003d null) {\n         remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n         if (remoteBranchName !\u003d null) {\n             throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n         }\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n     final boolean isRemote \u003d !remote.equals(\".\");\n     String remoteUri;\n     FetchResult fetchRes;\n     if (isRemote) {\n         remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n         if (remoteUri \u003d\u003d null) {\n             String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n             throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n         }\n         if (monitor.isCancelled())\n             throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n         FetchCommand fetch \u003d new FetchCommand(repo);\n         fetch.setRemote(remote);\n-        if (monitor !\u003d null)\n-            fetch.setProgressMonitor(monitor);\n+        fetch.setProgressMonitor(monitor);\n         fetch.setTimeout(this.timeout);\n         fetchRes \u003d fetch.call();\n     } else {\n         remoteUri \u003d \"local repository\";\n         fetchRes \u003d null;\n     }\n     monitor.update(1);\n     AnyObjectId commitToMerge;\n     if (isRemote) {\n         Ref r \u003d null;\n         if (fetchRes !\u003d null) {\n             r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n             if (r \u003d\u003d null)\n                 r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n         }\n         if (r \u003d\u003d null)\n             throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n         else\n             commitToMerge \u003d r.getObjectId();\n     } else {\n         try {\n             commitToMerge \u003d repo.resolve(remoteBranchName);\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n     }\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     MergeCommand merge \u003d new MergeCommand(repo);\n     merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n     MergeResult mergeRes;\n     try {\n         mergeRes \u003d merge.call();\n         monitor.update(1);\n     } catch (NoHeadException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (ConcurrentRefUpdateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (CheckoutConflictException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (InvalidMergeHeadsException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (WrongRepositoryStateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (NoMessageException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     }\n     monitor.endTask();\n     return new PullResult(fetchRes, remote, mergeRes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7668a462829b12e4f6a192c43157152ef63ff305": {
      "type": "Ybodychange",
      "commitMessage": "PullCommand: support upstream configuration for local branches\n\nWhen creating a local branch based on another local branch, the\nupstream configuration contains \".\" as origin and the source branch\nas \"merge\". The PullCommand should support this by skipping the\nfetch step altogether and use the base branch to merge with.\n\nChange-Id: I260a1771aeeffca5b0161d1494fd63c672ecc2a6\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\n",
      "commitDate": "2010/10/29 上午12:18",
      "commitName": "7668a462829b12e4f6a192c43157152ef63ff305",
      "commitAuthor": "Mathias Kinzler",
      "commitDateOld": "2010/10/8 下午9:57",
      "commitNameOld": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
      "commitAuthorOld": "Mathias Kinzler",
      "daysBetweenCommits": 20.1,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n        if (remoteBranchName !\u003d null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final boolean isRemote \u003d !remote.equals(\".\");\n    String remoteUri;\n    FetchResult fetchRes;\n    if (isRemote) {\n        remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n        if (remoteUri \u003d\u003d null) {\n            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n        }\n        if (monitor.isCancelled())\n            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n        FetchCommand fetch \u003d new FetchCommand(repo);\n        fetch.setRemote(remote);\n        if (monitor !\u003d null)\n            fetch.setProgressMonitor(monitor);\n        fetch.setTimeout(this.timeout);\n        fetchRes \u003d fetch.call();\n    } else {\n        remoteUri \u003d \"local repository\";\n        fetchRes \u003d null;\n    }\n    monitor.update(1);\n    AnyObjectId commitToMerge;\n    if (isRemote) {\n        Ref r \u003d null;\n        if (fetchRes !\u003d null) {\n            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n            if (r \u003d\u003d null)\n                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n        }\n        if (r \u003d\u003d null)\n            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n        else\n            commitToMerge \u003d r.getObjectId();\n    } else {\n        try {\n            commitToMerge \u003d repo.resolve(remoteBranchName);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge \u003d new MergeCommand(repo);\n    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes \u003d merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n",
      "diff": "@@ -1,83 +1,97 @@\n public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n     checkCallable();\n     monitor.beginTask(JGitText.get().pullTaskName, 2);\n     String branchName;\n     try {\n         String fullBranch \u003d repo.getFullBranch();\n         if (!fullBranch.startsWith(Constants.R_HEADS)) {\n             throw new DetachedHeadException();\n         }\n         branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n     } catch (IOException e) {\n         throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n     }\n     if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n         throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n     Config repoConfig \u003d repo.getConfig();\n     final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n     if (remote \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n-    final String remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n-    if (remoteUri \u003d\u003d null) {\n-        String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n-        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n-    }\n     String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n     if (remoteBranchName \u003d\u003d null) {\n-        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REBASE);\n         if (remoteBranchName !\u003d null) {\n             throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n         }\n     }\n     if (remoteBranchName \u003d\u003d null) {\n         String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n         throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n     }\n-    if (monitor.isCancelled())\n-        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n-    FetchCommand fetch \u003d new FetchCommand(repo);\n-    fetch.setRemote(remote);\n-    if (monitor !\u003d null)\n-        fetch.setProgressMonitor(monitor);\n-    fetch.setTimeout(this.timeout);\n-    FetchResult fetchRes \u003d fetch.call();\n+    final boolean isRemote \u003d !remote.equals(\".\");\n+    String remoteUri;\n+    FetchResult fetchRes;\n+    if (isRemote) {\n+        remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n+        if (remoteUri \u003d\u003d null) {\n+            String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n+            throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n+        }\n+        if (monitor.isCancelled())\n+            throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n+        FetchCommand fetch \u003d new FetchCommand(repo);\n+        fetch.setRemote(remote);\n+        if (monitor !\u003d null)\n+            fetch.setProgressMonitor(monitor);\n+        fetch.setTimeout(this.timeout);\n+        fetchRes \u003d fetch.call();\n+    } else {\n+        remoteUri \u003d \"local repository\";\n+        fetchRes \u003d null;\n+    }\n     monitor.update(1);\n-    AnyObjectId commitToMerge \u003d null;\n-    Ref r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n-    if (r \u003d\u003d null)\n-        r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n-    if (r \u003d\u003d null) {\n-        String remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027 + branchName;\n+    AnyObjectId commitToMerge;\n+    if (isRemote) {\n+        Ref r \u003d null;\n+        if (fetchRes !\u003d null) {\n+            r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+            if (r \u003d\u003d null)\n+                r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n+        }\n+        if (r \u003d\u003d null)\n+            throw new JGitInternalException(MessageFormat.format(JGitText.get().couldNotGetAdvertisedRef, remoteBranchName));\n+        else\n+            commitToMerge \u003d r.getObjectId();\n+    } else {\n         try {\n-            commitToMerge \u003d repo.resolve(remoteTrackingBranch);\n+            commitToMerge \u003d repo.resolve(remoteBranchName);\n         } catch (IOException e) {\n             throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n         }\n-    } else\n-        commitToMerge \u003d r.getObjectId();\n+    }\n     if (monitor.isCancelled())\n         throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n     MergeCommand merge \u003d new MergeCommand(repo);\n     merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n     MergeResult mergeRes;\n     try {\n         mergeRes \u003d merge.call();\n         monitor.update(1);\n     } catch (NoHeadException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (ConcurrentRefUpdateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (CheckoutConflictException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (InvalidMergeHeadsException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (WrongRepositoryStateException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     } catch (NoMessageException e) {\n         throw new JGitInternalException(e.getMessage(), e);\n     }\n     monitor.endTask();\n     return new PullResult(fetchRes, remote, mergeRes);\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "db55d13f5f4b641a9390076ced6b1775bcfcd6f6": {
      "type": "Yintroduced",
      "commitMessage": "Add \"Pull\" command\n\nThis is the minimal implementation of a \"Pull\" command. It does not\nhave any parameters besides the generic progress monitor and timeout.\nIt works on the currently checked-out branch and assumes that the\nconfiguration contains the keys \"branch.\u003cbranch name\u003e.remote\" and\n\"branch.\u003cbranch name\u003e.merge\" to determine the remote configuration\nfor the fetch and the remote branch name for the merge.\n\nBug: 303404\nChange-Id: I7fe09029996d0cfc09a7d8f097b5d6af1488fa93\nSigned-off-by: Mathias Kinzler \u003cmathias.kinzler@sap.com\u003e\nSigned-off-by: Chris Aniszczyk \u003ccaniszczyk@gmail.com\u003e\n",
      "commitDate": "2010/10/8 下午9:57",
      "commitName": "db55d13f5f4b641a9390076ced6b1775bcfcd6f6",
      "commitAuthor": "Mathias Kinzler",
      "diff": "@@ -0,0 +1,83 @@\n+public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n+    checkCallable();\n+    monitor.beginTask(JGitText.get().pullTaskName, 2);\n+    String branchName;\n+    try {\n+        String fullBranch \u003d repo.getFullBranch();\n+        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n+            throw new DetachedHeadException();\n+        }\n+        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n+    } catch (IOException e) {\n+        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n+    }\n+    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n+        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n+    Config repoConfig \u003d repo.getConfig();\n+    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n+    if (remote \u003d\u003d null) {\n+        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n+        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n+    }\n+    final String remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n+    if (remoteUri \u003d\u003d null) {\n+        String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n+        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n+    }\n+    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+    if (remoteBranchName \u003d\u003d null) {\n+        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n+        if (remoteBranchName !\u003d null) {\n+            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n+        }\n+    }\n+    if (remoteBranchName \u003d\u003d null) {\n+        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n+        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n+    }\n+    if (monitor.isCancelled())\n+        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n+    FetchCommand fetch \u003d new FetchCommand(repo);\n+    fetch.setRemote(remote);\n+    if (monitor !\u003d null)\n+        fetch.setProgressMonitor(monitor);\n+    fetch.setTimeout(this.timeout);\n+    FetchResult fetchRes \u003d fetch.call();\n+    monitor.update(1);\n+    AnyObjectId commitToMerge \u003d null;\n+    Ref r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n+    if (r \u003d\u003d null)\n+        r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n+    if (r \u003d\u003d null) {\n+        String remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027 + branchName;\n+        try {\n+            commitToMerge \u003d repo.resolve(remoteTrackingBranch);\n+        } catch (IOException e) {\n+            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n+        }\n+    } else\n+        commitToMerge \u003d r.getObjectId();\n+    if (monitor.isCancelled())\n+        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n+    MergeCommand merge \u003d new MergeCommand(repo);\n+    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n+    MergeResult mergeRes;\n+    try {\n+        mergeRes \u003d merge.call();\n+        monitor.update(1);\n+    } catch (NoHeadException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    } catch (ConcurrentRefUpdateException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    } catch (CheckoutConflictException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    } catch (InvalidMergeHeadsException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    } catch (WrongRepositoryStateException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    } catch (NoMessageException e) {\n+        throw new JGitInternalException(e.getMessage(), e);\n+    }\n+    monitor.endTask();\n+    return new PullResult(fetchRes, remote, mergeRes);\n+}\n\\ No newline at end of file\n",
      "actualSource": "public PullResult call() throws WrongRepositoryStateException, InvalidConfigurationException, DetachedHeadException, InvalidRemoteException, CanceledException {\n    checkCallable();\n    monitor.beginTask(JGitText.get().pullTaskName, 2);\n    String branchName;\n    try {\n        String fullBranch \u003d repo.getFullBranch();\n        if (!fullBranch.startsWith(Constants.R_HEADS)) {\n            throw new DetachedHeadException();\n        }\n        branchName \u003d fullBranch.substring(Constants.R_HEADS.length());\n    } catch (IOException e) {\n        throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n    }\n    if (!repo.getRepositoryState().equals(RepositoryState.SAFE))\n        throw new WrongRepositoryStateException(MessageFormat.format(JGitText.get().cannotPullOnARepoWithState, repo.getRepositoryState().name()));\n    Config repoConfig \u003d repo.getConfig();\n    final String remote \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE);\n    if (remote \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_REMOTE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    final String remoteUri \u003d repo.getConfig().getString(\"remote\", remote, ConfigConstants.CONFIG_KEY_URL);\n    if (remoteUri \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_REMOTE_SECTION + DOT + remote + DOT + ConfigConstants.CONFIG_KEY_URL;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    String remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n    if (remoteBranchName \u003d\u003d null) {\n        remoteBranchName \u003d repoConfig.getString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE);\n        if (remoteBranchName !\u003d null) {\n            throw new JGitInternalException(\"Pull with rebase is not yet supported\");\n        }\n    }\n    if (remoteBranchName \u003d\u003d null) {\n        String missingKey \u003d ConfigConstants.CONFIG_BRANCH_SECTION + DOT + branchName + DOT + ConfigConstants.CONFIG_KEY_MERGE;\n        throw new InvalidConfigurationException(MessageFormat.format(JGitText.get().missingConfigurationForKey, missingKey));\n    }\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    FetchCommand fetch \u003d new FetchCommand(repo);\n    fetch.setRemote(remote);\n    if (monitor !\u003d null)\n        fetch.setProgressMonitor(monitor);\n    fetch.setTimeout(this.timeout);\n    FetchResult fetchRes \u003d fetch.call();\n    monitor.update(1);\n    AnyObjectId commitToMerge \u003d null;\n    Ref r \u003d fetchRes.getAdvertisedRef(remoteBranchName);\n    if (r \u003d\u003d null)\n        r \u003d fetchRes.getAdvertisedRef(Constants.R_HEADS + remoteBranchName);\n    if (r \u003d\u003d null) {\n        String remoteTrackingBranch \u003d Constants.R_REMOTES + remote + \u0027/\u0027 + branchName;\n        try {\n            commitToMerge \u003d repo.resolve(remoteTrackingBranch);\n        } catch (IOException e) {\n            throw new JGitInternalException(JGitText.get().exceptionCaughtDuringExecutionOfPullCommand, e);\n        }\n    } else\n        commitToMerge \u003d r.getObjectId();\n    if (monitor.isCancelled())\n        throw new CanceledException(MessageFormat.format(JGitText.get().operationCanceled, JGitText.get().pullTaskName));\n    MergeCommand merge \u003d new MergeCommand(repo);\n    merge.include(\"branch \\\u0027\" + remoteBranchName + \"\\\u0027 of \" + remoteUri, commitToMerge);\n    MergeResult mergeRes;\n    try {\n        mergeRes \u003d merge.call();\n        monitor.update(1);\n    } catch (NoHeadException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (ConcurrentRefUpdateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (CheckoutConflictException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (InvalidMergeHeadsException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (WrongRepositoryStateException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    } catch (NoMessageException e) {\n        throw new JGitInternalException(e.getMessage(), e);\n    }\n    monitor.endTask();\n    return new PullResult(fetchRes, remote, mergeRes);\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/api/PullCommand.java",
      "functionStartLine": 121,
      "functionName": "call",
      "functionAnnotation": "",
      "functionDoc": "Executes the {@code Pull} command with all the options and parameters\ncollected by the setter methods (e.g.\n{@link #setProgressMonitor(ProgressMonitor)}) of this class. Each\ninstance of this class should only be used for one invocation of the\ncommand. Don\u0027t call this method twice on an instance.\n\n@return the result of the pull\n"
    }
  }
}