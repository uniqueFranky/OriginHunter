{
  "origin": "codeshovel",
  "repositoryName": "hibernate-orm",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/hibernate-orm/.git",
  "startCommitName": "8bd79b29cfa7b2d539a746dc356d60b66e1e596b",
  "sourceFileName": "DefaultRefreshEventListener.java",
  "functionName": "onRefresh",
  "functionId": "onRefresh___event-RefreshEvent__refreshedAlready-Map",
  "sourceFilePath": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
  "functionAnnotation": "",
  "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
  "functionStartLine": 56,
  "functionEndLine": 229,
  "numCommitsSeen": 47,
  "timeTaken": 3990,
  "changeHistory": [
    "12b79a59383d1b647c9957815ef53861f0752dad",
    "a286232da374cbccefddbf406830dbb598b6c824",
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
    "59c3baae3271247bed516fe50952b65be1a27e5b",
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
    "8c9152040c469a096cd78b18234a66c973d5e07e",
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
    "cffe71aeba38977f526b5ce7e870609ea419471c",
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
    "fb15ee548ca1c8fb80f77497271931404f54c19e",
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
    "129c0f13482b99e2705f0e234b6bc0572a95c271",
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
    "fe8c7183d172946a03818be2cec1c9c2fc819316",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
    "14bdaec5e75bded557e8410d818a7b77308dd80b",
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
    "c18a9306b9f8995331240b66c01fea304e01d06f",
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
    "35ca4c35635f26b9a86b260ad974ba7da429950b",
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
    "d8d6d82e30960e0c255950eaf875ad48831b12b0"
  ],
  "changeHistoryShort": {
    "12b79a59383d1b647c9957815ef53861f0752dad": "Ybodychange",
    "a286232da374cbccefddbf406830dbb598b6c824": "Ybodychange",
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a": "Ybodychange",
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b": "Ybodychange",
    "59c3baae3271247bed516fe50952b65be1a27e5b": "Ybodychange",
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4": "Ybodychange",
    "8c9152040c469a096cd78b18234a66c973d5e07e": "Ybodychange",
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b": "Ybodychange",
    "cffe71aeba38977f526b5ce7e870609ea419471c": "Ybodychange",
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f": "Ybodychange",
    "fb15ee548ca1c8fb80f77497271931404f54c19e": "Ybodychange",
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc": "Ybodychange",
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb": "Ybodychange",
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6": "Ybodychange",
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3": "Ybodychange",
    "129c0f13482b99e2705f0e234b6bc0572a95c271": "Ybodychange",
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9": "Ybodychange",
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace": "Ybodychange",
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173": "Yfilerename",
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66": "Ybodychange",
    "fe8c7183d172946a03818be2cec1c9c2fc819316": "Ybodychange",
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": "Ybodychange",
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": "Ybodychange",
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": "Yfilerename",
    "14bdaec5e75bded557e8410d818a7b77308dd80b": "Ybodychange",
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b": "Ybodychange",
    "c18a9306b9f8995331240b66c01fea304e01d06f": "Ybodychange",
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df": "Ybodychange",
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49": "Ybodychange",
    "35ca4c35635f26b9a86b260ad974ba7da429950b": "Ybodychange",
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1": "Yfilerename",
    "d8d6d82e30960e0c255950eaf875ad48831b12b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "12b79a59383d1b647c9957815ef53861f0752dad": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12257 - Refreshing an entity clears the lock mode returned from EntityManager.getLockMode\n",
      "commitDate": "2018/4/27 上午2:46",
      "commitName": "12b79a59383d1b647c9957815ef53861f0752dad",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018/4/27 上午2:46",
      "commitNameOld": "a286232da374cbccefddbf406830dbb598b6c824",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    LockOptions lockOptionsToUse \u003d event.getLockOptions();\n    final LockMode requestedLockMode \u003d lockOptionsToUse.getLockMode();\n    LockMode postRefreshLockMode \u003d null;\n    if (e !\u003d null) {\n        final LockMode currentLockMode \u003d e.getLockMode();\n        if (currentLockMode.greaterThan(requestedLockMode)) {\n            lockOptionsToUse \u003d LockOptions.copy(event.getLockOptions(), new LockOptions());\n            if (currentLockMode \u003d\u003d LockMode.WRITE) {\n                lockOptionsToUse.setLockMode(LockMode.READ);\n                postRefreshLockMode \u003d LockMode.WRITE;\n            } else {\n                lockOptionsToUse.setLockMode(currentLockMode);\n            }\n        }\n    }\n    final Object result \u003d persister.load(id, object, lockOptionsToUse, source);\n    if (result !\u003d null) {\n        if (postRefreshLockMode !\u003d null) {\n            source.getPersistenceContext().getEntry(result).setLockMode(postRefreshLockMode);\n        }\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,82 +1,94 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient;\n     if (event.getEntityName() !\u003d null) {\n         isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n     } else {\n         isTransient \u003d !source.contains(event.getObject());\n     }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source, object).process(object, persister);\n         }\n     }\n     if (persister.canWriteToCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         cache.remove(source, ck);\n         source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n-    final LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n     LockOptions lockOptionsToUse \u003d event.getLockOptions();\n-    if (currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan(event.getLockMode())) {\n-        lockOptionsToUse \u003d LockOptions.copy(event.getLockOptions(), new LockOptions());\n-        lockOptionsToUse.setLockMode(currentLockMode);\n+    final LockMode requestedLockMode \u003d lockOptionsToUse.getLockMode();\n+    LockMode postRefreshLockMode \u003d null;\n+    if (e !\u003d null) {\n+        final LockMode currentLockMode \u003d e.getLockMode();\n+        if (currentLockMode.greaterThan(requestedLockMode)) {\n+            lockOptionsToUse \u003d LockOptions.copy(event.getLockOptions(), new LockOptions());\n+            if (currentLockMode \u003d\u003d LockMode.WRITE) {\n+                lockOptionsToUse.setLockMode(LockMode.READ);\n+                postRefreshLockMode \u003d LockMode.WRITE;\n+            } else {\n+                lockOptionsToUse.setLockMode(currentLockMode);\n+            }\n+        }\n     }\n-    Object result \u003d persister.load(id, object, lockOptionsToUse, source);\n+    final Object result \u003d persister.load(id, object, lockOptionsToUse, source);\n     if (result !\u003d null) {\n+        if (postRefreshLockMode !\u003d null) {\n+            source.getPersistenceContext().getEntry(result).setLockMode(postRefreshLockMode);\n+        }\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a286232da374cbccefddbf406830dbb598b6c824": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12257 : Refreshing an entity clears the lock mode\n",
      "commitDate": "2018/4/27 上午2:46",
      "commitName": "a286232da374cbccefddbf406830dbb598b6c824",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2018/3/23 上午2:25",
      "commitNameOld": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 35.01,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    final LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n    LockOptions lockOptionsToUse \u003d event.getLockOptions();\n    if (currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan(event.getLockMode())) {\n        lockOptionsToUse \u003d LockOptions.copy(event.getLockOptions(), new LockOptions());\n        lockOptionsToUse.setLockMode(currentLockMode);\n    }\n    Object result \u003d persister.load(id, object, lockOptionsToUse, source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 60,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,76 +1,82 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient;\n     if (event.getEntityName() !\u003d null) {\n         isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n     } else {\n         isTransient \u003d !source.contains(event.getObject());\n     }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source, object).process(object, persister);\n         }\n     }\n     if (persister.canWriteToCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         cache.remove(source, ck);\n         source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n-    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n+    final LockMode currentLockMode \u003d e \u003d\u003d null ? null : e.getLockMode();\n+    LockOptions lockOptionsToUse \u003d event.getLockOptions();\n+    if (currentLockMode !\u003d null \u0026\u0026 currentLockMode.greaterThan(event.getLockMode())) {\n+        lockOptionsToUse \u003d LockOptions.copy(event.getLockOptions(), new LockOptions());\n+        lockOptionsToUse.setLockMode(currentLockMode);\n+    }\n+    Object result \u003d persister.load(id, object, lockOptionsToUse, source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f432ecea687ce606144c8fca1f4fc7f1937e1c2a": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11356 - Adjust the 2nd-Cache SPIs to better reflect supported uses\nHHH-12323 - Update Statistics API and SPI based on changes to 2nd level caching changes\n",
      "commitDate": "2018/3/23 上午2:25",
      "commitName": "f432ecea687ce606144c8fca1f4fc7f1937e1c2a",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2018/2/21 下午4:32",
      "commitNameOld": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
      "commitAuthorOld": "Jonathan Bregler",
      "daysBetweenCommits": 29.41,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        cache.remove(source, ck);\n        source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,82 +1,76 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient;\n     if (event.getEntityName() !\u003d null) {\n         isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n     } else {\n         isTransient \u003d !source.contains(event.getObject());\n     }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source, object).process(object, persister);\n         }\n     }\n     if (persister.canWriteToCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n-        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n+        final EntityDataAccess cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n-        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n-\n-            @Override\n-            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n-                cache.unlockItem(session, ck, lock);\n-            }\n-        });\n         cache.remove(source, ck);\n+        source.getActionQueue().registerProcess((success, session) -\u003e cache.unlockItem(session, ck, lock));\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12260: refactor org.hibernate.event.internal.EvictVisitor#evictCollection\n",
      "commitDate": "2018/2/21 下午4:32",
      "commitName": "684cfe6383e100b8eefcc7a5439f0d9ce700ea4b",
      "commitAuthor": "Jonathan Bregler",
      "commitDateOld": "2017/12/13 下午8:19",
      "commitNameOld": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 69.84,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source, object).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,82 +1,82 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient;\n     if (event.getEntityName() !\u003d null) {\n         isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n     } else {\n         isTransient \u003d !source.contains(event.getObject());\n     }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n-            new EvictVisitor(source).process(object, persister);\n+            new EvictVisitor(source, object).process(object, persister);\n         }\n     }\n     if (persister.canWriteToCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n \n             @Override\n             public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                 cache.unlockItem(session, ck, lock);\n             }\n         });\n         cache.remove(source, ck);\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59c3baae3271247bed516fe50952b65be1a27e5b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-12146  - Support enabling caching at any level within a mapped hierarchy\n",
      "commitDate": "2017/12/13 下午8:19",
      "commitName": "59c3baae3271247bed516fe50952b65be1a27e5b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2017/5/3 下午4:54",
      "commitNameOld": "3a813dcbb4b5cf5b13571c63ff0c66b94a83b53c",
      "commitAuthorOld": "Richard Bradley",
      "daysBetweenCommits": 224.14,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.canWriteToCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,82 +1,82 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient;\n     if (event.getEntityName() !\u003d null) {\n         isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n     } else {\n         isTransient \u003d !source.contains(event.getObject());\n     }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n-    if (persister.hasCache()) {\n+    if (persister.canWriteToCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n \n             @Override\n             public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                 cache.unlockItem(session, ck, lock);\n             }\n         });\n         cache.remove(source, ck);\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cc5a13a3f007fad6067945e0bb011d902ba9b6f4": {
      "type": "Ybodychange",
      "commitMessage": "HHH-11217 - SessionImpl.refresh() throws IllegalArgumentException, \u0027not an Entity\u0027 when using custom entity name\n",
      "commitDate": "2016/11/23 下午10:52",
      "commitName": "cc5a13a3f007fad6067945e0bb011d902ba9b6f4",
      "commitAuthor": "Andrea Boriero",
      "commitDateOld": "2016/5/7 上午2:27",
      "commitNameOld": "8c9152040c469a096cd78b18234a66c973d5e07e",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 200.85,
      "commitsBetweenForRepo": 579,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient;\n    if (event.getEntityName() !\u003d null) {\n        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n    } else {\n        isTransient \u003d !source.contains(event.getObject());\n    }\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,77 +1,82 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n-    boolean isTransient \u003d !source.contains(event.getObject());\n+    boolean isTransient;\n+    if (event.getEntityName() !\u003d null) {\n+        isTransient \u003d !source.contains(event.getEntityName(), event.getObject());\n+    } else {\n+        isTransient \u003d !source.contains(event.getObject());\n+    }\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n \n             @Override\n             public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                 cache.unlockItem(session, ck, lock);\n             }\n         });\n         cache.remove(source, ck);\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c9152040c469a096cd78b18234a66c973d5e07e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10664 - Prep 5.2 feature branch\n",
      "commitDate": "2016/5/7 上午2:27",
      "commitName": "8c9152040c469a096cd78b18234a66c973d5e07e",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2016/5/7 上午2:12",
      "commitNameOld": "87e3f0fd28d7229b0a35032292ff32f542c22010",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,77 +1,77 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n         Object previousVersion \u003d null;\n         if (persister.isVersionPropertyGenerated()) {\n             previousVersion \u003d persister.getVersion(object);\n         }\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n         final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n         source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n \n             @Override\n-            public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+            public void doAfterTransactionCompletion(boolean success, SharedSessionContractImplementor session) {\n                 cache.unlockItem(session, ck, lock);\n             }\n         });\n         cache.remove(source, ck);\n     }\n     evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-10649 - When 2LC enabled, flush session and then refresh entity cause dirty read in another session / transaction\n",
      "commitDate": "2016/4/6 下午5:40",
      "commitName": "cbdab9d87f05b4255c7930a32fe995f87f0f3e0b",
      "commitAuthor": "Zhenlei Huang",
      "commitDateOld": "2015/7/2 上午6:14",
      "commitNameOld": "cffe71aeba38977f526b5ce7e870609ea419471c",
      "commitAuthorOld": "Radim Vansa",
      "daysBetweenCommits": 279.48,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        Object previousVersion \u003d null;\n        if (persister.isVersionPropertyGenerated()) {\n            previousVersion \u003d persister.getVersion(object);\n        }\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n\n            @Override\n            public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n                cache.unlockItem(session, ck, lock);\n            }\n        });\n        cache.remove(source, ck);\n    }\n    evictCachedCollections(persister, id, source);\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 56,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,65 +1,77 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n+        Object previousVersion \u003d null;\n+        if (persister.isVersionPropertyGenerated()) {\n+            previousVersion \u003d persister.getVersion(object);\n+        }\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n-        Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n-        cache.evict(ck);\n+        final Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n+        final SoftLock lock \u003d cache.lockItem(source, ck, previousVersion);\n+        source.getActionQueue().registerProcess(new AfterTransactionCompletionProcess() {\n+\n+            @Override\n+            public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {\n+                cache.unlockItem(session, ck, lock);\n+            }\n+        });\n+        cache.remove(source, ck);\n     }\n-    evictCachedCollections(persister, id, source.getFactory());\n+    evictCachedCollections(persister, id, source);\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cffe71aeba38977f526b5ce7e870609ea419471c": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9840 Change all kinds of CacheKey contract to a raw Object\n\n* Replaced all CacheKey with Object\n* Because of statistics, added unwrap operation to all AccessStrategies\n",
      "commitDate": "2015/7/2 上午6:14",
      "commitName": "cffe71aeba38977f526b5ce7e870609ea419471c",
      "commitAuthor": "Radim Vansa",
      "commitDateOld": "2015/7/2 上午3:42",
      "commitNameOld": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
      "commitAuthorOld": "Sanne Grinovero",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        cache.evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 52,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,65 +1,65 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n         final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n-        EntityCacheKey ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n+        Object ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n         cache.evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9840 Allow 2nd level cache implementations to customize the various key implementations\n",
      "commitDate": "2015/7/2 上午3:42",
      "commitName": "16ae00a53a9c58c841eb1dea8eb36354d5f3ff0f",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2015/5/19 下午12:25",
      "commitNameOld": "bd256e4783219f4a765219cf625bb658fcb5fde1",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 43.64,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n        EntityCacheKey ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n        cache.evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 53,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,64 +1,65 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n-        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n-        persister.getCacheAccessStrategy().evict(ck);\n+        final EntityRegionAccessStrategy cache \u003d persister.getCacheAccessStrategy();\n+        EntityCacheKey ck \u003d cache.generateCacheKey(id, persister, source.getFactory(), source.getTenantIdentifier());\n+        cache.evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb15ee548ca1c8fb80f77497271931404f54c19e": {
      "type": "Ybodychange",
      "commitMessage": "HHH-9328 Avoids creation of Cascade objects at all\nby converting all methods of the Cascade class into\nstatic methods.\n",
      "commitDate": "2014/11/28 上午3:43",
      "commitName": "fb15ee548ca1c8fb80f77497271931404f54c19e",
      "commitAuthor": "Andrej Golovnin",
      "commitDateOld": "2013/11/24 上午12:06",
      "commitNameOld": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 369.15,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 69,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,64 +1,64 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n-    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n+    Cascade.cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source, persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n         }\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8741 - More checkstyle cleanups\n",
      "commitDate": "2013/11/24 上午12:06",
      "commitName": "241868e1dd4e9b31a0d03d2e0de2b8684b4f80fc",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2013/10/8 上午3:20",
      "commitNameOld": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 46.87,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections()) {\n            new EvictVisitor(source).process(object, persister);\n        }\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 69,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,63 +1,64 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n-        if (persister.hasCollections())\n+        if (persister.hasCollections()) {\n             new EvictVisitor(source).process(object, persister);\n+        }\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4428464d096c6a1fff3023cb707a2384ab6c0ffb": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8593 EntityManager.refresh should throw EntityNotFoundException if the entity no longer exists in the database\n",
      "commitDate": "2013/10/8 上午3:20",
      "commitName": "4428464d096c6a1fff3023cb707a2384ab6c0ffb",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2013/4/27 上午1:30",
      "commitNameOld": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 164.08,
      "commitsBetweenForRepo": 376,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,63 +1,63 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n-            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n+            throw new UnresolvableObjectException(e.getId(), \"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc02da1c12f6a7487b56e76cf817dc72da8314e6": {
      "type": "Ybodychange",
      "commitMessage": "HHH-8159 - Apply fixups indicated by analysis tools\n",
      "commitDate": "2013/4/27 上午1:30",
      "commitName": "fc02da1c12f6a7487b56e76cf817dc72da8314e6",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012/8/17 上午3:21",
      "commitNameOld": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 252.92,
      "commitsBetweenForRepo": 561,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,63 +1,63 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n-    new Cascade(CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n+    new Cascade(CascadingActions.REFRESH, CascadePoint.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6b5a428b3fed930227ae6a17e3b876c07745d5a3": {
      "type": "Ybodychange",
      "commitMessage": "HHH-7527 - OSGI manifests for hibernate-orm : clean up org.hibernate.engine.spi package duplication between hem and core\n",
      "commitDate": "2012/8/17 上午3:21",
      "commitName": "6b5a428b3fed930227ae6a17e3b876c07745d5a3",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2012/3/26 下午4:17",
      "commitNameOld": "d3b640cb755e20db84d5d528b03e1ae474bb68e7",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 143.46,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,63 +1,63 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled()) {\n             LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n-    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n+    new Cascade(CascadingActions.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "129c0f13482b99e2705f0e234b6bc0572a95c271": {
      "type": "Ybodychange",
      "commitMessage": "HHH-6732 more logging trace statements are missing guards against unneeded string creation\n",
      "commitDate": "2011/10/27 上午6:24",
      "commitName": "129c0f13482b99e2705f0e234b6bc0572a95c271",
      "commitAuthor": "Sanne Grinovero",
      "commitDateOld": "2011/10/24 下午4:26",
      "commitNameOld": "bdba5898c90ef7667e7c5df35e72d2e993e32556",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 2.58,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled()) {\n            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,63 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n-        if (LOG.isTraceEnabled())\n-            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n+        if (LOG.isTraceEnabled()) {\n+            LOG.tracev(\"Refreshing transient {0}\", MessageHelper.infoString(persister, id, source.getFactory()));\n+        }\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n-        if (LOG.isTraceEnabled())\n-            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+        if (LOG.isTraceEnabled()) {\n+            LOG.tracev(\"Refreshing \", MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+        }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
      "commitDate": "2011/5/31 下午2:53",
      "commitName": "625d781af1ec2ae0c03d3db5b4f4832a8c61d8e9",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011/5/31 下午2:53",
      "commitNameOld": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
      "commitAuthorOld": "Strong Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n-        persister \u003d source.getEntityPersister(null, object);\n+        persister \u003d source.getEntityPersister(event.getEntityName(), object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n     source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb5bc1609d28dc740a249e622850a3b3b15b5ace": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4489 need method \"refresh(String entityName, Object obj)\"\n",
      "commitDate": "2011/5/31 下午2:53",
      "commitName": "eb5bc1609d28dc740a249e622850a3b3b15b5ace",
      "commitAuthor": "Strong Liu",
      "commitDateOld": "2011/5/5 上午7:20",
      "commitNameOld": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 26.31,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n-    String previousFetchProfile \u003d source.getFetchProfile();\n-    source.setFetchProfile(\"refresh\");\n+    String previousFetchProfile \u003d source.getLoadQueryInfluencers().getInternalFetchProfile();\n+    source.getLoadQueryInfluencers().setInternalFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n-    source.setFetchProfile(previousFetchProfile);\n+    source.getLoadQueryInfluencers().setInternalFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173": {
      "type": "Yfilerename",
      "commitMessage": "HHH-6198 - Split org.hibernate.event package into api/spi/internal\n",
      "commitDate": "2011/5/5 上午7:20",
      "commitName": "4ee0d4237d9c5cb2d160a29bfc717dd9c2015173",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/5/5 上午6:15",
      "commitNameOld": "fb44ad936d8d54d311ecbaea1633683a8d809d04",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/event/internal/DefaultRefreshEventListener.java"
      }
    },
    "47abaf12fa6be50e95b2a3b8b3d424611c873d66": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5697 - Support for multi-tenancy\n",
      "commitDate": "2011/3/26 下午11:50",
      "commitName": "47abaf12fa6be50e95b2a3b8b3d424611c873d66",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/3/26 下午10:11",
      "commitNameOld": "fe8c7183d172946a03818be2cec1c9c2fc819316",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n-        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n+        final CacheKey ck \u003d source.generateCacheKey(id, persister.getIdentifierType(), persister.getRootEntityName());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe8c7183d172946a03818be2cec1c9c2fc819316": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5697 - Support for multi-tenancy\n",
      "commitDate": "2011/3/26 下午10:11",
      "commitName": "fe8c7183d172946a03818be2cec1c9c2fc819316",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2011/3/9 上午6:19",
      "commitNameOld": "346418c4ef7b9a21dc659af43ff614d5db2343f9",
      "commitAuthorOld": "",
      "daysBetweenCommits": 17.66,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        final EntityKey key \u003d source.generateEntityKey(id, persister);\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 71,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n-        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n+        final EntityKey key \u003d source.generateEntityKey(id, persister);\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled())\n             LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n-        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n+        final EntityKey key \u003d source.generateEntityKey(id, persister);\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d": {
      "type": "Ybodychange",
      "commitMessage": "Give each project a single logger\n",
      "commitDate": "2011/1/19 上午6:00",
      "commitName": "3712e1ad7efccd2ba0c24b3d7d3b23f84d948b9d",
      "commitAuthor": "JPAV",
      "commitDateOld": "2011/1/19 上午5:35",
      "commitNameOld": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthorOld": "JPAV",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.trace(\"Already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 68,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,61 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n-        LOG.alreadyRefreshed();\n+        LOG.trace(\"Already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (LOG.isTraceEnabled())\n-            LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n+            LOG.trace(\"Refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (LOG.isTraceEnabled())\n-            LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+            LOG.trace(\"Refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b1425f3f07021dae556e710b2bdfdc3812661b": {
      "type": "Ybodychange",
      "commitMessage": "Replaced references to slf4j with references to new jboss.logging.Logger implementations and i18n\u0027d where it was clear how to do so.\n",
      "commitDate": "2011/1/19 上午5:35",
      "commitName": "a9b1425f3f07021dae556e710b2bdfdc3812661b",
      "commitAuthor": "JPAV",
      "commitDateOld": "2010/10/12 上午3:41",
      "commitNameOld": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 99.08,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        LOG.alreadyRefreshed();\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (LOG.isTraceEnabled())\n            LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (LOG.isTraceEnabled())\n            LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 72,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,63 +1,61 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n-        log.trace(\"already refreshed\");\n+        LOG.alreadyRefreshed();\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n-        }\n+        if (LOG.isTraceEnabled())\n+            LOG.refreshingTransient(MessageHelper.infoString(persister, id, source.getFactory()));\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n-        }\n+        if (LOG.isTraceEnabled())\n+            LOG.refreshing(MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         if (!persister.isMutable()) {\n             source.setReadOnly(result, true);\n         } else {\n             source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n         }\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814": {
      "type": "Yfilerename",
      "commitMessage": "HHH-5616 - Switch to Gradle for builds\n",
      "commitDate": "2010/10/12 上午3:41",
      "commitName": "34c2839dccef33a8f3abb4eaf3192c1e1d9e1814",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/10/12 上午2:51",
      "commitNameOld": "0bfe7869e41076fd0846ca7592740710876f2427",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "hibernate-core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
      }
    },
    "14bdaec5e75bded557e8410d818a7b77308dd80b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-5207 : Unexpected exception occurs during refresh of a detached immutable entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@19451 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/5/11 上午2:34",
      "commitName": "14bdaec5e75bded557e8410d818a7b77308dd80b",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2010/2/9 上午3:27",
      "commitNameOld": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 90.96,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        if (!persister.isMutable()) {\n            source.setReadOnly(result, true);\n        } else {\n            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n        }\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,59 +1,63 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n-        source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n+        if (!persister.isMutable()) {\n+            source.setReadOnly(result, true);\n+        } else {\n+            source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n+        }\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4704 - Pass session into EntityTuplizer#setIdentifier\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18733 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/2/9 上午3:27",
      "commitName": "839e23458aa0c50e1dc0d8f1a1bed87dbff49f3b",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2010/2/5 下午2:25",
      "commitNameOld": "c18a9306b9f8995331240b66c01fea304e01d06f",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 3.54,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,59 +1,59 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n-        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n+        id \u003d persister.getIdentifier(object, event.getSession());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     if (result !\u003d null) {\n         source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n     }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c18a9306b9f8995331240b66c01fea304e01d06f": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4880 : EntityManager.refresh does not throw EntityNotFoundException for removed entity\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18700 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/2/5 下午2:25",
      "commitName": "c18a9306b9f8995331240b66c01fea304e01d06f",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2010/1/27 下午5:26",
      "commitNameOld": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
      "commitAuthorOld": "Gail Badner",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    if (result !\u003d null) {\n        source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    }\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,57 +1,59 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     boolean isTransient \u003d !source.contains(event.getObject());\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n         if (isTransient) {\n             source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n         }\n         return;\n     }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n-    source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n+    if (result !\u003d null) {\n+        source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n+    }\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b40cfb58dbe4606609c3fa2b1e5e210466c593df": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4781 : Read-only entities changed to modifiable on refresh\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18643 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2010/1/27 下午5:26",
      "commitName": "b40cfb58dbe4606609c3fa2b1e5e210466c593df",
      "commitAuthor": "Gail Badner",
      "commitDateOld": "2009/11/25 上午7:59",
      "commitNameOld": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 63.39,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    boolean isTransient \u003d !source.contains(event.getObject());\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n        if (isTransient) {\n            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n        }\n        return;\n    }\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,51 +1,57 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n-    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n+    boolean isTransient \u003d !source.contains(event.getObject());\n+    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject())) {\n+        if (isTransient) {\n+            source.setReadOnly(event.getObject(), source.isDefaultReadOnly());\n+        }\n         return;\n+    }\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n     Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n+    source.setReadOnly(result, (e \u003d\u003d null ? source.isDefaultReadOnly() : e.isReadOnly()));\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4546 add JPA 2.0 locking.  Introduce LockOptions as the wrapper and session.buildLockRequest() (replaces session.lock()).\n\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18053 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/11/25 上午7:59",
      "commitName": "ceaea5a2a382e57fdded1ad717510d2e3e5bbf49",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2009/11/20 下午10:51",
      "commitNameOld": "35ca4c35635f26b9a86b260ad974ba7da429950b",
      "commitAuthorOld": "Scott Marlow",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,51 +1,51 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n         return;\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n-    Object result \u003d persister.load(id, object, event.getLockRequest(), source);\n+    Object result \u003d persister.load(id, object, event.getLockOptions(), source);\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "35ca4c35635f26b9a86b260ad974ba7da429950b": {
      "type": "Ybodychange",
      "commitMessage": "HHH-4546 add JPA 2.0 locking.  Still need more LockRequest support in AbstractEntityPersister.getAppropriateLoader(), may need to refactor.\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@18016 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2009/11/20 下午10:51",
      "commitName": "35ca4c35635f26b9a86b260ad974ba7da429950b",
      "commitAuthor": "Scott Marlow",
      "commitDateOld": "2008/7/31 上午12:46",
      "commitNameOld": "0d464c2be26dda9d44613dea80f3f32e2e9ef011",
      "commitAuthorOld": "Steve Ebersole",
      "daysBetweenCommits": 477.92,
      "commitsBetweenForRepo": 628,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockRequest(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 70,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "@@ -1,51 +1,51 @@\n public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n     final EventSource source \u003d event.getSession();\n     if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n         return;\n     final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n     if (refreshedAlready.containsKey(object)) {\n         log.trace(\"already refreshed\");\n         return;\n     }\n     final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n     final EntityPersister persister;\n     final Serializable id;\n     if (e \u003d\u003d null) {\n         persister \u003d source.getEntityPersister(null, object);\n         id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n             throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n         }\n     } else {\n         if (log.isTraceEnabled()) {\n             log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n         }\n         if (!e.isExistsInDatabase()) {\n             throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n         }\n         persister \u003d e.getPersister();\n         id \u003d e.getId();\n     }\n     refreshedAlready.put(object, object);\n     new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n     if (e !\u003d null) {\n         EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n         source.getPersistenceContext().removeEntity(key);\n         if (persister.hasCollections())\n             new EvictVisitor(source).process(object, persister);\n     }\n     if (persister.hasCache()) {\n         final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n         persister.getCacheAccessStrategy().evict(ck);\n     }\n     evictCachedCollections(persister, id, source.getFactory());\n     String previousFetchProfile \u003d source.getFetchProfile();\n     source.setFetchProfile(\"refresh\");\n-    Object result \u003d persister.load(id, object, event.getLockMode(), source);\n+    Object result \u003d persister.load(id, object, event.getLockRequest(), source);\n     source.setFetchProfile(previousFetchProfile);\n     UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a797998927e2cbba9ec34ca7dc31b42a192fa2f1": {
      "type": "Yfilerename",
      "commitMessage": "splitting code back out into individual modules (found better way to isolate documentation)\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@12771 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2007/7/17 上午11:15",
      "commitName": "a797998927e2cbba9ec34ca7dc31b42a192fa2f1",
      "commitAuthor": "Steve Ebersole",
      "commitDateOld": "2007/7/16 下午12:18",
      "commitNameOld": "9fda5ffa294695f1a1a2e349232f64d80ef26250",
      "commitAuthorOld": "Diego Plentz",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockMode(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 47,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "code/core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
        "newPath": "core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java"
      }
    },
    "d8d6d82e30960e0c255950eaf875ad48831b12b0": {
      "type": "Yintroduced",
      "commitMessage": "SVN layout migration for core/trunk\n\ngit-svn-id: https://svn.jboss.org/repos/hibernate/core/trunk@11722 1b8cb986-b30d-0410-93ca-fae66ebed9b2\n",
      "commitDate": "2007/6/30 上午3:23",
      "commitName": "d8d6d82e30960e0c255950eaf875ad48831b12b0",
      "commitAuthor": "Steve Ebersole",
      "diff": "@@ -0,0 +1,51 @@\n+public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n+    final EventSource source \u003d event.getSession();\n+    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n+        return;\n+    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n+    if (refreshedAlready.containsKey(object)) {\n+        log.trace(\"already refreshed\");\n+        return;\n+    }\n+    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n+    final EntityPersister persister;\n+    final Serializable id;\n+    if (e \u003d\u003d null) {\n+        persister \u003d source.getEntityPersister(null, object);\n+        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n+        }\n+        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n+        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n+            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n+        }\n+    } else {\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n+        }\n+        if (!e.isExistsInDatabase()) {\n+            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n+        }\n+        persister \u003d e.getPersister();\n+        id \u003d e.getId();\n+    }\n+    refreshedAlready.put(object, object);\n+    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n+    if (e !\u003d null) {\n+        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n+        source.getPersistenceContext().removeEntity(key);\n+        if (persister.hasCollections())\n+            new EvictVisitor(source).process(object, persister);\n+    }\n+    if (persister.hasCache()) {\n+        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n+        persister.getCacheAccessStrategy().evict(ck);\n+    }\n+    evictCachedCollections(persister, id, source.getFactory());\n+    String previousFetchProfile \u003d source.getFetchProfile();\n+    source.setFetchProfile(\"refresh\");\n+    Object result \u003d persister.load(id, object, event.getLockMode(), source);\n+    source.setFetchProfile(previousFetchProfile);\n+    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n+}\n\\ No newline at end of file\n",
      "actualSource": "public void onRefresh(RefreshEvent event, Map refreshedAlready) {\n    final EventSource source \u003d event.getSession();\n    if (source.getPersistenceContext().reassociateIfUninitializedProxy(event.getObject()))\n        return;\n    final Object object \u003d source.getPersistenceContext().unproxyAndReassociate(event.getObject());\n    if (refreshedAlready.containsKey(object)) {\n        log.trace(\"already refreshed\");\n        return;\n    }\n    final EntityEntry e \u003d source.getPersistenceContext().getEntry(object);\n    final EntityPersister persister;\n    final Serializable id;\n    if (e \u003d\u003d null) {\n        persister \u003d source.getEntityPersister(null, object);\n        id \u003d persister.getIdentifier(object, event.getSession().getEntityMode());\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing transient \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        if (source.getPersistenceContext().getEntry(key) !\u003d null) {\n            throw new PersistentObjectException(\"attempted to refresh transient instance when persistent instance was already associated with the Session: \" + MessageHelper.infoString(persister, id, source.getFactory()));\n        }\n    } else {\n        if (log.isTraceEnabled()) {\n            log.trace(\"refreshing \" + MessageHelper.infoString(e.getPersister(), e.getId(), source.getFactory()));\n        }\n        if (!e.isExistsInDatabase()) {\n            throw new HibernateException(\"this instance does not yet exist as a row in the database\");\n        }\n        persister \u003d e.getPersister();\n        id \u003d e.getId();\n    }\n    refreshedAlready.put(object, object);\n    new Cascade(CascadingAction.REFRESH, Cascade.BEFORE_REFRESH, source).cascade(persister, object, refreshedAlready);\n    if (e !\u003d null) {\n        EntityKey key \u003d new EntityKey(id, persister, source.getEntityMode());\n        source.getPersistenceContext().removeEntity(key);\n        if (persister.hasCollections())\n            new EvictVisitor(source).process(object, persister);\n    }\n    if (persister.hasCache()) {\n        final CacheKey ck \u003d new CacheKey(id, persister.getIdentifierType(), persister.getRootEntityName(), source.getEntityMode(), source.getFactory());\n        persister.getCacheAccessStrategy().evict(ck);\n    }\n    evictCachedCollections(persister, id, source.getFactory());\n    String previousFetchProfile \u003d source.getFetchProfile();\n    source.setFetchProfile(\"refresh\");\n    Object result \u003d persister.load(id, object, event.getLockMode(), source);\n    source.setFetchProfile(previousFetchProfile);\n    UnresolvableObjectException.throwIfNull(result, id, persister.getEntityName());\n}",
      "path": "code/core/src/main/java/org/hibernate/event/def/DefaultRefreshEventListener.java",
      "functionStartLine": 47,
      "functionName": "onRefresh",
      "functionAnnotation": "",
      "functionDoc": "Handle the given refresh event.\n\n@param event The refresh event to be handled.\n"
    }
  }
}