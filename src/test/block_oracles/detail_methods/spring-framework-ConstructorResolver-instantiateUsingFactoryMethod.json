{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConstructorResolver.java",
  "functionName": "instantiateUsingFactoryMethod",
  "functionId": "instantiateUsingFactoryMethod___beanName-String(modifiers-final)__mbd-RootBeanDefinition(modifiers-final)__explicitArgs-Object[](annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
  "functionAnnotation": "",
  "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
  "functionStartLine": 360,
  "functionEndLine": 597,
  "numCommitsSeen": 83,
  "timeTaken": 6424,
  "changeHistory": [
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
    "a5cbf5fe246e362c939db006cb44793b22bdc741",
    "b5cedd43eb2b70510729696554bbc1f99003ac10",
    "b94302b5bde7475b9926dacb9fb69f3c8c894444",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "cf479bf893df758b54f1a7117a7eae9a32728ab7",
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
    "b944283354f0f340ffc7ec74b430d79703a4294a",
    "8a83af55b8adf833683b8d9a6924eecf69709a12",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
    "ad62b2afb145499d384cb76c5f254113db99796c",
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
    "603cdea26e0880a46c697194bf5f1cbe60177f16",
    "b093b8495416cd3f05a32add1c671174341bd595",
    "94685481162a93666fc2f39b66223833a6bcb418",
    "9540d2c81b93b9062faf79d4df998525f3dedb7c",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
    "a9da12325995ab03cef56e8f51870081e36a3c9e",
    "9857ba077b16312e78ca6dcf2a219326955daae5",
    "12ce250c6ce911774a7983905fd6e006b5a1eac1",
    "351e72b6e258bd030fb21be253f6348319f81d0e",
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
    "45448463b87629bdd85cb375d3faa391bfaf147f",
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
    "af8af8c633ba016eca671bc9468eba006e8834b1",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
    "3cb073abce659c130abc9adc0662b75380fcc7f3",
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
    "7eabd2da563a4e95928e89f72f7a207804eef0ab",
    "53333c3ed06e465a55592a0f351ffab40110e5b3",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
    "14bd47551900ced88eeacf2a5f63c187ff72028c",
    "4344832a479831e7e67de1a9e81d52d023cd59ac",
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94": "Ybodychange",
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d": "Ybodychange",
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a": "Ybodychange",
    "a5cbf5fe246e362c939db006cb44793b22bdc741": "Ybodychange",
    "b5cedd43eb2b70510729696554bbc1f99003ac10": "Ybodychange",
    "b94302b5bde7475b9926dacb9fb69f3c8c894444": "Ymultichange(Ybodychange,Yannotationchange)",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Ymultichange(Yparametermetachange,Yannotationchange)",
    "cf479bf893df758b54f1a7117a7eae9a32728ab7": "Ybodychange",
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515": "Ybodychange",
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": "Ybodychange",
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": "Ybodychange",
    "b944283354f0f340ffc7ec74b430d79703a4294a": "Ybodychange",
    "8a83af55b8adf833683b8d9a6924eecf69709a12": "Ybodychange",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": "Ybodychange",
    "ad62b2afb145499d384cb76c5f254113db99796c": "Ybodychange",
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0": "Ybodychange",
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b": "Ybodychange",
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73": "Ybodychange",
    "603cdea26e0880a46c697194bf5f1cbe60177f16": "Ybodychange",
    "b093b8495416cd3f05a32add1c671174341bd595": "Ybodychange",
    "94685481162a93666fc2f39b66223833a6bcb418": "Ybodychange",
    "9540d2c81b93b9062faf79d4df998525f3dedb7c": "Ydocchange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1": "Ybodychange",
    "a9da12325995ab03cef56e8f51870081e36a3c9e": "Ybodychange",
    "9857ba077b16312e78ca6dcf2a219326955daae5": "Ybodychange",
    "12ce250c6ce911774a7983905fd6e006b5a1eac1": "Ybodychange",
    "351e72b6e258bd030fb21be253f6348319f81d0e": "Ybodychange",
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5": "Ybodychange",
    "45448463b87629bdd85cb375d3faa391bfaf147f": "Ybodychange",
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839": "Ybodychange",
    "af8af8c633ba016eca671bc9468eba006e8834b1": "Ybodychange",
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": "Ymultichange(Ybodychange,Yparametermetachange)",
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2": "Ybodychange",
    "3cb073abce659c130abc9adc0662b75380fcc7f3": "Ybodychange",
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400": "Ybodychange",
    "7eabd2da563a4e95928e89f72f7a207804eef0ab": "Ybodychange",
    "53333c3ed06e465a55592a0f351ffab40110e5b3": "Ybodychange",
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": "Ybodychange",
    "14bd47551900ced88eeacf2a5f63c187ff72028c": "Ybodychange",
    "4344832a479831e7e67de1a9e81d52d023cd59ac": "Ybodychange",
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe": "Ybodychange",
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1603c4ab2fc49d1bd65f55e35ca899044835ca94": {
      "type": "Ybodychange",
      "commitMessage": "Programmatic ObjectProvider retrieval through BeanFactory API\n\nIntroduces getBeanProvider(Class) and getBeanProvider(ResolvableType), also narrowing getBean(String, Class) and isTypeMatch(String, Class) to a non-null Class argument and enriching NoUniqueBeanDefinitionException with a full ResolvableType. In addition, ObjectProvider supports iterable/stream access for collection-style resolution of multiple matching beans now, and collection injection falls back to an empty collection in a single-constructor case with non-null arguments.\n\nIssue: SPR-17075\nIssue: SPR-11419\nIssue: SPR-15338\n",
      "commitDate": "2018/7/24 上午6:42",
      "commitName": "1603c4ab2fc49d1bd65f55e35ca899044835ca94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/6/28 下午4:28",
      "commitNameOld": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 25.59,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                resolvedValues \u003d new ConstructorArgumentValues();\n                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs \u003d 0;\n            }\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs !\u003d null) {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring, candidates.length \u003d\u003d 1);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues !\u003d null) {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 358,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,166 +1,166 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n-            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             if (mbd.hasConstructorArgumentValues()) {\n                 ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                 resolvedValues \u003d new ConstructorArgumentValues();\n                 minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n             } else {\n                 minNrOfArgs \u003d 0;\n             }\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (explicitArgs !\u003d null) {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 } else {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n-                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n+                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring, candidates.length \u003d\u003d 1);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else if (resolvedValues !\u003d null) {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d": {
      "type": "Ybodychange",
      "commitMessage": "Always use \u0027this.\u0027 when accessing fields\n\nEnsure that `this.` is used consistently when accessing class\nfields.\n\nIssue: SPR-16968\n",
      "commitDate": "2018/6/28 下午4:28",
      "commitName": "0b53c1096af41ed25e8a5f9bd3f194f4d4f8513d",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2018/5/30 上午3:51",
      "commitNameOld": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 29.53,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                resolvedValues \u003d new ConstructorArgumentValues();\n                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs \u003d 0;\n            }\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs !\u003d null) {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues !\u003d null) {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,166 +1,166 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             if (mbd.hasConstructorArgumentValues()) {\n                 ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                 resolvedValues \u003d new ConstructorArgumentValues();\n                 minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n             } else {\n                 minNrOfArgs \u003d 0;\n             }\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (explicitArgs !\u003d null) {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 } else {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else if (resolvedValues !\u003d null) {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n-            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n+            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, fb, factoryMethod, args), this.beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "74fcdea2d96e6c88d232c487e6e2ca6b9978773a": {
      "type": "Ybodychange",
      "commitMessage": "SimpleAliasRegistry logs info message for alias overriding\n\nIssue: SPR-16871\n",
      "commitDate": "2018/5/30 上午3:51",
      "commitName": "74fcdea2d96e6c88d232c487e6e2ca6b9978773a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/2/25 下午8:14",
      "commitNameOld": "c782075a13596a20eb3877cced2421b40246392e",
      "commitAuthorOld": "igor-suhorukov",
      "daysBetweenCommits": 93.32,
      "commitsBetweenForRepo": 476,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                resolvedValues \u003d new ConstructorArgumentValues();\n                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs \u003d 0;\n            }\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs !\u003d null) {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues !\u003d null) {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,166 +1,166 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             if (mbd.hasConstructorArgumentValues()) {\n                 ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                 resolvedValues \u003d new ConstructorArgumentValues();\n                 minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n             } else {\n                 minNrOfArgs \u003d 0;\n             }\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (explicitArgs !\u003d null) {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 } else {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n-                        if (this.beanFactory.logger.isTraceEnabled()) {\n-                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n+                        if (logger.isTraceEnabled()) {\n+                            logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else if (resolvedValues !\u003d null) {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a5cbf5fe246e362c939db006cb44793b22bdc741": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of Collection.toArray with zero-sized array argument\n\nIncludes consistent use of ClassUtils.toClassArray (as non-null variant)\n\nIssue: SPR-16523\n",
      "commitDate": "2018/2/22 下午6:29",
      "commitName": "a5cbf5fe246e362c939db006cb44793b22bdc741",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/11/14 上午4:51",
      "commitNameOld": "b5cedd43eb2b70510729696554bbc1f99003ac10",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 100.57,
      "commitsBetweenForRepo": 420,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                resolvedValues \u003d new ConstructorArgumentValues();\n                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs \u003d 0;\n            }\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs !\u003d null) {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues !\u003d null) {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,166 +1,166 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n-        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n+        Method[] candidates \u003d candidateSet.toArray(new Method[0]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             if (mbd.hasConstructorArgumentValues()) {\n                 ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                 resolvedValues \u003d new ConstructorArgumentValues();\n                 minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n             } else {\n                 minNrOfArgs \u003d 0;\n             }\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (explicitArgs !\u003d null) {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 } else {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else if (resolvedValues !\u003d null) {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b5cedd43eb2b70510729696554bbc1f99003ac10": {
      "type": "Ybodychange",
      "commitMessage": "Consistent and efficient access to BeanDefinition argument values\n\nIssue: SPR-16192\n",
      "commitDate": "2017/11/14 上午4:51",
      "commitName": "b5cedd43eb2b70510729696554bbc1f99003ac10",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/9/28 上午6:31",
      "commitNameOld": "ec345bf162285e397df774bdc2ad756e3aba155a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 46.93,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            if (mbd.hasConstructorArgumentValues()) {\n                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n                resolvedValues \u003d new ConstructorArgumentValues();\n                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n            } else {\n                minNrOfArgs \u003d 0;\n            }\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (explicitArgs !\u003d null) {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                } else {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else if (resolvedValues !\u003d null) {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,162 +1,166 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n-            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n-            resolvedValues \u003d new ConstructorArgumentValues();\n-            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+            if (mbd.hasConstructorArgumentValues()) {\n+                ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n+                resolvedValues \u003d new ConstructorArgumentValues();\n+                minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+            } else {\n+                minNrOfArgs \u003d 0;\n+            }\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n-                if (resolvedValues !\u003d null) {\n+                if (explicitArgs !\u003d null) {\n+                    if (paramTypes.length !\u003d explicitArgs.length) {\n+                        continue;\n+                    }\n+                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n+                } else {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n-                } else {\n-                    if (paramTypes.length !\u003d explicitArgs.length) {\n-                        continue;\n-                    }\n-                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n-            } else {\n+            } else if (resolvedValues !\u003d null) {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b94302b5bde7475b9926dacb9fb69f3c8c894444": {
      "type": "Ymultichange(Ybodychange,Yannotationchange)",
      "commitMessage": "Enforce non-null value from getBean and at injection points\n\nBean-derived null values may still get passed into bean properties and injection points but only if those are declared as non-required. Note that getBean will never return null; a manual bean.equals(null) / \"null\".equals(bean.toString()) check identifies expected null values now.  This will only ever happen with custom FactoryBeans or factory methods returning null - and since all common cases are handled by autowiring or bean property values in bean definitions, there should be no need to ever manually check for such a null value received from getBean.\n\nIssue: SPR-15829\n",
      "commitDate": "2017/8/18 上午6:11",
      "commitName": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Enforce non-null value from getBean and at injection points\n\nBean-derived null values may still get passed into bean properties and injection points but only if those are declared as non-required. Note that getBean will never return null; a manual bean.equals(null) / \"null\".equals(bean.toString()) check identifies expected null values now.  This will only ever happen with custom FactoryBeans or factory methods returning null - and since all common cases are handled by autowiring or bean property values in bean definitions, there should be no need to ever manually check for such a null value received from getBean.\n\nIssue: SPR-15829\n",
          "commitDate": "2017/8/18 上午6:11",
          "commitName": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/7 下午8:19",
          "commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 71.41,
          "commitsBetweenForRepo": 370,
          "commitsBetweenForFile": 1,
          "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 351,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,166 +1,162 @@\n-@Nullable\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n-        if (beanInstance \u003d\u003d null) {\n-            return null;\n-        }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Enforce non-null value from getBean and at injection points\n\nBean-derived null values may still get passed into bean properties and injection points but only if those are declared as non-required. Note that getBean will never return null; a manual bean.equals(null) / \"null\".equals(bean.toString()) check identifies expected null values now.  This will only ever happen with custom FactoryBeans or factory methods returning null - and since all common cases are handled by autowiring or bean property values in bean definitions, there should be no need to ever manually check for such a null value received from getBean.\n\nIssue: SPR-15829\n",
          "commitDate": "2017/8/18 上午6:11",
          "commitName": "b94302b5bde7475b9926dacb9fb69f3c8c894444",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/7 下午8:19",
          "commitNameOld": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 71.41,
          "commitsBetweenForRepo": 370,
          "commitsBetweenForFile": 1,
          "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 351,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,166 +1,162 @@\n-@Nullable\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n-        if (beanInstance \u003d\u003d null) {\n-            return null;\n-        }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@Nullable",
            "newValue": ""
          }
        }
      ]
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/7 下午8:19",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/6/1 上午3:42",
      "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.69,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\npublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,175 +1,166 @@\n @Nullable\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n-        if (factoryBean \u003d\u003d null) {\n-            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n-        }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n-            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n-\n-                @Override\n-                public Object run() {\n-                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n-                }\n-            }, beanFactory.getAccessControlContext());\n+            beanInstance \u003d AccessController.doPrivileged((PrivilegedAction\u003cObject\u003e) () -\u003e beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args), beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Ymultichange(Yparametermetachange,Yannotationchange)",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/5/27 下午2:57",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "subchanges": [
        {
          "type": "Yparametermetachange",
          "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/5/27 下午2:57",
          "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2016/11/8 上午1:00",
          "commitNameOld": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 200.58,
          "commitsBetweenForRepo": 1145,
          "commitsBetweenForFile": 1,
          "actualSource": "@Nullable\npublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 358,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "@Nullable",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,174 +1,175 @@\n-public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+@Nullable\n+public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]",
            "newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](annotations-@Nullable__modifiers-final)]"
          }
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/5/27 下午2:57",
          "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
          "commitAuthor": "Sebastien Deleuze",
          "commitDateOld": "2016/11/8 上午1:00",
          "commitNameOld": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 200.58,
          "commitsBetweenForRepo": 1145,
          "commitsBetweenForFile": 1,
          "actualSource": "@Nullable\npublic BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 358,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "@Nullable",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,174 +1,175 @@\n-public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n+@Nullable\n+public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, @Nullable final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@Nullable"
          }
        }
      ]
    },
    "cf479bf893df758b54f1a7117a7eae9a32728ab7": {
      "type": "Ybodychange",
      "commitMessage": "Consistent throwing of BeanCreationExceptions (and reflection exceptions)\n\nIssue: SPR-14883\n(cherry picked from commit b42d731)\n",
      "commitDate": "2016/11/8 上午1:00",
      "commitName": "cf479bf893df758b54f1a7117a7eae9a32728ab7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/24 下午9:34",
      "commitNameOld": "ed49ce838ee00df24e6aa89892ee168761c206d2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 106.14,
      "commitsBetweenForRepo": 539,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new ImplicitlyAppearedSingletonException();\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n-            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n+            throw new ImplicitlyAppearedSingletonException();\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e3f2ebf6690b72b7a8af852a35df6ff6229515": {
      "type": "Ybodychange",
      "commitMessage": "MethodParameter supports Java 8 Executable/Parameter and validates parameter indexes\n\nAlso, equals insists on the same class now, differentiating from SynthesizingMethodParameter.\n\nIssue: SPR-14055\nIssue: SPR-13456\nIssue: SPR-14438\n",
      "commitDate": "2016/7/7 上午6:37",
      "commitName": "39e3f2ebf6690b72b7a8af852a35df6ff6229515",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/5 下午11:00",
      "commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 1.32,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n-                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n+                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterCount() \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4": {
      "type": "Ybodychange",
      "commitMessage": "Explicit type can be replaced by \u003c\u003e\n\nIssue: SPR-13188\n",
      "commitDate": "2016/7/5 下午11:00",
      "commitName": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthor": "Stephane Nicoll",
      "commitDateOld": "2016/4/7 下午8:18",
      "commitNameOld": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 89.11,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003c\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n-        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n+        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003c\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n-                            causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n+                            causes \u003d new LinkedList\u003c\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n-                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n+                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003c\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n-            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n+            List\u003cString\u003e argTypes \u003d new ArrayList\u003c\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n-                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n+                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003c\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5c1d3fca15d9c020a07a0130a3992926d7087f1a": {
      "type": "Ybodychange",
      "commitMessage": "BeanFactory does not unwrap java.util.Optional for top-level bean\n\nIssue: SPR-14121\n",
      "commitDate": "2016/4/7 下午8:18",
      "commitName": "5c1d3fca15d9c020a07a0130a3992926d7087f1a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/3/19 上午1:51",
      "commitNameOld": "431ca9314af6929a53b177640522323602e6d224",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 19.77,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setBeanInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 356,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n-        bw.setWrappedInstance(beanInstance);\n+        bw.setBeanInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b944283354f0f340ffc7ec74b430d79703a4294a": {
      "type": "Ybodychange",
      "commitMessage": "ConstructorResolver exposes parameter signature from user-declared class (in case of a CGLIB-generated subclass)\n\nIssue: SPR-14015\n",
      "commitDate": "2016/3/11 下午7:52",
      "commitName": "b944283354f0f340ffc7ec74b430d79703a4294a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/2/26 下午7:31",
      "commitNameOld": "8a83af55b8adf833683b8d9a6924eecf69709a12",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 14.02,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (Method candidate : candidates) {\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,175 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n-        for (int i \u003d 0; i \u003c candidates.length; i++) {\n-            Method candidate \u003d candidates[i];\n+        for (Method candidate : candidates) {\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (causes \u003d\u003d null) {\n                             causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                         }\n                         causes.add(ex);\n                         continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             if (causes !\u003d null) {\n                 UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                 for (Exception cause : causes) {\n                     this.beanFactory.onSuppressedException(cause);\n                 }\n                 throw ex;\n             }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8a83af55b8adf833683b8d9a6924eecf69709a12": {
      "type": "Ybodychange",
      "commitMessage": "Consistent resolution of factory method exceptions\n\nIssue: SPR-13985\n",
      "commitDate": "2016/2/26 下午7:31",
      "commitName": "8a83af55b8adf833683b8d9a6924eecf69709a12",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/2/26 上午4:36",
      "commitNameOld": "b6dd8a923365f021af636705e652a725e1cf0ebe",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.62,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (causes \u003d\u003d null) {\n                            causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                        }\n                        causes.add(ex);\n                        continue;\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            if (causes !\u003d null) {\n                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n                for (Exception cause : causes) {\n                    this.beanFactory.onSuppressedException(cause);\n                }\n                throw ex;\n            }\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,177 +1,175 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n-        List\u003cException\u003e causes \u003d null;\n+        LinkedList\u003cUnsatisfiedDependencyException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n-                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n-                            if (causes !\u003d null) {\n-                                for (Exception cause : causes) {\n-                                    this.beanFactory.onSuppressedException(cause);\n-                                }\n-                            }\n-                            throw ex;\n-                        } else {\n-                            if (causes \u003d\u003d null) {\n-                                causes \u003d new LinkedList\u003cException\u003e();\n-                            }\n-                            causes.add(ex);\n-                            continue;\n+                        if (causes \u003d\u003d null) {\n+                            causes \u003d new LinkedList\u003cUnsatisfiedDependencyException\u003e();\n                         }\n+                        causes.add(ex);\n+                        continue;\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n+            if (causes !\u003d null) {\n+                UnsatisfiedDependencyException ex \u003d causes.removeLast();\n+                for (Exception cause : causes) {\n+                    this.beanFactory.onSuppressedException(cause);\n+                }\n+                throw ex;\n+            }\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
      "type": "Ybodychange",
      "commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
      "commitDate": "2015/5/20 下午8:34",
      "commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/12/24 上午12:35",
      "commitNameOld": "d55af2b445cd3b1c08a7038de4db8e903c36083f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 147.83,
      "commitsBetweenForRepo": 632,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 352,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,177 +1,177 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n-        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n+        } else if (void.class \u003d\u003d factoryMethodToUse.getReturnType()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad62b2afb145499d384cb76c5f254113db99796c": {
      "type": "Ybodychange",
      "commitMessage": "Consistent throwing of BeanInstantiationException for factory methods, including a hint about circular references\n\nIssue: SPR-12317\n",
      "commitDate": "2014/10/22 上午3:40",
      "commitName": "ad62b2afb145499d384cb76c5f254113db99796c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/9/3 上午4:13",
      "commitNameOld": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 48.98,
      "commitsBetweenForRepo": 255,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 355,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,177 +1,177 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n             throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n-            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+            beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n-        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean instantiation via factory method failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c9274e01743a87d7fb8519f7772c1b1677ecbe0": {
      "type": "Ybodychange",
      "commitMessage": "LazyInitTargetSource works for @Bean targets as well\n\nIssue: SPR-10508\nIssue: SPR-8080\n",
      "commitDate": "2014/9/3 上午4:13",
      "commitName": "8c9274e01743a87d7fb8519f7772c1b1677ecbe0",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/7/5 上午4:30",
      "commitNameOld": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 59.99,
      "commitsBetweenForRepo": 375,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,177 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n+        if (mbd.isSingleton() \u0026\u0026 this.beanFactory.containsSingleton(beanName)) {\n+            throw new IllegalStateException(\"About-to-be-created singleton instance implicitly appeared \" + \"through the creation of the factory bean that its bean definition points to\");\n+        }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b": {
      "type": "Ybodychange",
      "commitMessage": "ConstructorResolver\u0027s exception message on null factory-bean hints at potential BeanPostProcessor involvement\n\nIssue: SPR-11951\n",
      "commitDate": "2014/7/5 上午4:30",
      "commitName": "6c41cc354c1e6575ff5f56147c3fcbe5b52c2e9b",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/3/5 下午11:16",
      "commitNameOld": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 121.22,
      "commitsBetweenForRepo": 647,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n-            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 (or a BeanPostProcessor involved) returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n             if (explicitArgs !\u003d null) {\n                 for (Object arg : explicitArgs) {\n                     argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                 }\n             } else {\n                 Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                 valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                 valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                 for (ValueHolder value : valueHolders) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n             }\n             String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ad317774fb8e0b1f70e0135e5786c94c2521fb73": {
      "type": "Ybodychange",
      "commitMessage": "instantiateUsingFactoryMethod avoids NPE and reports argument types in case of explicitArgs and resolved generic arguments as well\n\nIssue: SPR-11517\n",
      "commitDate": "2014/3/5 下午11:16",
      "commitName": "ad317774fb8e0b1f70e0135e5786c94c2521fb73",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/2/13 上午8:08",
      "commitNameOld": "ce39146be8889409898264b8a9389d3d1f0d4258",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 20.63,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n            if (explicitArgs !\u003d null) {\n                for (Object arg : explicitArgs) {\n                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n                }\n            } else {\n                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n                for (ValueHolder value : valueHolders) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                    argTypes.add(argType);\n                }\n            }\n            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 354,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,169 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n-            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n-            String argDesc \u003d \"\";\n-            if (hasArgs) {\n-                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n-                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n+            List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e(minNrOfArgs);\n+            if (explicitArgs !\u003d null) {\n+                for (Object arg : explicitArgs) {\n+                    argTypes.add(arg !\u003d null ? arg.getClass().getSimpleName() : \"null\");\n+                }\n+            } else {\n+                Set\u003cValueHolder\u003e valueHolders \u003d new LinkedHashSet\u003cValueHolder\u003e(resolvedValues.getArgumentCount());\n+                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());\n+                valueHolders.addAll(resolvedValues.getGenericArgumentValues());\n+                for (ValueHolder value : valueHolders) {\n+                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : (value.getValue() !\u003d null ? value.getValue().getClass().getSimpleName() : \"null\"));\n                     argTypes.add(argType);\n                 }\n-                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n-            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n+            String argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (minNrOfArgs \u003e 0 ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "603cdea26e0880a46c697194bf5f1cbe60177f16": {
      "type": "Ybodychange",
      "commitMessage": "resolveFactoryMethodIfPossible considers nonPublicAccessAllowed and SecurityManager\n\nIssue: SPR-11422\n",
      "commitDate": "2014/2/13 上午6:48",
      "commitName": "603cdea26e0880a46c697194bf5f1cbe60177f16",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/11/26 上午4:52",
      "commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 79.08,
      "commitsBetweenForRepo": 450,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 357,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,181 +1,169 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-        Method[] rawCandidates;\n-        final Class\u003c?\u003e factoryClazz \u003d factoryClass;\n-        if (System.getSecurityManager() !\u003d null) {\n-            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n-\n-                @Override\n-                public Method[] run() {\n-                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-                }\n-            });\n-        } else {\n-            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n-        }\n+        Method[] rawCandidates \u003d getCandidateMethods(factoryClass, mbd);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n-            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n+            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b093b8495416cd3f05a32add1c671174341bd595": {
      "type": "Ybodychange",
      "commitMessage": "Use non-lenient constructor resolution mode for @Bean methods\n\nSince @Bean methods are never used with externally specified constructor argument values but rather just with autowiring, the non-lenient constructor resolution mode is appropriate in case of an overloaded @Bean method, not performing any type difference weight checks. This change includes a refinement of Spring\u0027s existing non-lenient constructor resolution (which needs to be explicitly turned on and is therefore not well tested), narrowing the conditions for the ambiguity check (only in case of the same number of arguments and not for overridden methods).\n\nIssue: SPR-10988\n",
      "commitDate": "2013/11/4 上午7:19",
      "commitName": "b093b8495416cd3f05a32add1c671174341bd595",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/5/14 上午6:04",
      "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthorOld": "Rob Winch",
      "daysBetweenCommits": 174.05,
      "commitsBetweenForRepo": 656,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class\u003c?\u003e factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class\u003c?\u003e factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                @Override\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,181 +1,181 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n-    Class factoryClass;\n+    Class\u003c?\u003e factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n-        final Class factoryClazz \u003d factoryClass;\n+        final Class\u003c?\u003e factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 @Override\n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n-            Class[] paramTypes \u003d candidate.getParameterTypes();\n+            Class\u003c?\u003e[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n-                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n+                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution() \u0026\u0026 paramTypes.length \u003d\u003d factoryMethodToUse.getParameterTypes().length \u0026\u0026 !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n-        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n+        } else if (ambiguousFactoryMethods !\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "94685481162a93666fc2f39b66223833a6bcb418": {
      "type": "Ybodychange",
      "commitMessage": "Add @Override to remaining source files\n\nIssue: SPR-10130\n",
      "commitDate": "2013/5/14 上午6:04",
      "commitName": "94685481162a93666fc2f39b66223833a6bcb418",
      "commitAuthor": "Rob Winch",
      "commitDateOld": "2013/2/5 上午2:35",
      "commitNameOld": "f464a45ba481ff3e960ad3dd8b5edd4464a46289",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 98.15,
      "commitsBetweenForRepo": 366,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                @Override\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                @Override\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,179 +1,181 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n+                @Override\n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n+                @Override\n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9540d2c81b93b9062faf79d4df998525f3dedb7c": {
      "type": "Ydocchange",
      "commitMessage": "Replace \u003ccode\u003e with {@code} throughout Javadoc\n\nIssue: SPR-10128\n",
      "commitDate": "2012/12/29 上午5:36",
      "commitName": "9540d2c81b93b9062faf79d4df998525f3dedb7c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/12/29 上午3:49",
      "commitNameOld": "1762157ad1a89ff8778387a2c72a8e36ff341a40",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
        "newValue": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or {@code null} if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n"
      }
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java"
      }
    },
    "061063257ab8e16786d04eaddb5b5aba61dcd7f1": {
      "type": "Ybodychange",
      "commitMessage": "optimized @Bean error messages (SPR-7628, SPR-7629)\n",
      "commitDate": "2010/10/11 上午2:31",
      "commitName": "061063257ab8e16786d04eaddb5b5aba61dcd7f1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/8/19 下午5:30",
      "commitNameOld": "a9da12325995ab03cef56e8f51870081e36a3c9e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 52.38,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,179 +1,179 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n-                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n+                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 argsHolderToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n-        if (explicitArgs \u003d\u003d null) {\n+        if (explicitArgs \u003d\u003d null \u0026\u0026 argsHolderToUse !\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9da12325995ab03cef56e8f51870081e36a3c9e": {
      "type": "Ybodychange",
      "commitMessage": "temporarily disabled constructor argument caching for converted values (SPR-7423)\n",
      "commitDate": "2010/8/19 下午5:30",
      "commitName": "a9da12325995ab03cef56e8f51870081e36a3c9e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/8/18 下午5:08",
      "commitNameOld": "9857ba077b16312e78ca6dcf2a219326955daae5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 339,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,179 +1,179 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         Object[] argsToResolve \u003d null;\n         synchronized (mbd.constructorArgumentLock) {\n             factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n             if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                 argsToUse \u003d mbd.resolvedConstructorArguments;\n                 if (argsToUse \u003d\u003d null) {\n                     argsToResolve \u003d mbd.preparedConstructorArguments;\n                 }\n             }\n         }\n         if (argsToResolve !\u003d null) {\n             argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n-            boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n+            boolean hasArgs \u003d (resolvedValues.getArgumentCount() \u003e 0);\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n-                    String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+                    String argType \u003d (value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName());\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9857ba077b16312e78ca6dcf2a219326955daae5": {
      "type": "Ybodychange",
      "commitMessage": "revised constructor argument caching for highly concurrent creation scenarios (follow-up to SPR-7423)\n",
      "commitDate": "2010/8/18 下午5:08",
      "commitName": "9857ba077b16312e78ca6dcf2a219326955daae5",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/8/12 上午3:24",
      "commitNameOld": "8a23ce917afb6cd19996508521a27f8ea97db29d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        Object[] argsToResolve \u003d null;\n        synchronized (mbd.constructorArgumentLock) {\n            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n                argsToUse \u003d mbd.resolvedConstructorArguments;\n                if (argsToUse \u003d\u003d null) {\n                    argsToResolve \u003d mbd.preparedConstructorArguments;\n                }\n            }\n        }\n        if (argsToResolve !\u003d null) {\n            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 340,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,174 +1,179 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n-        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n-        if (factoryMethodToUse !\u003d null) {\n-            argsToUse \u003d mbd.resolvedConstructorArguments;\n-            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n-                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n+        Object[] argsToResolve \u003d null;\n+        synchronized (mbd.constructorArgumentLock) {\n+            factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n+            if (factoryMethodToUse !\u003d null \u0026\u0026 mbd.constructorArgumentsResolved) {\n+                argsToUse \u003d mbd.resolvedConstructorArguments;\n+                if (argsToUse \u003d\u003d null) {\n+                    argsToResolve \u003d mbd.preparedConstructorArguments;\n+                }\n             }\n         }\n+        if (argsToResolve !\u003d null) {\n+            argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);\n+        }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsHolderToUse \u003d argsHolder;\n                     argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n-            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n-            argsHolderToUse.storeCache(mbd);\n+            argsHolderToUse.storeCache(mbd, factoryMethodToUse);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "12ce250c6ce911774a7983905fd6e006b5a1eac1": {
      "type": "Ybodychange",
      "commitMessage": "fixed constructor argument caching for prototypes with multiple constructor matches (SPR-7084)\n",
      "commitDate": "2010/4/14 下午8:11",
      "commitName": "12ce250c6ce911774a7983905fd6e006b5a1eac1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/3/26 下午8:05",
      "commitNameOld": "351e72b6e258bd030fb21be253f6348319f81d0e",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 19.0,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    ArgumentsHolder argsHolderToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder argsHolder;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsHolderToUse \u003d argsHolder;\n                    argsToUse \u003d argsHolder.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n            argsHolderToUse.storeCache(mbd);\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 335,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,171 +1,174 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n+    ArgumentsHolder argsHolderToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n-                ArgumentsHolder args;\n+                ArgumentsHolder argsHolder;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n-                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n+                        argsHolder \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n-                    args \u003d new ArgumentsHolder(explicitArgs);\n+                    argsHolder \u003d new ArgumentsHolder(explicitArgs);\n                 }\n-                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n+                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n-                    argsToUse \u003d args.arguments;\n+                    argsHolderToUse \u003d argsHolder;\n+                    argsToUse \u003d argsHolder.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n             String argDesc \u003d \"\";\n             if (hasArgs) {\n                 List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                 for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                     String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                     argTypes.add(argType);\n                 }\n                 argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n             }\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n+            argsHolderToUse.storeCache(mbd);\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "351e72b6e258bd030fb21be253f6348319f81d0e": {
      "type": "Ybodychange",
      "commitMessage": "incorrectly invoked factory methods now result in exceptions with more descriptive messages (SPR-5475)\n",
      "commitDate": "2010/3/26 下午8:05",
      "commitName": "351e72b6e258bd030fb21be253f6348319f81d0e",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2010/2/15 下午9:01",
      "commitNameOld": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 38.96,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n            String argDesc \u003d \"\";\n            if (hasArgs) {\n                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n                    String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n                    argTypes.add(argType);\n                }\n                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n            }\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 334,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,161 +1,171 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n-            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" + \"Check that a method of the specified name exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n+            boolean hasArgs \u003d resolvedValues.getArgumentCount() \u003e 0;\n+            String argDesc \u003d \"\";\n+            if (hasArgs) {\n+                List\u003cString\u003e argTypes \u003d new ArrayList\u003cString\u003e();\n+                for (ValueHolder value : resolvedValues.getIndexedArgumentValues().values()) {\n+                    String argType \u003d value.getType() !\u003d null ? ClassUtils.getShortName(value.getType()) : value.getValue().getClass().getSimpleName();\n+                    argTypes.add(argType);\n+                }\n+                argDesc \u003d StringUtils.collectionToCommaDelimitedString(argTypes);\n+            }\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"(\" + argDesc + \")\u0027. \" + \"Check that a method with the specified name \" + (hasArgs ? \"and arguments \" : \"\") + \"exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "18bd4a83375a1815dbf83aca384cf7f5c27e93f5": {
      "type": "Ybodychange",
      "commitMessage": "improved \"no matching factory method found\" exception message (SPR-6837)\n",
      "commitDate": "2010/2/15 下午9:01",
      "commitName": "18bd4a83375a1815dbf83aca384cf7f5c27e93f5",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/1/20 下午5:29",
      "commitNameOld": "45448463b87629bdd85cb375d3faa391bfaf147f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 26.15,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" + \"Check that a method of the specified name exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 330,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,161 +1,161 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n-            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027. \" + \"Check that a method of the specified name exists and that it is \" + (isStatic ? \"static\" : \"non-static\") + \".\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45448463b87629bdd85cb375d3faa391bfaf147f": {
      "type": "Ybodychange",
      "commitMessage": "collect exceptions across all constructors that have been tried (SPR-6720)\n",
      "commitDate": "2010/1/20 下午5:29",
      "commitName": "45448463b87629bdd85cb375d3faa391bfaf147f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/27 下午6:45",
      "commitNameOld": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 145.95,
      "commitsBetweenForRepo": 967,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 330,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,161 +1,161 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-        Method[] rawCandidates \u003d null;\n+        Method[] rawCandidates;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "904c2358cdfd9cd8337da0950b8c8d6fc7099839": {
      "type": "Ybodychange",
      "commitMessage": "adapted to changes in non-lenient mode\n",
      "commitDate": "2009/8/27 下午6:45",
      "commitName": "904c2358cdfd9cd8337da0950b8c8d6fc7099839",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/27 下午5:47",
      "commitNameOld": "015284af7cf8eff979cd0c5e5ad3d189915e98a9",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d null;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 332,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,161 +1,161 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d null;\n         final Class factoryClazz \u003d factoryClass;\n         if (System.getSecurityManager() !\u003d null) {\n             rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n \n                 public Method[] run() {\n                     return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                 }\n             });\n         } else {\n             rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n         }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n-        Object beanInstance \u003d null;\n+        Object beanInstance;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "af8af8c633ba016eca671bc9468eba006e8834b1": {
      "type": "Ybodychange",
      "commitMessage": "+ added fine grained privileged blocks to preserve the caller security stack when invoking the callee\n",
      "commitDate": "2009/8/7 上午6:31",
      "commitName": "af8af8c633ba016eca671bc9468eba006e8834b1",
      "commitAuthor": "Costin Leau",
      "commitDateOld": "2009/8/7 上午3:08",
      "commitNameOld": "81eb11486dad59e4a42566f9f7760d85396790b0",
      "commitAuthorOld": "Costin Leau",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d null;\n        final Class factoryClazz \u003d factoryClass;\n        if (System.getSecurityManager() !\u003d null) {\n            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n\n                public Method[] run() {\n                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n                }\n            });\n        } else {\n            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n        }\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d null;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 334,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,150 +1,161 @@\n public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n+        Method[] rawCandidates \u003d null;\n+        final Class factoryClazz \u003d factoryClass;\n+        if (System.getSecurityManager() !\u003d null) {\n+            rawCandidates \u003d AccessController.doPrivileged(new PrivilegedAction\u003cMethod[]\u003e() {\n+\n+                public Method[] run() {\n+                    return (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+                }\n+            });\n+        } else {\n+            rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClazz) : factoryClazz.getMethods());\n+        }\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d null;\n         if (System.getSecurityManager() !\u003d null) {\n             final Object fb \u003d factoryBean;\n             final Method factoryMethod \u003d factoryMethodToUse;\n             final Object[] args \u003d argsToUse;\n             beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n \n                 public Object run() {\n                     return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                 }\n             }, beanFactory.getAccessControlContext());\n         } else {\n             beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d5d3104b7b13ce249bf9c877f7160cd2137ec209": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
      "commitDate": "2009/8/7 上午12:34",
      "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
      "commitAuthor": "Costin Leau",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
          "commitDate": "2009/8/7 上午12:34",
          "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
          "commitAuthor": "Costin Leau",
          "commitDateOld": "2009/7/30 上午12:43",
          "commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 7.99,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d null;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 334,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,137 +1,150 @@\n-public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n-        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        Object beanInstance \u003d null;\n+        if (System.getSecurityManager() !\u003d null) {\n+            final Object fb \u003d factoryBean;\n+            final Method factoryMethod \u003d factoryMethodToUse;\n+            final Object[] args \u003d argsToUse;\n+            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\n+                public Object run() {\n+                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n+                }\n+            }, beanFactory.getAccessControlContext());\n+        } else {\n+            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "+ interaction with user code uses now dedicated privileged when running under a security manager\n",
          "commitDate": "2009/8/7 上午12:34",
          "commitName": "d5d3104b7b13ce249bf9c877f7160cd2137ec209",
          "commitAuthor": "Costin Leau",
          "commitDateOld": "2009/7/30 上午12:43",
          "commitNameOld": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 7.99,
          "commitsBetweenForRepo": 47,
          "commitsBetweenForFile": 1,
          "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d null;\n        if (System.getSecurityManager() !\u003d null) {\n            final Object fb \u003d factoryBean;\n            final Method factoryMethod \u003d factoryMethodToUse;\n            final Object[] args \u003d argsToUse;\n            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n\n                public Object run() {\n                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n                }\n            }, beanFactory.getAccessControlContext());\n        } else {\n            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        }\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
          "functionStartLine": 334,
          "functionName": "instantiateUsingFactoryMethod",
          "functionAnnotation": "",
          "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
          "diff": "@@ -1,137 +1,150 @@\n-public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+public BeanWrapper instantiateUsingFactoryMethod(final String beanName, final RootBeanDefinition mbd, final Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                     ambiguousFactoryMethods \u003d null;\n                 } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                     if (ambiguousFactoryMethods \u003d\u003d null) {\n                         ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                         ambiguousFactoryMethods.add(factoryMethodToUse);\n                     }\n                     ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n-        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        Object beanInstance \u003d null;\n+        if (System.getSecurityManager() !\u003d null) {\n+            final Object fb \u003d factoryBean;\n+            final Method factoryMethod \u003d factoryMethodToUse;\n+            final Object[] args \u003d argsToUse;\n+            beanInstance \u003d AccessController.doPrivileged(new PrivilegedAction\u003cObject\u003e() {\n+\n+                public Object run() {\n+                    return beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, fb, factoryMethod, args);\n+                }\n+            }, beanFactory.getAccessControlContext());\n+        } else {\n+            beanInstance \u003d beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        }\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[beanName-String, mbd-RootBeanDefinition, explicitArgs-Object[]]",
            "newValue": "[beanName-String(modifiers-final), mbd-RootBeanDefinition(modifiers-final), explicitArgs-Object[](modifiers-final)]"
          }
        }
      ]
    },
    "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2": {
      "type": "Ybodychange",
      "commitMessage": "fixed constructor resolution algorithm to trigger ambiguity exception as late as possible\n",
      "commitDate": "2009/7/30 上午12:43",
      "commitName": "17dfc8b0fcf3e2a02ab0db48af1d309981bbe6c2",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/7/28 下午10:43",
      "commitNameOld": "3cb073abce659c130abc9adc0662b75380fcc7f3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        ConstructorArgumentValues resolvedValues \u003d null;\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                    ambiguousFactoryMethods \u003d null;\n                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n                    if (ambiguousFactoryMethods \u003d\u003d null) {\n                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n                        ambiguousFactoryMethods.add(factoryMethodToUse);\n                    }\n                    ambiguousFactoryMethods.add(candidate);\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 314,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,130 +1,137 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n+        ConstructorArgumentValues resolvedValues \u003d null;\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n-        ConstructorArgumentValues resolvedValues \u003d null;\n+        Set\u003cMethod\u003e ambiguousFactoryMethods \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n-                } else if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n-                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n+                    ambiguousFactoryMethods \u003d null;\n+                } else if (factoryMethodToUse !\u003d null \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight) {\n+                    if (ambiguousFactoryMethods \u003d\u003d null) {\n+                        ambiguousFactoryMethods \u003d new LinkedHashSet\u003cMethod\u003e();\n+                        ambiguousFactoryMethods.add(factoryMethodToUse);\n+                    }\n+                    ambiguousFactoryMethods.add(candidate);\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n-        }\n-        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n+        } else if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n+        } else if (ambiguousFactoryMethods !\u003d null \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): \" + ambiguousFactoryMethods);\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3cb073abce659c130abc9adc0662b75380fcc7f3": {
      "type": "Ybodychange",
      "commitMessage": "revised non-lenient resolution\n",
      "commitDate": "2009/7/28 下午10:43",
      "commitName": "3cb073abce659c130abc9adc0662b75380fcc7f3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/7/27 下午10:09",
      "commitNameOld": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                } else if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 305,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,130 +1,130 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n-                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n+                int typeDiffWeight \u003d (mbd.isLenientConstructorResolution() ? args.getTypeDifferenceWeight(paramTypes) : args.getAssignabilityWeight(paramTypes));\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 } else if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n                     throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1eabe2b4416ee7619bd863fcdc1e6f6ada766400": {
      "type": "Ybodychange",
      "commitMessage": "lenientConstructorResolution flag applies to factory methods as well\n",
      "commitDate": "2009/7/27 下午10:09",
      "commitName": "1eabe2b4416ee7619bd863fcdc1e6f6ada766400",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/7/17 上午1:22",
      "commitNameOld": "8e2797153bf3d4eb7fbc679907dc06700c0595f4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                } else if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 304,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,128 +1,130 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n+                } else if (typeDiffWeight \u003c Integer.MAX_VALUE \u0026\u0026 typeDiffWeight \u003d\u003d minTypeDiffWeight \u0026\u0026 !mbd.isLenientConstructorResolution()) {\n+                    throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Ambiguous factory method matches found in bean \u0027\" + beanName + \"\u0027 \" + \"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)\");\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7eabd2da563a4e95928e89f72f7a207804eef0ab": {
      "type": "Ybodychange",
      "commitMessage": "introduced \"nonPublicAccessAllowed\" flag (SPR-5882)\n",
      "commitDate": "2009/7/16 下午11:52",
      "commitName": "7eabd2da563a4e95928e89f72f7a207804eef0ab",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/7/16 下午9:27",
      "commitNameOld": "a9254b34d19237f5fde7ceedec2126b08cf48e4d",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 304,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,128 +1,128 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n-        Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+        Method[] rawCandidates \u003d (mbd.isNonPublicAccessAllowed() ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods());\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         String[] paramNames \u003d null;\n                         ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                         if (pnd !\u003d null) {\n                             paramNames \u003d pnd.getParameterNames(candidate);\n                         }\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "53333c3ed06e465a55592a0f351ffab40110e5b3": {
      "type": "Ybodychange",
      "commitMessage": "XML constructor-arg element allows for specifying a constructor argument by name now, with target argument names read from the class file via ASM or from Java 6\u0027s @ConstructorProperties annotation (SPR-3313)\n",
      "commitDate": "2009/6/3 下午6:21",
      "commitName": "53333c3ed06e465a55592a0f351ffab40110e5b3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/22 下午6:46",
      "commitNameOld": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 41.98,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        String[] paramNames \u003d null;\n                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n                        if (pnd !\u003d null) {\n                            paramNames \u003d pnd.getParameterNames(candidate);\n                        }\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 297,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,123 +1,128 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n-                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+                        String[] paramNames \u003d null;\n+                        ParameterNameDiscoverer pnd \u003d this.beanFactory.getParameterNameDiscoverer();\n+                        if (pnd !\u003d null) {\n+                            paramNames \u003d pnd.getParameterNames(candidate);\n+                        }\n+                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n-        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        Object beanInstance \u003d this.beanFactory.getInstantiationStrategy().instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ea9d8925a27e80d31d924826cf54f70b2bbcc638": {
      "type": "Ybodychange",
      "commitMessage": "next cut of JavaConfig metadata reading revision: using cached MetadataReaders\n",
      "commitDate": "2009/4/22 下午6:46",
      "commitName": "ea9d8925a27e80d31d924826cf54f70b2bbcc638",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/4/20 上午7:45",
      "commitNameOld": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 296,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,123 +1,123 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         if (!mbd.hasBeanClass()) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n         }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n-            if (argsToUse \u003d\u003d null) {\n+            if (argsToUse \u003d\u003d null \u0026\u0026 mbd.preparedConstructorArguments !\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n-    if (factoryMethodToUse \u003d\u003d null) {\n+    if (factoryMethodToUse \u003d\u003d null || argsToUse \u003d\u003d null) {\n         factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n         Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n         for (Method candidate : rawCandidates) {\n-            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName())) {\n+            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 mbd.isFactoryMethod(candidate)) {\n                 candidateSet.add(candidate);\n             }\n         }\n         Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n         AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "14bd47551900ced88eeacf2a5f63c187ff72028c": {
      "type": "Ybodychange",
      "commitMessage": "revised support for annotated factory methods (merged @FactoryMethod functionality into JavaConfig facility)\n",
      "commitDate": "2009/4/20 上午7:45",
      "commitName": "14bd47551900ced88eeacf2a5f63c187ff72028c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/3/23 下午10:13",
      "commitNameOld": "4344832a479831e7e67de1a9e81d52d023cd59ac",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 27.4,
      "commitsBetweenForRepo": 234,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        if (!mbd.hasBeanClass()) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n        }\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n        Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n        for (Method candidate : rawCandidates) {\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName())) {\n                candidateSet.add(candidate);\n            }\n        }\n        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n        AutowireUtils.sortFactoryMethods(candidates);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 265,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,111 +1,123 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n+        if (!mbd.hasBeanClass()) {\n+            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"bean definition declares neither a bean class nor a factory-bean reference\");\n+        }\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null) {\n                 argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null) {\n-        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+        factoryClass \u003d ClassUtils.getUserClass(factoryClass);\n+        Method[] rawCandidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+        List\u003cMethod\u003e candidateSet \u003d new ArrayList\u003cMethod\u003e();\n+        for (Method candidate : rawCandidates) {\n+            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName())) {\n+                candidateSet.add(candidate);\n+            }\n+        }\n+        Method[] candidates \u003d candidateSet.toArray(new Method[candidateSet.size()]);\n+        AutowireUtils.sortFactoryMethods(candidates);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n-            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n+            if (paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4344832a479831e7e67de1a9e81d52d023cd59ac": {
      "type": "Ybodychange",
      "commitMessage": "qualifier annotations and @Value can be used at method level as well (applying to all parameters); \nfixed EL evaluation of prepared constructor arguments for repeated prototype creation\n",
      "commitDate": "2009/3/23 下午10:13",
      "commitName": "4344832a479831e7e67de1a9e81d52d023cd59ac",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/2/25 下午6:07",
      "commitNameOld": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 26.17,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 263,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,126 +1,111 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Object factoryBean;\n     Class factoryClass;\n     boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n         isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null) {\n-                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n-                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n-                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n-                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n-                argsToUse \u003d new Object[argsToResolve.length];\n-                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n-                    Object argValue \u003d argsToResolve[i];\n-                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n-                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-                    if (argValue instanceof AutowiredArgumentMarker) {\n-                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n-                    } else if (argValue instanceof BeanMetadataElement) {\n-                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n-                    }\n-                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n-                }\n+                argsToUse \u003d resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse);\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null) {\n         Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "092de0107cd876d7f8207da7a9fc9ba163cfadfe": {
      "type": "Ybodychange",
      "commitMessage": "improved NoClassDefFoundError handling during constructor resolution (SPR-5522)\n",
      "commitDate": "2009/2/25 下午6:07",
      "commitName": "092de0107cd876d7f8207da7a9fc9ba163cfadfe",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/11/21 上午1:33",
      "commitNameOld": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 96.69,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Object factoryBean;\n    Class factoryClass;\n    boolean isStatic;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        factoryBean \u003d null;\n        factoryClass \u003d mbd.getBeanClass();\n        isStatic \u003d true;\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse \u003d new Object[argsToResolve.length];\n                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                    Object argValue \u003d argsToResolve[i];\n                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 279,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,124 +1,126 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n-    Class factoryClass \u003d null;\n-    Object factoryBean \u003d null;\n-    boolean isStatic \u003d true;\n+    Object factoryBean;\n+    Class factoryClass;\n+    boolean isStatic;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n+        factoryBean \u003d null;\n         factoryClass \u003d mbd.getBeanClass();\n+        isStatic \u003d true;\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null) {\n                 Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                 Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                 TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                 BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                 argsToUse \u003d new Object[argsToResolve.length];\n                 for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                     Object argValue \u003d argsToResolve[i];\n                     MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                     GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                     if (argValue instanceof AutowiredArgumentMarker) {\n                         argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                     } else if (argValue instanceof BeanMetadataElement) {\n                         argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                     }\n                     argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                 }\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null) {\n         Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n-        int minNrOfArgs \u003d 0;\n+        int minNrOfArgs;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n-                ArgumentsHolder args \u003d null;\n+                ArgumentsHolder args;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Exception cause : causes) {\n                                     this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "05bebb0c056714d97b479cf6c5552ba3c5b06d9c": {
      "type": "Ybodychange",
      "commitMessage": "completed value annotation support; Java 5 code style updates\n",
      "commitDate": "2008/11/21 上午1:33",
      "commitName": "05bebb0c056714d97b479cf6c5552ba3c5b06d9c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/11/20 上午10:10",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.64,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass \u003d null;\n    Object factoryBean \u003d null;\n    boolean isStatic \u003d true;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        factoryClass \u003d mbd.getBeanClass();\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse \u003d new Object[argsToResolve.length];\n                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                    Object argValue \u003d argsToResolve[i];\n                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs \u003d 0;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List\u003cException\u003e causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args \u003d null;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Exception cause : causes) {\n                                    this.beanFactory.onSuppressedException(cause);\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList\u003cException\u003e();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 269,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,124 +1,124 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Class factoryClass \u003d null;\n     Object factoryBean \u003d null;\n     boolean isStatic \u003d true;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         factoryClass \u003d mbd.getBeanClass();\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null) {\n                 Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                 Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                 TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                 BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                 argsToUse \u003d new Object[argsToResolve.length];\n                 for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                     Object argValue \u003d argsToResolve[i];\n                     MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                     GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                     if (argValue instanceof AutowiredArgumentMarker) {\n                         argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                     } else if (argValue instanceof BeanMetadataElement) {\n                         argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                     }\n                     argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                 }\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null) {\n         Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs \u003d 0;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n-        List causes \u003d null;\n+        List\u003cException\u003e causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args \u003d null;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n-                                for (Iterator it \u003d causes.iterator(); it.hasNext(); ) {\n-                                    this.beanFactory.onSuppressedException((Exception) it.next());\n+                                for (Exception cause : causes) {\n+                                    this.beanFactory.onSuppressedException(cause);\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n-                                causes \u003d new LinkedList();\n+                                causes \u003d new LinkedList\u003cException\u003e();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008/11/20 上午10:10",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/10/23 上午12:13",
      "commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 28.41,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass \u003d null;\n    Object factoryBean \u003d null;\n    boolean isStatic \u003d true;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        factoryClass \u003d mbd.getBeanClass();\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse \u003d new Object[argsToResolve.length];\n                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                    Object argValue \u003d argsToResolve[i];\n                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs \u003d 0;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args \u003d null;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Iterator it \u003d causes.iterator(); it.hasNext(); ) {\n                                    this.beanFactory.onSuppressedException((Exception) it.next());\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 270,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n",
      "diff": "@@ -1,126 +1,124 @@\n public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n     BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n     this.beanFactory.initBeanWrapper(bw);\n     Class factoryClass \u003d null;\n     Object factoryBean \u003d null;\n     boolean isStatic \u003d true;\n     String factoryBeanName \u003d mbd.getFactoryBeanName();\n     if (factoryBeanName !\u003d null) {\n         if (factoryBeanName.equals(beanName)) {\n             throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n         }\n         factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n         if (factoryBean \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n         }\n         factoryClass \u003d factoryBean.getClass();\n         isStatic \u003d false;\n     } else {\n         factoryClass \u003d mbd.getBeanClass();\n     }\n     Method factoryMethodToUse \u003d null;\n     Object[] argsToUse \u003d null;\n     if (explicitArgs !\u003d null) {\n         argsToUse \u003d explicitArgs;\n     } else {\n         factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n         if (factoryMethodToUse !\u003d null) {\n             argsToUse \u003d mbd.resolvedConstructorArguments;\n             if (argsToUse \u003d\u003d null) {\n                 Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                 Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                 TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                 BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                 argsToUse \u003d new Object[argsToResolve.length];\n                 for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                     Object argValue \u003d argsToResolve[i];\n                     MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n-                    if (JdkVersion.isAtLeastJava15()) {\n-                        GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n-                    }\n+                    GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                     if (argValue instanceof AutowiredArgumentMarker) {\n                         argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                     } else if (argValue instanceof BeanMetadataElement) {\n                         argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                     }\n                     argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                 }\n             }\n         }\n     }\n     if (factoryMethodToUse \u003d\u003d null) {\n         Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n         boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n         int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n         ConstructorArgumentValues resolvedValues \u003d null;\n         int minNrOfArgs \u003d 0;\n         if (explicitArgs !\u003d null) {\n             minNrOfArgs \u003d explicitArgs.length;\n         } else {\n             ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n             resolvedValues \u003d new ConstructorArgumentValues();\n             minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n         }\n         List causes \u003d null;\n         for (int i \u003d 0; i \u003c candidates.length; i++) {\n             Method candidate \u003d candidates[i];\n             Class[] paramTypes \u003d candidate.getParameterTypes();\n             if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                 ArgumentsHolder args \u003d null;\n                 if (resolvedValues !\u003d null) {\n                     try {\n                         args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                     } catch (UnsatisfiedDependencyException ex) {\n                         if (this.beanFactory.logger.isTraceEnabled()) {\n                             this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                         }\n                         if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                             if (causes !\u003d null) {\n                                 for (Iterator it \u003d causes.iterator(); it.hasNext(); ) {\n                                     this.beanFactory.onSuppressedException((Exception) it.next());\n                                 }\n                             }\n                             throw ex;\n                         } else {\n                             if (causes \u003d\u003d null) {\n                                 causes \u003d new LinkedList();\n                             }\n                             causes.add(ex);\n                             continue;\n                         }\n                     }\n                 } else {\n                     if (paramTypes.length !\u003d explicitArgs.length) {\n                         continue;\n                     }\n                     args \u003d new ArgumentsHolder(explicitArgs);\n                 }\n                 int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                 if (typeDiffWeight \u003c minTypeDiffWeight) {\n                     factoryMethodToUse \u003d candidate;\n                     argsToUse \u003d args.arguments;\n                     minTypeDiffWeight \u003d typeDiffWeight;\n                 }\n             }\n         }\n         if (factoryMethodToUse \u003d\u003d null) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n         }\n         if (void.class.equals(factoryMethodToUse.getReturnType())) {\n             throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n         }\n         if (explicitArgs \u003d\u003d null) {\n             mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n         }\n     }\n     try {\n         Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n         if (beanInstance \u003d\u003d null) {\n             return null;\n         }\n         bw.setWrappedInstance(beanInstance);\n         return bw;\n     } catch (Throwable ex) {\n         throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008/10/23 上午12:13",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,126 @@\n+public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n+    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n+    this.beanFactory.initBeanWrapper(bw);\n+    Class factoryClass \u003d null;\n+    Object factoryBean \u003d null;\n+    boolean isStatic \u003d true;\n+    String factoryBeanName \u003d mbd.getFactoryBeanName();\n+    if (factoryBeanName !\u003d null) {\n+        if (factoryBeanName.equals(beanName)) {\n+            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n+        }\n+        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n+        if (factoryBean \u003d\u003d null) {\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n+        }\n+        factoryClass \u003d factoryBean.getClass();\n+        isStatic \u003d false;\n+    } else {\n+        factoryClass \u003d mbd.getBeanClass();\n+    }\n+    Method factoryMethodToUse \u003d null;\n+    Object[] argsToUse \u003d null;\n+    if (explicitArgs !\u003d null) {\n+        argsToUse \u003d explicitArgs;\n+    } else {\n+        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n+        if (factoryMethodToUse !\u003d null) {\n+            argsToUse \u003d mbd.resolvedConstructorArguments;\n+            if (argsToUse \u003d\u003d null) {\n+                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n+                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n+                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n+                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n+                argsToUse \u003d new Object[argsToResolve.length];\n+                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n+                    Object argValue \u003d argsToResolve[i];\n+                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n+                    if (JdkVersion.isAtLeastJava15()) {\n+                        GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n+                    }\n+                    if (argValue instanceof AutowiredArgumentMarker) {\n+                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n+                    } else if (argValue instanceof BeanMetadataElement) {\n+                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n+                    }\n+                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n+                }\n+            }\n+        }\n+    }\n+    if (factoryMethodToUse \u003d\u003d null) {\n+        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n+        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n+        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n+        ConstructorArgumentValues resolvedValues \u003d null;\n+        int minNrOfArgs \u003d 0;\n+        if (explicitArgs !\u003d null) {\n+            minNrOfArgs \u003d explicitArgs.length;\n+        } else {\n+            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n+            resolvedValues \u003d new ConstructorArgumentValues();\n+            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n+        }\n+        List causes \u003d null;\n+        for (int i \u003d 0; i \u003c candidates.length; i++) {\n+            Method candidate \u003d candidates[i];\n+            Class[] paramTypes \u003d candidate.getParameterTypes();\n+            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n+                ArgumentsHolder args \u003d null;\n+                if (resolvedValues !\u003d null) {\n+                    try {\n+                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n+                    } catch (UnsatisfiedDependencyException ex) {\n+                        if (this.beanFactory.logger.isTraceEnabled()) {\n+                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n+                        }\n+                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n+                            if (causes !\u003d null) {\n+                                for (Iterator it \u003d causes.iterator(); it.hasNext(); ) {\n+                                    this.beanFactory.onSuppressedException((Exception) it.next());\n+                                }\n+                            }\n+                            throw ex;\n+                        } else {\n+                            if (causes \u003d\u003d null) {\n+                                causes \u003d new LinkedList();\n+                            }\n+                            causes.add(ex);\n+                            continue;\n+                        }\n+                    }\n+                } else {\n+                    if (paramTypes.length !\u003d explicitArgs.length) {\n+                        continue;\n+                    }\n+                    args \u003d new ArgumentsHolder(explicitArgs);\n+                }\n+                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n+                if (typeDiffWeight \u003c minTypeDiffWeight) {\n+                    factoryMethodToUse \u003d candidate;\n+                    argsToUse \u003d args.arguments;\n+                    minTypeDiffWeight \u003d typeDiffWeight;\n+                }\n+            }\n+        }\n+        if (factoryMethodToUse \u003d\u003d null) {\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n+        }\n+        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n+            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n+        }\n+        if (explicitArgs \u003d\u003d null) {\n+            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n+        }\n+    }\n+    try {\n+        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n+        if (beanInstance \u003d\u003d null) {\n+            return null;\n+        }\n+        bw.setWrappedInstance(beanInstance);\n+        return bw;\n+    } catch (Throwable ex) {\n+        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "public BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, Object[] explicitArgs) {\n    BeanWrapperImpl bw \u003d new BeanWrapperImpl();\n    this.beanFactory.initBeanWrapper(bw);\n    Class factoryClass \u003d null;\n    Object factoryBean \u003d null;\n    boolean isStatic \u003d true;\n    String factoryBeanName \u003d mbd.getFactoryBeanName();\n    if (factoryBeanName !\u003d null) {\n        if (factoryBeanName.equals(beanName)) {\n            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, \"factory-bean reference points back to the same bean definition\");\n        }\n        factoryBean \u003d this.beanFactory.getBean(factoryBeanName);\n        if (factoryBean \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"factory-bean \u0027\" + factoryBeanName + \"\u0027 returned null\");\n        }\n        factoryClass \u003d factoryBean.getClass();\n        isStatic \u003d false;\n    } else {\n        factoryClass \u003d mbd.getBeanClass();\n    }\n    Method factoryMethodToUse \u003d null;\n    Object[] argsToUse \u003d null;\n    if (explicitArgs !\u003d null) {\n        argsToUse \u003d explicitArgs;\n    } else {\n        factoryMethodToUse \u003d (Method) mbd.resolvedConstructorOrFactoryMethod;\n        if (factoryMethodToUse !\u003d null) {\n            argsToUse \u003d mbd.resolvedConstructorArguments;\n            if (argsToUse \u003d\u003d null) {\n                Class[] paramTypes \u003d factoryMethodToUse.getParameterTypes();\n                Object[] argsToResolve \u003d mbd.preparedConstructorArguments;\n                TypeConverter converter \u003d (this.typeConverter !\u003d null ? this.typeConverter : bw);\n                BeanDefinitionValueResolver valueResolver \u003d new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);\n                argsToUse \u003d new Object[argsToResolve.length];\n                for (int i \u003d 0; i \u003c argsToResolve.length; i++) {\n                    Object argValue \u003d argsToResolve[i];\n                    MethodParameter methodParam \u003d new MethodParameter(factoryMethodToUse, i);\n                    if (JdkVersion.isAtLeastJava15()) {\n                        GenericTypeResolver.resolveParameterType(methodParam, factoryClass);\n                    }\n                    if (argValue instanceof AutowiredArgumentMarker) {\n                        argValue \u003d resolveAutowiredArgument(methodParam, beanName, null, converter);\n                    } else if (argValue instanceof BeanMetadataElement) {\n                        argValue \u003d valueResolver.resolveValueIfNecessary(\"factory method argument\", argValue);\n                    }\n                    argsToUse[i] \u003d converter.convertIfNecessary(argValue, paramTypes[i], methodParam);\n                }\n            }\n        }\n    }\n    if (factoryMethodToUse \u003d\u003d null) {\n        Method[] candidates \u003d ReflectionUtils.getAllDeclaredMethods(factoryClass);\n        boolean autowiring \u003d (mbd.getResolvedAutowireMode() \u003d\u003d RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n        int minTypeDiffWeight \u003d Integer.MAX_VALUE;\n        ConstructorArgumentValues resolvedValues \u003d null;\n        int minNrOfArgs \u003d 0;\n        if (explicitArgs !\u003d null) {\n            minNrOfArgs \u003d explicitArgs.length;\n        } else {\n            ConstructorArgumentValues cargs \u003d mbd.getConstructorArgumentValues();\n            resolvedValues \u003d new ConstructorArgumentValues();\n            minNrOfArgs \u003d resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);\n        }\n        List causes \u003d null;\n        for (int i \u003d 0; i \u003c candidates.length; i++) {\n            Method candidate \u003d candidates[i];\n            Class[] paramTypes \u003d candidate.getParameterTypes();\n            if (Modifier.isStatic(candidate.getModifiers()) \u003d\u003d isStatic \u0026\u0026 candidate.getName().equals(mbd.getFactoryMethodName()) \u0026\u0026 paramTypes.length \u003e\u003d minNrOfArgs) {\n                ArgumentsHolder args \u003d null;\n                if (resolvedValues !\u003d null) {\n                    try {\n                        args \u003d createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, candidate, autowiring);\n                    } catch (UnsatisfiedDependencyException ex) {\n                        if (this.beanFactory.logger.isTraceEnabled()) {\n                            this.beanFactory.logger.trace(\"Ignoring factory method [\" + candidate + \"] of bean \u0027\" + beanName + \"\u0027: \" + ex);\n                        }\n                        if (i \u003d\u003d candidates.length - 1 \u0026\u0026 factoryMethodToUse \u003d\u003d null) {\n                            if (causes !\u003d null) {\n                                for (Iterator it \u003d causes.iterator(); it.hasNext(); ) {\n                                    this.beanFactory.onSuppressedException((Exception) it.next());\n                                }\n                            }\n                            throw ex;\n                        } else {\n                            if (causes \u003d\u003d null) {\n                                causes \u003d new LinkedList();\n                            }\n                            causes.add(ex);\n                            continue;\n                        }\n                    }\n                } else {\n                    if (paramTypes.length !\u003d explicitArgs.length) {\n                        continue;\n                    }\n                    args \u003d new ArgumentsHolder(explicitArgs);\n                }\n                int typeDiffWeight \u003d args.getTypeDifferenceWeight(paramTypes);\n                if (typeDiffWeight \u003c minTypeDiffWeight) {\n                    factoryMethodToUse \u003d candidate;\n                    argsToUse \u003d args.arguments;\n                    minTypeDiffWeight \u003d typeDiffWeight;\n                }\n            }\n        }\n        if (factoryMethodToUse \u003d\u003d null) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"No matching factory method found: \" + (mbd.getFactoryBeanName() !\u003d null ? \"factory bean \u0027\" + mbd.getFactoryBeanName() + \"\u0027; \" : \"\") + \"factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027\");\n        }\n        if (void.class.equals(factoryMethodToUse.getReturnType())) {\n            throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Invalid factory method \u0027\" + mbd.getFactoryMethodName() + \"\u0027: needs to have a non-void return type!\");\n        }\n        if (explicitArgs \u003d\u003d null) {\n            mbd.resolvedConstructorOrFactoryMethod \u003d factoryMethodToUse;\n        }\n    }\n    try {\n        Object beanInstance \u003d this.instantiationStrategy.instantiate(mbd, beanName, this.beanFactory, factoryBean, factoryMethodToUse, argsToUse);\n        if (beanInstance \u003d\u003d null) {\n            return null;\n        }\n        bw.setWrappedInstance(beanInstance);\n        return bw;\n    } catch (Throwable ex) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex);\n    }\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/factory/support/ConstructorResolver.java",
      "functionStartLine": 273,
      "functionName": "instantiateUsingFactoryMethod",
      "functionAnnotation": "",
      "functionDoc": "Instantiate the bean using a named factory method. The method may be static, if the\nbean definition parameter specifies a class, rather than a \"factory-bean\", or\nan instance variable on a factory object itself configured using Dependency Injection.\n\u003cp\u003eImplementation requires iterating over the static or instance methods with the\nname specified in the RootBeanDefinition (the method may be overloaded) and trying\nto match with the parameters. We don\u0027t have the types attached to constructor args,\nso trial and error is the only way to go here. The explicitArgs array may contain\nargument values passed in programmatically via the corresponding getBean method.\n\n@param beanName the name of the bean\n@param mbd the merged bean definition for the bean\n@param explicitArgs argument values passed in programmatically via the getBean\nmethod, or \u003ccode\u003enull\u003c/code\u003e if none (-\u003e use constructor argument values from bean definition)\n@return a BeanWrapper for the new instance\n"
    }
  }
}