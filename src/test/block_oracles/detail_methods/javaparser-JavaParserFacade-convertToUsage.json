{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "JavaParserFacade.java",
  "functionName": "convertToUsage",
  "functionId": "convertToUsage___type-com.github.javaparser.ast.type.Type__context-Context",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 519,
  "functionEndLine": 578,
  "numCommitsSeen": 239,
  "timeTaken": 1963,
  "changeHistory": [
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
    "b54617e765d73b3ce0d187cf12ad8da382bce439",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
    "478a9ba268137913d67438b1e3c8f61e5e0976a5",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "56377a22d552f0880ceccacf1aca1eafbc7094e4",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
    "33d37d1089463ba9af543996a05cac5955c46251",
    "90c22f84a61e12130a8750d235acf7ed06305796",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
    "07782fbbe149055d495e0c358da844734c08641f",
    "c990d23490f5c4ac4322119b03d5951b63eef055",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
    "33753cab1604a44d43215ba4055b435606a7a71b",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "03ec309bba14eaf50a32b05353fa9711b831de7f",
    "fb388c36c0045c50744cf215521e5c280036aa70",
    "1613b8d9cc00da012539ea3db05cdb0cc8153358",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
    "eec165d9e3ef0ab1d93f69a231964984a3379762",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
    "1829d9560d37efd59722aaa2f1f22e392918429b",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba",
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
    "1d5332815b543d569be3d7ec672a65b7efc39a04",
    "6650e5a3818c15de2883b71cd41524b0337e26f6",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa"
  ],
  "changeHistoryShort": {
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4": "Ybodychange",
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea": "Ybodychange",
    "b54617e765d73b3ce0d187cf12ad8da382bce439": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9": "Ybodychange",
    "478a9ba268137913d67438b1e3c8f61e5e0976a5": "Ybodychange",
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": "Ybodychange",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yreturntypechange,Ybodychange)",
    "56377a22d552f0880ceccacf1aca1eafbc7094e4": "Ymodifierchange",
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": "Ymodifierchange",
    "33d37d1089463ba9af543996a05cac5955c46251": "Ybodychange",
    "90c22f84a61e12130a8750d235acf7ed06305796": "Yparameterchange",
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": "Ybodychange",
    "07782fbbe149055d495e0c358da844734c08641f": "Ymodifierchange",
    "c990d23490f5c4ac4322119b03d5951b63eef055": "Ymultichange(Yparameterchange,Ybodychange)",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": "Ybodychange",
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe": "Ybodychange",
    "33753cab1604a44d43215ba4055b435606a7a71b": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492": "Ybodychange",
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf": "Ybodychange",
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "03ec309bba14eaf50a32b05353fa9711b831de7f": "Ybodychange",
    "fb388c36c0045c50744cf215521e5c280036aa70": "Yfilerename",
    "1613b8d9cc00da012539ea3db05cdb0cc8153358": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": "Ybodychange",
    "eec165d9e3ef0ab1d93f69a231964984a3379762": "Ybodychange",
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": "Ybodychange",
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": "Ybodychange",
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": "Ybodychange",
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": "Ybodychange",
    "1829d9560d37efd59722aaa2f1f22e392918429b": "Ybodychange",
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": "Ybodychange",
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34": "Ybodychange",
    "1d5332815b543d569be3d7ec672a65b7efc39a04": "Ybodychange",
    "6650e5a3818c15de2883b71cd41524b0337e26f6": "Ymodifierchange",
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": "Yintroduced"
  },
  "changeHistoryDetails": {
    "427dd53b9ebedcb0bdb687007eb0faf2de734df4": {
      "type": "Ybodychange",
      "commitMessage": "Better error handling for \"var\" inferrer.\n",
      "commitDate": "2018/2/15 上午2:49",
      "commitName": "427dd53b9ebedcb0bdb687007eb0faf2de734df4",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018/2/15 上午1:42",
      "commitNameOld": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType \u003d (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n    } else if (type instanceof VarType) {\n        Node parent \u003d type.getParentNode().get();\n        if (!(parent instanceof VariableDeclarator)) {\n            throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n        }\n        final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) parent;\n        return variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -\u003e new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,54 +1,58 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (context \u003d\u003d null) {\n         throw new NullPointerException(\"Context should not be null\");\n     }\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n         } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n         } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else if (type instanceof UnionType) {\n         UnionType unionType \u003d (UnionType) type;\n         return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n     } else if (type instanceof VarType) {\n-        final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) type.getParentNode().get();\n-        return variableDeclarator.getInitializer().get().calculateResolvedType();\n+        Node parent \u003d type.getParentNode().get();\n+        if (!(parent instanceof VariableDeclarator)) {\n+            throw new IllegalStateException(\"Trying to resolve a `var` which is not in a variable declaration.\");\n+        }\n+        final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) parent;\n+        return variableDeclarator.getInitializer().map(Expression::calculateResolvedType).orElseThrow(() -\u003e new IllegalStateException(\"Cannot resolve `var` which has no initializer.\"));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d59e3083ed82de3490c2f5ca35a07bb73806fea": {
      "type": "Ybodychange",
      "commitMessage": "Make a simple \"var\" inferrer.\n",
      "commitDate": "2018/2/15 上午1:42",
      "commitName": "6d59e3083ed82de3490c2f5ca35a07bb73806fea",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018/2/4 上午2:46",
      "commitNameOld": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthorOld": "Danny van Bruggen",
      "daysBetweenCommits": 10.96,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType \u003d (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n    } else if (type instanceof VarType) {\n        final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) type.getParentNode().get();\n        return variableDeclarator.getInitializer().get().calculateResolvedType();\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,51 +1,54 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (context \u003d\u003d null) {\n         throw new NullPointerException(\"Context should not be null\");\n     }\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n         } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n         } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else if (type instanceof UnionType) {\n         UnionType unionType \u003d (UnionType) type;\n         return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n+    } else if (type instanceof VarType) {\n+        final VariableDeclarator variableDeclarator \u003d (VariableDeclarator) type.getParentNode().get();\n+        return variableDeclarator.getInitializer().get().calculateResolvedType();\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b54617e765d73b3ce0d187cf12ad8da382bce439": {
      "type": "Ybodychange",
      "commitMessage": "Cleaning up JSS code\n",
      "commitDate": "2018/2/4 上午2:46",
      "commitName": "b54617e765d73b3ce0d187cf12ad8da382bce439",
      "commitAuthor": "Danny van Bruggen",
      "commitDateOld": "2018/1/10 下午8:52",
      "commitNameOld": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 24.25,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType \u003d (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 429,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,51 +1,51 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (context \u003d\u003d null) {\n         throw new NullPointerException(\"Context should not be null\");\n     }\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n-        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n-        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n+        if (wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n+            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedType().get(), context));\n+        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 wildcardType.getSuperType().isPresent()) {\n+            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperType().get(), context));\n+        } else if (!wildcardType.getExtendedType().isPresent() \u0026\u0026 !wildcardType.getSuperType().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else if (type instanceof UnionType) {\n         UnionType unionType \u003d (UnionType) type;\n         return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType \u003d (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 448,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "f63811a47591d89b25a1de78686bdc6dfcaf42b9": {
      "type": "Ybodychange",
      "commitMessage": "adding support to resolve union types\n",
      "commitDate": "2017/11/25 下午7:15",
      "commitName": "f63811a47591d89b25a1de78686bdc6dfcaf42b9",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/11/25 下午4:49",
      "commitNameOld": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else if (type instanceof UnionType) {\n        UnionType unionType \u003d (UnionType) type;\n        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 443,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,51 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (context \u003d\u003d null) {\n         throw new NullPointerException(\"Context should not be null\");\n     }\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+    } else if (type instanceof UnionType) {\n+        UnionType unionType \u003d (UnionType) type;\n+        return new ResolvedUnionType(unionType.getElements().stream().map(el -\u003e convertToUsage(el, context)).collect(Collectors.toList()));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "478a9ba268137913d67438b1e3c8f61e5e0976a5": {
      "type": "Ybodychange",
      "commitMessage": "adding tests for #343 and improving error messages for nodes outside the AST\n",
      "commitDate": "2017/11/25 下午4:49",
      "commitName": "478a9ba268137913d67438b1e3c8f61e5e0976a5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/11/8 上午4:09",
      "commitNameOld": "23a829996b5393fc6697d51b1d3ec332157b1279",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 17.53,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (context \u003d\u003d null) {\n        throw new NullPointerException(\"Context should not be null\");\n    }\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 446,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,48 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    if (context \u003d\u003d null) {\n+        throw new NullPointerException(\"Context should not be null\");\n+    }\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                 return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "198ba6cbe49832ac09ca84c6920e9be661a3b56a": {
      "type": "Ybodychange",
      "commitMessage": "issue1154: correct most compilation errors in the jp model\n",
      "commitDate": "2017/9/29 下午2:30",
      "commitName": "198ba6cbe49832ac09ca84c6920e9be661a3b56a",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2017/9/29 上午4:36",
      "commitNameOld": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 431,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n-        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+        SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n-        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+        ResolvedTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n-            if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n+            if (typeDeclaration instanceof ResolvedTypeParameterDeclaration) {\n+                return new ResolvedTypeVariable((ResolvedTypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new ResolvedTypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n-        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n+        return ResolvedPrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017/9/29 上午4:36",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/9/29 上午3:35",
          "commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 434,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n-protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n+        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n+            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n+            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.UNBOUNDED;\n+            return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-        return VoidType.INSTANCE;\n+        return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n-        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Type",
            "newValue": "ResolvedType"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/9/29 上午3:35",
          "commitNameOld": "c3dc3669e86f005080c02e62162356022eafaac1",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "actualSource": "protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return ResolvedWildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return ResolvedVoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 434,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n-protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+protected ResolvedType convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n+        List\u003cResolvedType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n+            return ResolvedWildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n+            return ResolvedWildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.UNBOUNDED;\n+            return ResolvedWildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n-        return VoidType.INSTANCE;\n+        return ResolvedVoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n-        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n+        return new ResolvedArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "56377a22d552f0880ceccacf1aca1eafbc7094e4": {
      "type": "Ymodifierchange",
      "commitMessage": "Switch method to protected as it wasn\u0027t originally public\n",
      "commitDate": "2017/2/14 上午7:59",
      "commitName": "56377a22d552f0880ceccacf1aca1eafbc7094e4",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/2/14 上午7:49",
      "commitNameOld": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 396,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n-public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+protected Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[protected]"
      }
    },
    "0f40221492b47df25615a1b5909fefa6f2d6fa0e": {
      "type": "Ymodifierchange",
      "commitMessage": "Refactored out huge method from facade to visitor\n",
      "commitDate": "2017/2/14 上午7:49",
      "commitName": "0f40221492b47df25615a1b5909fefa6f2d6fa0e",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/2/2 上午8:04",
      "commitNameOld": "a12a91a78591323403230d5654879a44ab4afb20",
      "commitAuthorOld": "Brandon Fergerson",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 396,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n-private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "33d37d1089463ba9af543996a05cac5955c46251": {
      "type": "Ybodychange",
      "commitMessage": "Fixed issue when converting wildcard type with super bound\n",
      "commitDate": "2017/1/13 上午1:17",
      "commitName": "33d37d1089463ba9af543996a05cac5955c46251",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/1/12 上午8:45",
      "commitNameOld": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 713,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n-            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n+            return Wildcard.superBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "90c22f84a61e12130a8750d235acf7ed06305796": {
      "type": "Yparameterchange",
      "commitMessage": "migration to JavaParser 3.0.0-RC.3\n",
      "commitDate": "2016/12/20 上午12:01",
      "commitName": "90c22f84a61e12130a8750d235acf7ed06305796",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/14 上午3:42",
      "commitNameOld": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 711,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n-private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n+private Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n         } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[type-com.github.javaparser.ast.type.Type\u003c?\u003e, context-Context]",
        "newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
      }
    },
    "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923": {
      "type": "Ybodychange",
      "commitMessage": "porting to JavaParser 3.0.0 RC2\n",
      "commitDate": "2016/12/14 上午3:42",
      "commitName": "52b60cf471dc9d7b53d8f22018d9c4e4fcc15923",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/14 上午12:45",
      "commitNameOld": "cb5ffb7fdd56f1b768d25da330fa3b29ecb74eaf",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 711,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n-        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n-        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+        if (wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtendedTypes().get(), context));\n+        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 wildcardType.getSuperTypes().isPresent()) {\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuperTypes().get(), context));\n+        } else if (!wildcardType.getExtendedTypes().isPresent() \u0026\u0026 !wildcardType.getSuperTypes().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "07782fbbe149055d495e0c358da844734c08641f": {
      "type": "Ymodifierchange",
      "commitMessage": "reformat JavaParserFacade\n",
      "commitDate": "2016/12/14 上午12:41",
      "commitName": "07782fbbe149055d495e0c358da844734c08641f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/12/13 下午9:10",
      "commitNameOld": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthorOld": "Fred Lefévère-Laoide",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 760,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n-public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n+private Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[private]"
      }
    },
    "c990d23490f5c4ac4322119b03d5951b63eef055": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "loads of changes to support our code",
      "commitDate": "2016/12/13 下午9:10",
      "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
      "commitAuthor": "Fred Lefévère-Laoide",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "loads of changes to support our code",
          "commitDate": "2016/12/13 下午9:10",
          "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
          "commitAuthor": "Fred Lefévère-Laoide",
          "commitDateOld": "2016/11/22 上午4:52",
          "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 21.68,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 760,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n-public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[type-com.github.javaparser.ast.type.Type, context-Context]",
            "newValue": "[type-com.github.javaparser.ast.type.Type\u003c?\u003e, context-Context]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "loads of changes to support our code",
          "commitDate": "2016/12/13 下午9:10",
          "commitName": "c990d23490f5c4ac4322119b03d5951b63eef055",
          "commitAuthor": "Fred Lefévère-Laoide",
          "commitDateOld": "2016/11/22 上午4:52",
          "commitNameOld": "dfebf682a440aa48a8a444562f7fdfc1819b9a1e",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 21.68,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 760,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,45 @@\n-public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+public Type convertToUsage(com.github.javaparser.ast.type.Type\u003c?\u003e type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+            return Wildcard.extendsBound(convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016/11/22 上午2:58",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/10 上午1:15",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 592,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n-            typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n+            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016/11/10 上午1:15",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/6 下午4:40",
      "commitNameOld": "c746c4ef7711a05c27827ab749d96155046a4f91",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.36,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 592,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n-            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+            typeParameters \u003d classOrInterfaceType.getTypeArguments().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n-        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n+        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n+        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:22",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午11:08",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 590,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n-        SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n-        ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeImpl((ReferenceTypeDeclaration) typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:08",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午3:58",
      "commitNameOld": "2fde8a6409906ab1e0b5e846f2e54b82da7878b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 590,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n-        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n+        SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n-        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+        ReferenceTypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b32947e8c85bc21fe533173f50d4a0a91036fdaf": {
      "type": "Ybodychange",
      "commitMessage": "adding more comments in model declarations\n",
      "commitDate": "2016/10/21 下午2:55",
      "commitName": "b32947e8c85bc21fe533173f50d4a0a91036fdaf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/21 上午4:06",
      "commitNameOld": "1e7780e554428a10c73de88ca64e5933b2291593",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeParameter()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 570,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,45 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n-        if (typeDeclaration.isTypeVariable()) {\n+        if (typeDeclaration.isTypeParameter()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n         com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n         return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:32",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 566,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "4601dfb9d1acf7f564948b7ddbb9201d62849ad7": {
      "type": "Ybodychange",
      "commitMessage": "revision of modified code to use Navigator.getParentNode\n",
      "commitDate": "2016/10/20 上午1:35",
      "commitName": "4601dfb9d1acf7f564948b7ddbb9201d62849ad7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:34",
      "commitNameOld": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 567,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,45 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n+    } else if (type instanceof com.github.javaparser.ast.type.ArrayType) {\n+        com.github.javaparser.ast.type.ArrayType jpArrayType \u003d (com.github.javaparser.ast.type.ArrayType) type;\n+        return new ArrayType(convertToUsage(jpArrayType.getComponentType(), context));\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe": {
      "type": "Ybodychange",
      "commitMessage": "issue91: JavaParserClassDeclarationTest passing\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "3fcd7b41f404d112b13d3bfe732b26eceec0dbfe",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:33",
      "commitNameOld": "33753cab1604a44d43215ba4055b435606a7a71b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException(wildcardType.toString());\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,42 +1,42 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+        if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n-        } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n+        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n-            throw new UnsupportedOperationException();\n+            throw new UnsupportedOperationException(wildcardType.toString());\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "33753cab1604a44d43215ba4055b435606a7a71b": {
      "type": "Ybodychange",
      "commitMessage": "issue91: first fixes\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "33753cab1604a44d43215ba4055b435606a7a71b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:33",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,46 +1,42 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n-    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n-        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n-        Type typeUsage \u003d convertToUsage(referenceType, context);\n-        return typeUsage;\n-    } else if (type instanceof ClassOrInterfaceType) {\n+    if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+        if (classOrInterfaceType.getTypeArguments().isPresent()) {\n             typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n         } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n         } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/19 下午11:04",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType, context);\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n        } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 563,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,46 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n         com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n-        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n-        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-            typeUsage \u003d new ArrayType(typeUsage);\n-        }\n+        Type typeUsage \u003d convertToUsage(referenceType, context);\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n-        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n-            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+        if (classOrInterfaceType.getTypeArguments() !\u003d null) {\n+            typeParameters \u003d classOrInterfaceType.getTypeArguments().get().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n                 return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n-        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n-        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n-        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+        if (wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends().get(), context));\n+        } else if (!wildcardType.getExtends().isPresent() \u0026\u0026 wildcardType.getSuper().isPresent()) {\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper().get(), context));\n+        } else if (wildcardType.getExtends().isPresent() \u0026\u0026 !wildcardType.getSuper().isPresent()) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492": {
      "type": "Ybodychange",
      "commitMessage": "rename to typevariable and add comment\n",
      "commitDate": "2016/10/18 上午4:00",
      "commitName": "d6a1f32f00bd513d6bc56fbbfefcb9ae9c706492",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/17 上午12:48",
      "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 547,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n         com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n         Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayType(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameterDeclaration) {\n-                return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n+                return new TypeVariable((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeVariable(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ecc78c8b480ceb41019f764c983aaa69c2dabfe3": {
      "type": "Ybodychange",
      "commitMessage": "reorganize packages in model\n",
      "commitDate": "2016/10/15 上午12:51",
      "commitName": "ecc78c8b480ceb41019f764c983aaa69c2dabfe3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 下午2:19",
      "commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.44,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameterDeclaration) {\n                return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 548,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n     if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n         com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n         Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayType(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n-            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n-                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n+            if (typeDeclaration instanceof TypeParameterDeclaration) {\n+                return new TypeParameter((TypeParameterDeclaration) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n         return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n             return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n         return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午8:20",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,49 @@\n-public TypeUsage convertToUsage(Type type, Context context) {\n-    if (type instanceof ReferenceType) {\n-        ReferenceType referenceType \u003d (ReferenceType) type;\n-        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+            typeUsage \u003d new ArrayType(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n-            if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n-    } else if (type instanceof PrimitiveType) {\n-        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.UNBOUNDED;\n+            return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n-    } else if (type instanceof VoidType) {\n-        return VoidTypeUsage.INSTANCE;\n+    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+        return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[type-Type, context-Context]",
            "newValue": "[type-com.github.javaparser.ast.type.Type, context-Context]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午8:20",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,49 @@\n-public TypeUsage convertToUsage(Type type, Context context) {\n-    if (type instanceof ReferenceType) {\n-        ReferenceType referenceType \u003d (ReferenceType) type;\n-        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+            typeUsage \u003d new ArrayType(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n-            if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n-    } else if (type instanceof PrimitiveType) {\n-        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.UNBOUNDED;\n+            return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n-    } else if (type instanceof VoidType) {\n-        return VoidTypeUsage.INSTANCE;\n+    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+        return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "TypeUsage",
            "newValue": "Type"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 下午8:20",
          "commitNameOld": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "actualSource": "public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayType(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return Wildcard.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n        return VoidType.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
          "functionStartLine": 546,
          "functionName": "convertToUsage",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,49 +1,49 @@\n-public TypeUsage convertToUsage(Type type, Context context) {\n-    if (type instanceof ReferenceType) {\n-        ReferenceType referenceType \u003d (ReferenceType) type;\n-        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+public Type convertToUsage(com.github.javaparser.ast.type.Type type, Context context) {\n+    if (type instanceof com.github.javaparser.ast.type.ReferenceType) {\n+        com.github.javaparser.ast.type.ReferenceType referenceType \u003d (com.github.javaparser.ast.type.ReferenceType) type;\n+        Type typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n-            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+            typeUsage \u003d new ArrayType(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n-        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+        List\u003cType\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n-            if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+            if (typeDeclaration instanceof me.tomassetti.symbolsolver.model.resolution.TypeParameter) {\n+                return new TypeParameter((me.tomassetti.symbolsolver.model.resolution.TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n-    } else if (type instanceof PrimitiveType) {\n-        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+    } else if (type instanceof com.github.javaparser.ast.type.PrimitiveType) {\n+        return PrimitiveType.byName(((com.github.javaparser.ast.type.PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n+            return Wildcard.extendsBound((ReferenceTypeImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.UNBOUNDED;\n+            return Wildcard.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n-    } else if (type instanceof VoidType) {\n-        return VoidTypeUsage.INSTANCE;\n+    } else if (type instanceof com.github.javaparser.ast.type.VoidType) {\n+        return VoidType.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "14c9305d49885a12acdb7c09d2e35ad29b5403cf": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"issue80: improve TypeParameter.describe\"\n\nThis reverts commit e581ddb297f5a1da9790adaeadbb6d0f43c8432f.\n",
      "commitDate": "2016/10/13 下午8:20",
      "commitName": "14c9305d49885a12acdb7c09d2e35ad29b5403cf",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/13 下午8:12",
      "commitNameOld": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 545,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n+                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n+                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n             return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return WildcardUsage.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e581ddb297f5a1da9790adaeadbb6d0f43c8432f": {
      "type": "Ybodychange",
      "commitMessage": "issue80: improve TypeParameter.describe\n",
      "commitDate": "2016/10/13 下午8:12",
      "commitName": "e581ddb297f5a1da9790adaeadbb6d0f43c8432f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/12 上午1:37",
      "commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.77,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 545,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n+                return new TypeParameterUsage((TypeParameter) typeDeclaration, typeSolver);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter(), typeSolver);\n             }\n         } else {\n             return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n             return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return WildcardUsage.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015/11/22 下午6:45",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/22 下午6:03",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java",
      "functionStartLine": 425,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/JavaParserFacade.java"
      }
    },
    "4a18b1ee8ed716d6e32e190f728f1eee57148872": {
      "type": "Ybodychange",
      "commitMessage": "modules: extraction of the model module\n",
      "commitDate": "2015/11/13 下午5:59",
      "commitName": "4a18b1ee8ed716d6e32e190f728f1eee57148872",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午5:12",
      "commitNameOld": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 331,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,49 +1,49 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeParameterUsage((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n+            return new ReferenceTypeUsageImpl(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         WildcardType wildcardType \u003d (WildcardType) type;\n         if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getExtends(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n-            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+            return WildcardUsage.extendsBound((ReferenceTypeUsageImpl) convertToUsage(wildcardType.getSuper(), context));\n         } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n             return WildcardUsage.UNBOUNDED;\n         } else {\n             throw new UnsupportedOperationException();\n         }\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 327,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "03ec309bba14eaf50a32b05353fa9711b831de7f": {
      "type": "Ybodychange",
      "commitMessage": "reimplement WildcardUsage\n",
      "commitDate": "2015/10/31 下午11:01",
      "commitName": "03ec309bba14eaf50a32b05353fa9711b831de7f",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午7:11",
      "commitNameOld": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType \u003d (WildcardType) type;\n        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n            return WildcardUsage.UNBOUNDED;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 336,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,49 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeParameterUsage((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n-        return new WildcardUsage((WildcardType) type);\n+        WildcardType wildcardType \u003d (WildcardType) type;\n+        if (wildcardType.getExtends() !\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getExtends(), context));\n+        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() !\u003d null) {\n+            return WildcardUsage.extendsBound((ReferenceTypeUsage) convertToUsage(wildcardType.getSuper(), context));\n+        } else if (wildcardType.getExtends() \u003d\u003d null \u0026\u0026 wildcardType.getSuper() \u003d\u003d null) {\n+            return WildcardUsage.UNBOUNDED;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fb388c36c0045c50744cf215521e5c280036aa70": {
      "type": "Yfilerename",
      "commitMessage": "move JavaParser specific code to specific package\n",
      "commitDate": "2015/10/31 下午7:11",
      "commitName": "fb388c36c0045c50744cf215521e5c280036aa70",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 下午5:57",
      "commitNameOld": "b2bf624be5d1ef59480250e66224aeaa1886df36",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java",
      "functionStartLine": 336,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/JavaParserFacade.java"
      }
    },
    "1613b8d9cc00da012539ea3db05cdb0cc8153358": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015/10/31 下午5:01",
      "commitName": "1613b8d9cc00da012539ea3db05cdb0cc8153358",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/31 上午6:51",
      "commitNameOld": "adb02497ed443e836ae552e20bcb11ab8c1ab623",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 337,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,40 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n-                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n+                return new TypeParameterUsage((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+                return new TypeParameterUsage(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015/10/31 上午6:37",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午11:43",
      "commitNameOld": "005ec580724781a825aaf08a496ad7f8f667b27f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 337,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,40 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n+            return new ReferenceTypeUsage(typeDeclaration, typeParameters, typeSolver);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b": {
      "type": "Ybodychange",
      "commitMessage": "renaming\n",
      "commitDate": "2015/10/28 下午11:18",
      "commitName": "68aeb576ccb2b44e436d13d0be2660f85dc9ee4b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/27 下午10:40",
      "commitNameOld": "bed91989f7354552d72b2b7f0c28fcbd24fee003",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 62.03,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 316,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,40 +1,40 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n         for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n             typeUsage \u003d new ArrayTypeUsage(typeUsage);\n         }\n         return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n-            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+            return new ReferenceTypeUsage(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eec165d9e3ef0ab1d93f69a231964984a3379762": {
      "type": "Ybodychange",
      "commitMessage": "consider array modifiers\n",
      "commitDate": "2015/8/25 下午5:57",
      "commitName": "eec165d9e3ef0ab1d93f69a231964984a3379762",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午5:05",
      "commitNameOld": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n        }\n        return typeUsage;\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 316,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,36 +1,40 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n-        return convertToUsage(referenceType.getType(), context);\n+        TypeUsage typeUsage \u003d convertToUsage(referenceType.getType(), context);\n+        for (int i \u003d 0; i \u003c referenceType.getArrayCount(); i++) {\n+            typeUsage \u003d new ArrayTypeUsage(typeUsage);\n+        }\n+        return typeUsage;\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         String name \u003d qName(classOrInterfaceType);\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n-        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n+        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee58eb8363ecd8fad15a63eb2fdc94a387b58807": {
      "type": "Ybodychange",
      "commitMessage": "use qualified name when solving types\n",
      "commitDate": "2015/8/25 上午3:57",
      "commitName": "ee58eb8363ecd8fad15a63eb2fdc94a387b58807",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午3:37",
      "commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        String name \u003d qName(classOrInterfaceType);\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(name);\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 323,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,36 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n-        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n+        String name \u003d qName(classOrInterfaceType);\n+        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(name, typeSolver);\n         if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n+            throw new UnsolvedSymbolException(name);\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n         return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "283204dd5840cb11dd6c73dbbb196e80db79c9a4": {
      "type": "Ybodychange",
      "commitMessage": "consider method override\n",
      "commitDate": "2015/8/25 上午3:19",
      "commitName": "283204dd5840cb11dd6c73dbbb196e80db79c9a4",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午2:45",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return VoidTypeUsage.INSTANCE;\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 311,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             if (typeDeclaration instanceof TypeParameter) {\n                 return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n             } else {\n                 JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                 return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n             }\n         } else {\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else if (type instanceof WildcardType) {\n         return new WildcardUsage((WildcardType) type);\n     } else if (type instanceof VoidType) {\n-        return new VoidTypeUsage();\n+        return VoidTypeUsage.INSTANCE;\n     } else {\n         throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f77a169eec5a2e0fdeea1b9d67641426af0e1176": {
      "type": "Ybodychange",
      "commitMessage": "remove JavaParserFacade.convert\n",
      "commitDate": "2015/8/24 下午10:22",
      "commitName": "f77a169eec5a2e0fdeea1b9d67641426af0e1176",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午10:06",
      "commitNameOld": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            if (typeDeclaration instanceof TypeParameter) {\n                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n            } else {\n                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n            }\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else if (type instanceof WildcardType) {\n        return new WildcardUsage((WildcardType) type);\n    } else if (type instanceof VoidType) {\n        return new VoidTypeUsage();\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 307,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,35 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n-            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n-            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+            if (typeDeclaration instanceof TypeParameter) {\n+                return new TypeUsageOfTypeParameter((TypeParameter) typeDeclaration);\n+            } else {\n+                JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n+                return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+            }\n         } else {\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n+    } else if (type instanceof WildcardType) {\n+        return new WildcardUsage((WildcardType) type);\n+    } else if (type instanceof VoidType) {\n+        return new VoidTypeUsage();\n     } else {\n         throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "416e7b16f820700af08a94e4b38a2b4c24ef6a2c": {
      "type": "Ybodychange",
      "commitMessage": "minor corrections for enums\n",
      "commitDate": "2015/8/24 下午10:06",
      "commitName": "416e7b16f820700af08a94e4b38a2b4c24ef6a2c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午9:58",
      "commitNameOld": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 304,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,27 +1,27 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         if (typeDeclaration.isTypeVariable()) {\n             JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n             return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n         } else {\n             return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n         }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else {\n-        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+        throw new UnsupportedOperationException(\"FOO \" + type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1829d9560d37efd59722aaa2f1f22e392918429b": {
      "type": "Ybodychange",
      "commitMessage": "calculate if type variable are assignable\n",
      "commitDate": "2015/8/24 下午9:58",
      "commitName": "1829d9560d37efd59722aaa2f1f22e392918429b",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/24 下午9:26",
      "commitNameOld": "00f005b38e8b83eb1d60db9070c6e9e3beffe403",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        if (typeDeclaration.isTypeVariable()) {\n            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n        } else {\n            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n        }\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 304,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,27 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n-        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+        if (typeDeclaration.isTypeVariable()) {\n+            JavaParserTypeVariableDeclaration javaParserTypeVariableDeclaration \u003d (JavaParserTypeVariableDeclaration) typeDeclaration;\n+            return new TypeUsageOfTypeParameter(javaParserTypeVariableDeclaration.asTypeParameter());\n+        } else {\n+            return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+        }\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0c4c859f472f7243919f1af7a0871cf8155af1ba": {
      "type": "Ybodychange",
      "commitMessage": "add tests for static field access\n",
      "commitDate": "2015/8/22 上午5:00",
      "commitName": "0c4c859f472f7243919f1af7a0871cf8155af1ba",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/22 上午2:45",
      "commitNameOld": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 244,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n-            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+            throw new UnsolvedSymbolException(classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n     } else if (type instanceof PrimitiveType) {\n         return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b6c27e95fef9e725fbf9e15afb852bb952dfa34": {
      "type": "Ybodychange",
      "commitMessage": "first round of cleaning the API\n",
      "commitDate": "2015/8/22 上午2:45",
      "commitName": "7b6c27e95fef9e725fbf9e15afb852bb952dfa34",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/21 下午6:03",
      "commitNameOld": "6d60a91b5d0d29dde1c081d82781fc60011d926d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 205,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,22 +1,22 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n     } else if (type instanceof PrimitiveType) {\n-        return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType) type), Collections.emptyList());\n+        return PrimitiveTypeUsage.byName(((PrimitiveType) type).getType().name());\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1d5332815b543d569be3d7ec672a65b7efc39a04": {
      "type": "Ybodychange",
      "commitMessage": "test ClassOrInterfaceDeclarationContext.solveSymbolAsValue\n",
      "commitDate": "2015/8/18 下午5:15",
      "commitName": "1d5332815b543d569be3d7ec672a65b7efc39a04",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/18 下午3:14",
      "commitNameOld": "3117fab4797fa9aba8b5f8dc596ab70c90c7d548",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else if (type instanceof PrimitiveType) {\n        return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType) type), Collections.emptyList());\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 207,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,22 @@\n public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+    } else if (type instanceof PrimitiveType) {\n+        return new TypeUsageOfTypeDeclaration(new PrimitiveTypeDeclaration((PrimitiveType) type), Collections.emptyList());\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6650e5a3818c15de2883b71cd41524b0337e26f6": {
      "type": "Ymodifierchange",
      "commitMessage": "add test resolveUsageOfGenericFieldAdvancedCase\n",
      "commitDate": "2015/8/5 下午4:09",
      "commitName": "6650e5a3818c15de2883b71cd41524b0337e26f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/4 下午9:54",
      "commitNameOld": "80f951258992f75441239c79e0f31eda7d47e107",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 131,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,20 @@\n-private TypeUsage convertToUsage(Type type, Context context) {\n+public TypeUsage convertToUsage(Type type, Context context) {\n     if (type instanceof ReferenceType) {\n         ReferenceType referenceType \u003d (ReferenceType) type;\n         return convertToUsage(referenceType.getType(), context);\n     } else if (type instanceof ClassOrInterfaceType) {\n         ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n         SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n         if (!ref.isSolved()) {\n             throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n         }\n         TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n         List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n         if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n             typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n         }\n         return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n     } else {\n         throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "2568d9ebe91ceb0a13c98b16f99593cd22084efa": {
      "type": "Yintroduced",
      "commitMessage": "solving first case of generic type\n",
      "commitDate": "2015/8/4 下午5:02",
      "commitName": "2568d9ebe91ceb0a13c98b16f99593cd22084efa",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,20 @@\n+private TypeUsage convertToUsage(Type type, Context context) {\n+    if (type instanceof ReferenceType) {\n+        ReferenceType referenceType \u003d (ReferenceType) type;\n+        return convertToUsage(referenceType.getType(), context);\n+    } else if (type instanceof ClassOrInterfaceType) {\n+        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n+        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n+        if (!ref.isSolved()) {\n+            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n+        }\n+        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n+        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n+        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n+            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n+        }\n+        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n+    } else {\n+        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "private TypeUsage convertToUsage(Type type, Context context) {\n    if (type instanceof ReferenceType) {\n        ReferenceType referenceType \u003d (ReferenceType) type;\n        return convertToUsage(referenceType.getType(), context);\n    } else if (type instanceof ClassOrInterfaceType) {\n        ClassOrInterfaceType classOrInterfaceType \u003d (ClassOrInterfaceType) type;\n        SymbolReference\u003cTypeDeclaration\u003e ref \u003d context.solveType(classOrInterfaceType.getName(), typeSolver);\n        if (!ref.isSolved()) {\n            throw new UnsolvedSymbolException(null, classOrInterfaceType.getName());\n        }\n        TypeDeclaration typeDeclaration \u003d ref.getCorrespondingDeclaration();\n        List\u003cTypeUsage\u003e typeParameters \u003d Collections.emptyList();\n        if (classOrInterfaceType.getTypeArgs() !\u003d null) {\n            typeParameters \u003d classOrInterfaceType.getTypeArgs().stream().map((pt) -\u003e convertToUsage(pt, context)).collect(Collectors.toList());\n        }\n        return new TypeUsageOfTypeDeclaration(typeDeclaration, typeParameters);\n    } else {\n        throw new UnsupportedOperationException(type.getClass().getCanonicalName());\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/JavaParserFacade.java",
      "functionStartLine": 124,
      "functionName": "convertToUsage",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}