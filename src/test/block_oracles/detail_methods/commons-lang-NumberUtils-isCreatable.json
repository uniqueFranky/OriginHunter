{
  "origin": "codeshovel",
  "repositoryName": "commons-lang",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/commons-lang/.git",
  "startCommitName": "a36c903d4f1065bc59f5e6d2bb0f9d92a5e71d83",
  "sourceFileName": "NumberUtils.java",
  "functionName": "isCreatable",
  "functionId": "isCreatable___str-String(modifiers-final)",
  "sourceFilePath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
  "functionAnnotation": "",
  "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5\n",
  "functionStartLine": 1398,
  "functionEndLine": 1509,
  "numCommitsSeen": 180,
  "timeTaken": 3889,
  "changeHistory": [
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
    "c3b1fefbad0c67c8556ba6b4573f135197f87598",
    "8f9271399aca64a6f5afe36d3eec365eb68e310e",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
    "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992",
    "a2d41db55aa46bd4fedb215c978f03e282cf1ffb",
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
    "05763470e5a067eb153533d47baa73174ad9bd46",
    "d16c62aed209aada9868c07e139d2dd48dc81536",
    "21cbe9553f0c1b96493eccc7d5e048358b56d7f3",
    "cf03e6173b70ad64337704402bea51600cddd1ba",
    "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3",
    "9397608dd35a335d5e14813c0923f9419782980a",
    "5a509030a946646780e963b9f492a4eaff734116",
    "5292526e476ffbb19c6613a98464054236c86ace",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db",
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818",
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb"
  ],
  "changeHistoryShort": {
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e": "Ybodychange",
    "c3b1fefbad0c67c8556ba6b4573f135197f87598": "Ymultichange(Ybodychange,Ydocchange)",
    "8f9271399aca64a6f5afe36d3eec365eb68e310e": "Ydocchange",
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": "Ybodychange",
    "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01": "Ydocchange",
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992": "Ybodychange",
    "a2d41db55aa46bd4fedb215c978f03e282cf1ffb": "Ydocchange",
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
    "05763470e5a067eb153533d47baa73174ad9bd46": "Ydocchange",
    "d16c62aed209aada9868c07e139d2dd48dc81536": "Ydocchange",
    "21cbe9553f0c1b96493eccc7d5e048358b56d7f3": "Ydocchange",
    "cf03e6173b70ad64337704402bea51600cddd1ba": "Ybodychange",
    "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3": "Ydocchange",
    "9397608dd35a335d5e14813c0923f9419782980a": "Ybodychange",
    "5a509030a946646780e963b9f492a4eaff734116": "Ybodychange",
    "5292526e476ffbb19c6613a98464054236c86ace": "Ybodychange",
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": "Yparametermetachange",
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818": "Ybodychange",
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036": "Ybodychange",
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": "Yfilerename",
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": "Ybodychange",
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": "Yfilerename",
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0": "Ybodychange",
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": "Ybodychange",
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c8e61afdb89c58ea8ffaf04593da41ff0888d30e": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1060: NumberUtils.isNumber assumes number starting with Zero is octal (closes #313)\n",
      "commitDate": "2018/2/11 下午7:08",
      "commitName": "c8e61afdb89c58ea8ffaf04593da41ff0888d30e",
      "commitAuthor": "Piotr Kosmala",
      "commitDateOld": "2018/2/11 下午6:49",
      "commitNameOld": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
      "commitAuthorOld": "pascalschumacher",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 !StringUtils.contains(str, \u0027.\u0027)) {\n        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1398,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5\n",
      "diff": "@@ -1,87 +1,87 @@\n public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n-    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n+    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 !StringUtils.contains(str, \u0027.\u0027)) {\n         if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c3b1fefbad0c67c8556ba6b4573f135197f87598": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "NumberUtils#isCreatable: remove java 6 only code, as commons-lang requires at java 7+ now\n",
      "commitDate": "2018/2/11 下午6:49",
      "commitName": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
      "commitAuthor": "pascalschumacher",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "NumberUtils#isCreatable: remove java 6 only code, as commons-lang requires at java 7+ now\n",
          "commitDate": "2018/2/11 下午6:49",
          "commitName": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2017/6/6 下午9:12",
          "commitNameOld": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
          "commitAuthorOld": "Benedikt Ritter",
          "daysBetweenCommits": 249.9,
          "commitsBetweenForRepo": 146,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5\n",
          "diff": "@@ -1,91 +1,87 @@\n public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n-    final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n-            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n-                return false;\n-            }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "NumberUtils#isCreatable: remove java 6 only code, as commons-lang requires at java 7+ now\n",
          "commitDate": "2018/2/11 下午6:49",
          "commitName": "c3b1fefbad0c67c8556ba6b4573f135197f87598",
          "commitAuthor": "pascalschumacher",
          "commitDateOld": "2017/6/6 下午9:12",
          "commitNameOld": "1da8ccdbfe2faa3e6801fe44eaf3c336aab48bec",
          "commitAuthorOld": "Benedikt Ritter",
          "daysBetweenCommits": 249.9,
          "commitsBetweenForRepo": 146,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5\n",
          "diff": "@@ -1,91 +1,87 @@\n public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n-    final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n-            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n-                return false;\n-            }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n",
            "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5\n"
          }
        }
      ]
    },
    "8f9271399aca64a6f5afe36d3eec365eb68e310e": {
      "type": "Ydocchange",
      "commitMessage": "fix typo in NumberUtils#isCreatable and NumberUtils#isNumber javadoc\n",
      "commitDate": "2016/10/22 下午8:28",
      "commitName": "8f9271399aca64a6f5afe36d3eec365eb68e310e",
      "commitAuthor": "pascalschumacher",
      "commitDateOld": "2016/9/19 下午7:56",
      "commitNameOld": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 33.02,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resulting in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n"
      }
    },
    "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4": {
      "type": "Ybodychange",
      "commitMessage": "PMD: Remove useless parentheses\n",
      "commitDate": "2016/9/19 下午7:56",
      "commitName": "9c5b6cdc7108eb071785b0c4edd205650cdf1ca4",
      "commitAuthor": "Benedikt Ritter",
      "commitDateOld": "2016/9/12 上午1:00",
      "commitNameOld": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 7.79,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n",
      "diff": "@@ -1,91 +1,91 @@\n public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n-    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n+    final int start \u003d chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027 ? 1 : 0;\n+    final boolean hasLeadingPlusSign \u003d start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n-        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n+        if (chars[start + 1] \u003d\u003d \u0027x\u0027 || chars[start + 1] \u003d\u003d \u0027X\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n-    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n+    while (i \u003c sz || i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                 return false;\n             }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01": {
      "type": "Ydocchange",
      "commitMessage": "LANG-1252: adding @since and notes to changes.xml\n",
      "commitDate": "2016/9/12 上午1:00",
      "commitName": "e64b51c70fa9f5e2795e91e6729ebd895f7f3c01",
      "commitAuthor": "Rob Tompkins",
      "commitDateOld": "2016/9/11 下午10:54",
      "commitNameOld": "b3c31a379e9ad7cd22cb7f0669b82361ced84992",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.5 the code supports the \"+\" suffix on numbers except for integers in Java 1.6\n"
      }
    },
    "b3c31a379e9ad7cd22cb7f0669b82361ced84992": {
      "type": "Ybodychange",
      "commitMessage": "LANG-1252: replacing system call for java 1.6 to SystemUtils.IS_JAVA_1_6\n",
      "commitDate": "2016/9/11 下午10:54",
      "commitName": "b3c31a379e9ad7cd22cb7f0669b82361ced84992",
      "commitAuthor": "Rob Tompkins",
      "commitDateOld": "2016/9/11 上午9:43",
      "commitNameOld": "71d9e00d42b278ce9d216b33bf1a9c8606fbcb49",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 0.55,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1401,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "@@ -1,92 +1,91 @@\n public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n     final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n     final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n-            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+            if (SystemUtils.IS_JAVA_1_6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                 return false;\n             }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a2d41db55aa46bd4fedb215c978f03e282cf1ffb": {
      "type": "Ydocchange",
      "commitMessage": "LANG-1252: Cleaning up checkstyle warnings: whitespace, line length\n",
      "commitDate": "2016/9/11 上午9:41",
      "commitName": "a2d41db55aa46bd4fedb215c978f03e282cf1ffb",
      "commitAuthor": "Rob Tompkins",
      "commitDateOld": "2016/9/11 上午9:01",
      "commitNameOld": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
      "commitAuthorOld": "Rob Tompkins",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1400,
      "functionName": "isCreatable",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and\nnumbers marked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
      }
    },
    "c503d742f094dc2048b72c3f78f5e2e6070a44e1": {
      "type": "Ymultichange(Yrename,Ybodychange,Ydocchange)",
      "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
      "commitDate": "2016/9/11 上午9:01",
      "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
      "commitAuthor": "Rob Tompkins",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
          "commitDate": "2016/9/11 上午9:01",
          "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
          "commitAuthor": "Rob Tompkins",
          "commitDateOld": "2016/6/12 下午7:23",
          "commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
          "commitAuthorOld": "Nick Manley",
          "daysBetweenCommits": 90.57,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
          "diff": "@@ -1,87 +1,92 @@\n-public static boolean isNumber(final String str) {\n+public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n+    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n+    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                return false;\n+            }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "isNumber",
            "newValue": "isCreatable"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
          "commitDate": "2016/9/11 上午9:01",
          "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
          "commitAuthor": "Rob Tompkins",
          "commitDateOld": "2016/6/12 下午7:23",
          "commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
          "commitAuthorOld": "Nick Manley",
          "daysBetweenCommits": 90.57,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
          "diff": "@@ -1,87 +1,92 @@\n-public static boolean isNumber(final String str) {\n+public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n+    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n+    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                return false;\n+            }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LANG-1252: better naming and java 6 specifics around handling a leading +\n",
          "commitDate": "2016/9/11 上午9:01",
          "commitName": "c503d742f094dc2048b72c3f78f5e2e6070a44e1",
          "commitAuthor": "Rob Tompkins",
          "commitDateOld": "2016/6/12 下午7:23",
          "commitNameOld": "8d6bc0ca625f3a1a98b486541fa613b2fac4b41c",
          "commitAuthorOld": "Nick Manley",
          "daysBetweenCommits": 90.57,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "actualSource": "public static boolean isCreatable(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n                return false;\n            }\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
          "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
          "functionStartLine": 1398,
          "functionName": "isCreatable",
          "functionAnnotation": "",
          "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
          "diff": "@@ -1,87 +1,92 @@\n-public static boolean isNumber(final String str) {\n+public static boolean isCreatable(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+    boolean isJava6 \u003d StringUtils.startsWith(System.getProperty(\"java.version\"), \"1.6\");\n+    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027 || chars[0] \u003d\u003d \u0027+\u0027) ? 1 : 0;\n+    final boolean hasLeadingPlusSign \u003d (start \u003d\u003d 1 \u0026\u0026 chars[0] \u003d\u003d \u0027+\u0027);\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+            if (isJava6 \u0026\u0026 hasLeadingPlusSign \u0026\u0026 !hasDecPoint) {\n+                return false;\n+            }\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
            "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNote, {@link #createNumber(String)} should return a number for every\ninput resuling in \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
          }
        }
      ]
    },
    "05763470e5a067eb153533d47baa73174ad9bd46": {
      "type": "Ydocchange",
      "commitMessage": "clarify behavior of #isNumber() with blanks\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1645076 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/12/13 上午5:15",
      "commitName": "05763470e5a067eb153533d47baa73174ad9bd46",
      "commitAuthor": "Matthew Jason Benson",
      "commitDateOld": "2014/12/3 上午9:35",
      "commitNameOld": "0162032aa4ea1084e4bccbce6fbfc48ae4b0cc48",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 9.82,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1354,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003enull\u003c/code\u003e and empty/blank {@code String} will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
      }
    },
    "d16c62aed209aada9868c07e139d2dd48dc81536": {
      "type": "Ydocchange",
      "commitMessage": "Clarify that 0.d is decimal, not octal\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1592931 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/5/7 上午9:20",
      "commitName": "d16c62aed209aada9868c07e139d2dd48dc81536",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/5/7 上午5:32",
      "commitNameOld": "21cbe9553f0c1b96493eccc7d5e048358b56d7f3",
      "commitAuthorOld": "Duncan Jones",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1342,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\nHowever, numbers beginning with {@code 0.} are treated as decimal.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
      }
    },
    "21cbe9553f0c1b96493eccc7d5e048358b56d7f3": {
      "type": "Ydocchange",
      "commitMessage": "Explained treatment of leading zeroes in isNumber() method Javadoc.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1592890 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/5/7 上午5:32",
      "commitName": "21cbe9553f0c1b96493eccc7d5e048358b56d7f3",
      "commitAuthor": "Duncan Jones",
      "commitDateOld": "2014/5/6 上午1:48",
      "commitNameOld": "d910918faf359f8144d4195ead470fd0921554dc",
      "commitAuthorOld": "Benedikt Ritter",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1341,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e or\n\u003ccode\u003e0X\u003c/code\u003e qualifier, octal numbers, scientific notation and numbers \nmarked with a type qualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003eNon-hexadecimal strings beginning with a leading zero are\ntreated as octal values. Thus the string \u003ccode\u003e09\u003c/code\u003e will return\n\u003ccode\u003efalse\u003c/code\u003e, since \u003ccode\u003e9\u003c/code\u003e is not a valid octal value.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
      }
    },
    "cf03e6173b70ad64337704402bea51600cddd1ba": {
      "type": "Ybodychange",
      "commitMessage": "LANG-992 Fix NumberUtils#isNumber() returns false for \"0.0\", \"0.4790\", et al\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1582585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/3/28 上午11:10",
      "commitName": "cf03e6173b70ad64337704402bea51600cddd1ba",
      "commitAuthor": "Niall Pemberton",
      "commitDateOld": "2014/2/11 上午10:57",
      "commitNameOld": "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 45.01,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (Character.isDigit(chars[start + 1])) {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1337,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "@@ -1,87 +1,87 @@\n public static boolean isNumber(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n         if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n-        } else {\n+        } else if (Character.isDigit(chars[start + 1])) {\n             int i \u003d start + 1;\n             for (; i \u003c chars.length; i++) {\n                 if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3": {
      "type": "Ydocchange",
      "commitMessage": "Javadoc update\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566972 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/2/11 上午10:57",
      "commitName": "3269d1bc7a28ba4536d4c1ac5a9aaadf5b8f48c3",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/2/11 上午10:53",
      "commitNameOld": "9397608dd35a335d5e14813c0923f9419782980a",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1337,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
        "newValue": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n@since 3.3 the code supports hex {@code 0Xhhh} and octal {@code 0ddd} validation\n"
      }
    },
    "9397608dd35a335d5e14813c0923f9419782980a": {
      "type": "Ybodychange",
      "commitMessage": "LANG-971 NumberUtils#isNumber(String) fails to reject invalid Octal numbers\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566967 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/2/11 上午10:53",
      "commitName": "9397608dd35a335d5e14813c0923f9419782980a",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/2/11 上午10:34",
      "commitNameOld": "5a509030a946646780e963b9f492a4eaff734116",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            int i \u003d start + 1;\n            for (; i \u003c chars.length; i++) {\n                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1336,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,77 +1,87 @@\n public static boolean isNumber(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027))) {\n-        int i \u003d start + 2;\n-        if (i \u003d\u003d sz) {\n-            return false;\n-        }\n-        for (; i \u003c chars.length; i++) {\n-            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027) {\n+        if ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027)) {\n+            int i \u003d start + 2;\n+            if (i \u003d\u003d sz) {\n                 return false;\n             }\n+            for (; i \u003c chars.length; i++) {\n+                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } else {\n+            int i \u003d start + 1;\n+            for (; i \u003c chars.length; i++) {\n+                if (chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00277\u0027) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n-        return true;\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5a509030a946646780e963b9f492a4eaff734116": {
      "type": "Ybodychange",
      "commitMessage": "LANG-972 NumberUtils#isNumber does not allow for hex 0XABCD\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1566963 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/2/11 上午10:34",
      "commitName": "5a509030a946646780e963b9f492a4eaff734116",
      "commitAuthor": "Sebastian Bazley",
      "commitDateOld": "2014/2/6 下午9:29",
      "commitNameOld": "5a001837b4ae6ca3b55f61179577f6d1d8f38d37",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 4.55,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027))) {\n        int i \u003d start + 2;\n        if (i \u003d\u003d sz) {\n            return false;\n        }\n        for (; i \u003c chars.length; i++) {\n            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1336,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,77 +1,77 @@\n public static boolean isNumber(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 ((chars[start + 1] \u003d\u003d \u0027x\u0027) || (chars[start + 1] \u003d\u003d \u0027X\u0027))) {\n         int i \u003d start + 2;\n         if (i \u003d\u003d sz) {\n             return false;\n         }\n         for (; i \u003c chars.length; i++) {\n             if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5292526e476ffbb19c6613a98464054236c86ace": {
      "type": "Ybodychange",
      "commitMessage": "Add final modifier to local variables.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:09",
      "commitName": "5292526e476ffbb19c6613a98464054236c86ace",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2013/1/22 下午3:07",
      "commitNameOld": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    final char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n        int i \u003d start + 2;\n        if (i \u003d\u003d sz) {\n            return false;\n        }\n        for (; i \u003c chars.length; i++) {\n            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1310,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,77 +1,77 @@\n public static boolean isNumber(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n-    char[] chars \u003d str.toCharArray();\n+    final char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n-    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+    final int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n         int i \u003d start + 2;\n         if (i \u003d\u003d sz) {\n             return false;\n         }\n         for (; i \u003c chars.length; i++) {\n             if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5bd622dab027ef37001a630a7c825c5b8c19d1db": {
      "type": "Yparametermetachange",
      "commitMessage": "Add final modifier to method parameters.\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1436768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/1/22 下午3:07",
      "commitName": "5bd622dab027ef37001a630a7c825c5b8c19d1db",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2012/11/13 下午9:21",
      "commitNameOld": "f5a83bb90cf7b318ac72823e6b99d01d060abe41",
      "commitAuthorOld": "Sebastian Bazley",
      "daysBetweenCommits": 69.74,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n        int i \u003d start + 2;\n        if (i \u003d\u003d sz) {\n            return false;\n        }\n        for (; i \u003c chars.length; i++) {\n            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1310,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,77 +1,77 @@\n-public static boolean isNumber(String str) {\n+public static boolean isNumber(final String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n         int i \u003d start + 2;\n         if (i \u003d\u003d sz) {\n             return false;\n         }\n         for (; i \u003c chars.length; i++) {\n             if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                 return false;\n             }\n         }\n         return true;\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[str-String]",
        "newValue": "[str-String(modifiers-final)]"
      }
    },
    "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD issues: \"These nested if statements could be combined\"\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1153241 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/8/3 上午2:49",
      "commitName": "2b5f7a79b0fc561a0dee8dddc46e31c2c8bf6818",
      "commitAuthor": "Gary D. Gregory",
      "commitDateOld": "2011/7/20 上午4:53",
      "commitNameOld": "2c3fa8366e133200d2a6e0c7f309a876ff9b8675",
      "commitAuthorOld": "Gary D. Gregory",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n        int i \u003d start + 2;\n        if (i \u003d\u003d sz) {\n            return false;\n        }\n        for (; i \u003c chars.length; i++) {\n            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1311,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,79 +1,77 @@\n public static boolean isNumber(String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n-    if (sz \u003e start + 1) {\n-        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n-            int i \u003d start + 2;\n-            if (i \u003d\u003d sz) {\n+    if (sz \u003e start + 1 \u0026\u0026 chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+        int i \u003d start + 2;\n+        if (i \u003d\u003d sz) {\n+            return false;\n+        }\n+        for (; i \u003c chars.length; i++) {\n+            if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                 return false;\n             }\n-            for (; i \u003c chars.length; i++) {\n-                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n         }\n+        return true;\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036": {
      "type": "Ybodychange",
      "commitMessage": "Fixing NumberUtils.isNumber so that 1.1L is not considered a number. LANG-664\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1054202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/1/1 下午2:56",
      "commitName": "8e2f4ddb9a1ecd7a1bf7d752c2c891d630287036",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2010/8/3 下午12:41",
      "commitNameOld": "50c1fdecb4ed33ec1bb0d449f294c299d5369701",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 151.09,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1319,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,79 +1,79 @@\n public static boolean isNumber(String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1) {\n         if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             return foundDigit;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n-            return foundDigit \u0026\u0026 !hasExp;\n+            return foundDigit \u0026\u0026 !hasExp \u0026\u0026 !hasDecPoint;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc5c081e22a61bb5a6810af302be3f22f7966df4": {
      "type": "Yfilerename",
      "commitMessage": "Move main source to src/main/java\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@895322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/1/3 上午10:11",
      "commitName": "fc5c081e22a61bb5a6810af302be3f22f7966df4",
      "commitAuthor": "Paul C. Benedict Jr",
      "commitDateOld": "2010/1/3 上午10:09",
      "commitNameOld": "6b32246f5f9f77c74b32a5290cdbdd4e0f5c71c6",
      "commitAuthorOld": "Paul C. Benedict Jr",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
        "newPath": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "26bc3fe010d5154d3ccac526ec22c429fc3af499": {
      "type": "Ybodychange",
      "commitMessage": "isNumber(String) and createNumber(String) both modified to support \"2.\". LANG-521\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@893088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/22 下午2:52",
      "commitName": "26bc3fe010d5154d3ccac526ec22c429fc3af499",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:56",
      "commitNameOld": "c6e8f706dc7a236cc2a49f979d857ee92d0abd7c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            return foundDigit;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,73 +1,79 @@\n public static boolean isNumber(String str) {\n     if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1) {\n         if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n+        if (chars[i] \u003d\u003d \u0027.\u0027) {\n+            if (hasDecPoint || hasExp) {\n+                return false;\n+            }\n+            return foundDigit;\n+        }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "debc02c6d9b94c717b4182ae4dd7a97d47293a52": {
      "type": "Yfilerename",
      "commitMessage": "Changing directory name from lang to lang3. Build will fail (probably) until Java code is changed in subsequent commit. LANG-563\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@889202 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/10 下午7:33",
      "commitName": "debc02c6d9b94c717b4182ae4dd7a97d47293a52",
      "commitAuthor": "Henri Yandell",
      "commitDateOld": "2009/12/10 下午7:31",
      "commitNameOld": "375d7d0954cae60c4c7292cc65abbc972178857c",
      "commitAuthorOld": "Henri Yandell",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/java/org/apache/commons/lang3/math/NumberUtils.java",
      "functionStartLine": 1312,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/commons/lang/math/NumberUtils.java",
        "newPath": "src/java/org/apache/commons/lang3/math/NumberUtils.java"
      }
    },
    "0531f837cba9ad5a34b12f26310f05f593b3b7e0": {
      "type": "Ybodychange",
      "commitMessage": "Using StringUtils.isEmpty() when testing Strings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137705 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/11/5 上午4:26",
      "commitName": "0531f837cba9ad5a34b12f26310f05f593b3b7e0",
      "commitAuthor": "Fredrik Westermarck",
      "commitDateOld": "2003/9/24 上午1:02",
      "commitNameOld": "c978c7f029c19a87cf14b4af9a3dc22b812c5190",
      "commitAuthorOld": "Fredrik Westermarck",
      "daysBetweenCommits": 42.14,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 1341,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "@@ -1,73 +1,73 @@\n public static boolean isNumber(String str) {\n-    if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n+    if (StringUtils.isEmpty(str)) {\n         return false;\n     }\n     char[] chars \u003d str.toCharArray();\n     int sz \u003d chars.length;\n     boolean hasExp \u003d false;\n     boolean hasDecPoint \u003d false;\n     boolean allowSigns \u003d false;\n     boolean foundDigit \u003d false;\n     int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n     if (sz \u003e start + 1) {\n         if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n             int i \u003d start + 2;\n             if (i \u003d\u003d sz) {\n                 return false;\n             }\n             for (; i \u003c chars.length; i++) {\n                 if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n     }\n     sz--;\n     int i \u003d start;\n     while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             foundDigit \u003d true;\n             allowSigns \u003d false;\n         } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n             if (hasDecPoint || hasExp) {\n                 return false;\n             }\n             hasDecPoint \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             if (hasExp) {\n                 return false;\n             }\n             if (!foundDigit) {\n                 return false;\n             }\n             hasExp \u003d true;\n             allowSigns \u003d true;\n         } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n             if (!allowSigns) {\n                 return false;\n             }\n             allowSigns \u003d false;\n             foundDigit \u003d false;\n         } else {\n             return false;\n         }\n         i++;\n     }\n     if (i \u003c chars.length) {\n         if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n             return true;\n         }\n         if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n             return false;\n         }\n         if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n             return foundDigit;\n         }\n         if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n             return foundDigit \u0026\u0026 !hasExp;\n         }\n         return false;\n     }\n     return !allowSigns \u0026\u0026 foundDigit;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c": {
      "type": "Ybodychange",
      "commitMessage": "Fixed typos in javadoc and some inline comments.\nPr #22908.\nPatch submitted by Janek Bogucki.\nReviewed by Phil Steitz.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/9/7 下午10:32",
      "commitName": "fd3bd5bdd2ef9f6dd184a2d3c587d1a73e19334c",
      "commitAuthor": "Phil Steitz",
      "commitDateOld": "2003/9/5 下午11:55",
      "commitNameOld": "69b8f445d74f22ba99a75c47a38d97d5e85248cc",
      "commitAuthorOld": "Phil Steitz",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static boolean isNumber(String str) {\n    if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 1243,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n",
      "diff": "",
      "extendedDetails": {}
    },
    "2d06a7ce861432fc702168fd4c94bc00ddfc39eb": {
      "type": "Yintroduced",
      "commitMessage": "NumberUtils moved to math subpackage\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/lang/trunk@137379 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2003/6/25 上午5:14",
      "commitName": "2d06a7ce861432fc702168fd4c94bc00ddfc39eb",
      "commitAuthor": "Stephen Colebourne",
      "diff": "@@ -0,0 +1,73 @@\n+public static boolean isNumber(String str) {\n+    if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n+        return false;\n+    }\n+    char[] chars \u003d str.toCharArray();\n+    int sz \u003d chars.length;\n+    boolean hasExp \u003d false;\n+    boolean hasDecPoint \u003d false;\n+    boolean allowSigns \u003d false;\n+    boolean foundDigit \u003d false;\n+    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n+    if (sz \u003e start + 1) {\n+        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n+            int i \u003d start + 2;\n+            if (i \u003d\u003d sz) {\n+                return false;\n+            }\n+            for (; i \u003c chars.length; i++) {\n+                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    sz--;\n+    int i \u003d start;\n+    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n+        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+            foundDigit \u003d true;\n+            allowSigns \u003d false;\n+        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n+            if (hasDecPoint || hasExp) {\n+                return false;\n+            }\n+            hasDecPoint \u003d true;\n+        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n+            if (hasExp) {\n+                return false;\n+            }\n+            if (!foundDigit) {\n+                return false;\n+            }\n+            hasExp \u003d true;\n+            allowSigns \u003d true;\n+        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n+            if (!allowSigns) {\n+                return false;\n+            }\n+            allowSigns \u003d false;\n+            foundDigit \u003d false;\n+        } else {\n+            return false;\n+        }\n+        i++;\n+    }\n+    if (i \u003c chars.length) {\n+        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n+            return true;\n+        }\n+        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n+            return false;\n+        }\n+        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n+            return foundDigit;\n+        }\n+        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n+            return foundDigit \u0026\u0026 !hasExp;\n+        }\n+        return false;\n+    }\n+    return !allowSigns \u0026\u0026 foundDigit;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static boolean isNumber(String str) {\n    if ((str \u003d\u003d null) || (str.length() \u003d\u003d 0)) {\n        return false;\n    }\n    char[] chars \u003d str.toCharArray();\n    int sz \u003d chars.length;\n    boolean hasExp \u003d false;\n    boolean hasDecPoint \u003d false;\n    boolean allowSigns \u003d false;\n    boolean foundDigit \u003d false;\n    int start \u003d (chars[0] \u003d\u003d \u0027-\u0027) ? 1 : 0;\n    if (sz \u003e start + 1) {\n        if (chars[start] \u003d\u003d \u00270\u0027 \u0026\u0026 chars[start + 1] \u003d\u003d \u0027x\u0027) {\n            int i \u003d start + 2;\n            if (i \u003d\u003d sz) {\n                return false;\n            }\n            for (; i \u003c chars.length; i++) {\n                if ((chars[i] \u003c \u00270\u0027 || chars[i] \u003e \u00279\u0027) \u0026\u0026 (chars[i] \u003c \u0027a\u0027 || chars[i] \u003e \u0027f\u0027) \u0026\u0026 (chars[i] \u003c \u0027A\u0027 || chars[i] \u003e \u0027F\u0027)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    sz--;\n    int i \u003d start;\n    while (i \u003c sz || (i \u003c sz + 1 \u0026\u0026 allowSigns \u0026\u0026 !foundDigit)) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            foundDigit \u003d true;\n            allowSigns \u003d false;\n        } else if (chars[i] \u003d\u003d \u0027.\u0027) {\n            if (hasDecPoint || hasExp) {\n                return false;\n            }\n            hasDecPoint \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            if (hasExp) {\n                return false;\n            }\n            if (!foundDigit) {\n                return false;\n            }\n            hasExp \u003d true;\n            allowSigns \u003d true;\n        } else if (chars[i] \u003d\u003d \u0027+\u0027 || chars[i] \u003d\u003d \u0027-\u0027) {\n            if (!allowSigns) {\n                return false;\n            }\n            allowSigns \u003d false;\n            foundDigit \u003d false;\n        } else {\n            return false;\n        }\n        i++;\n    }\n    if (i \u003c chars.length) {\n        if (chars[i] \u003e\u003d \u00270\u0027 \u0026\u0026 chars[i] \u003c\u003d \u00279\u0027) {\n            return true;\n        }\n        if (chars[i] \u003d\u003d \u0027e\u0027 || chars[i] \u003d\u003d \u0027E\u0027) {\n            return false;\n        }\n        if (!allowSigns \u0026\u0026 (chars[i] \u003d\u003d \u0027d\u0027 || chars[i] \u003d\u003d \u0027D\u0027 || chars[i] \u003d\u003d \u0027f\u0027 || chars[i] \u003d\u003d \u0027F\u0027)) {\n            return foundDigit;\n        }\n        if (chars[i] \u003d\u003d \u0027l\u0027 || chars[i] \u003d\u003d \u0027L\u0027) {\n            return foundDigit \u0026\u0026 !hasExp;\n        }\n        return false;\n    }\n    return !allowSigns \u0026\u0026 foundDigit;\n}",
      "path": "src/java/org/apache/commons/lang/math/NumberUtils.java",
      "functionStartLine": 803,
      "functionName": "isNumber",
      "functionAnnotation": "",
      "functionDoc": "\u003cp\u003eChecks whether the String a valid Java number.\u003c/p\u003e\n\n\u003cp\u003eValid numbers include hexadecimal marked with the \u003ccode\u003e0x\u003c/code\u003e\nqualifier, scientific notation and numbers marked with a type\nqualifier (e.g. 123L).\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eNull\u003c/code\u003e and empty String will return\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n@param str the \u003ccode\u003eString\u003c/code\u003e to check\n@return \u003ccode\u003etrue\u003c/code\u003e if the string is a correctly formatted number\n"
    }
  }
}