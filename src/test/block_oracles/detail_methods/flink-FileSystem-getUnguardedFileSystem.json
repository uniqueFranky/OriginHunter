{
  "origin": "codeshovel",
  "repositoryName": "flink",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/flink/.git",
  "startCommitName": "9e936a5f8198b0059e9b5fba33163c2bbe3efbdd",
  "sourceFileName": "FileSystem.java",
  "functionName": "getUnguardedFileSystem",
  "functionId": "getUnguardedFileSystem___fsUri-URI(modifiers-final)",
  "sourceFilePath": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
  "functionAnnotation": "@Internal",
  "functionDoc": "",
  "functionStartLine": 322,
  "functionEndLine": 415,
  "numCommitsSeen": 143,
  "timeTaken": 7806,
  "changeHistory": [
    "d7c2c417213502130b1aeab1868313df178555cc",
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7",
    "19ef82cf358da54bf204e678bf203f25147b11f9",
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
    "1c8d866a83065e3d1bc9707dab81117f24c9f678",
    "2af658673f877a7e0fd73fdd2907f88824d793a5",
    "39fb7c945359465ce5241539559daac416e210b8",
    "f2909293cbb37cc4b4516e3bef4db66376159e52",
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a",
    "8563d511da8ab8ac0e1362775f11aef7b67375be",
    "24eb47ac86299920aa137d5b6394a248ff58d19e",
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8",
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
    "3a6344356a185be43f9be4b33702f97827f9ff96",
    "fc6b5168684ca298d8b025c839d9a4e48e470790",
    "33cb2ca9898809d2fc90765996ea56bbea458e59",
    "88d7305a5267aac598949519275123208195daf7",
    "d0c21f4c470812d699ec141210ad5119b3450de3",
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
    "75e67a701cbabe5577967037c0e865d1c2e9a25b"
  ],
  "changeHistoryShort": {
    "d7c2c417213502130b1aeab1868313df178555cc": "Ybodychange",
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff": "Ymultichange(Yparameterchange,Ybodychange)",
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7": "Ybodychange",
    "19ef82cf358da54bf204e678bf203f25147b11f9": "Yannotationchange",
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed": "Ymultichange(Yrename,Ydocchange)",
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76": "Ybodychange",
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e": "Ybodychange",
    "1c8d866a83065e3d1bc9707dab81117f24c9f678": "Ybodychange",
    "2af658673f877a7e0fd73fdd2907f88824d793a5": "Ybodychange",
    "39fb7c945359465ce5241539559daac416e210b8": "Ybodychange",
    "f2909293cbb37cc4b4516e3bef4db66376159e52": "Ybodychange",
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af": "Ybodychange",
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c": "Ybodychange",
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a": "Ybodychange",
    "8563d511da8ab8ac0e1362775f11aef7b67375be": "Yfilerename",
    "24eb47ac86299920aa137d5b6394a248ff58d19e": "Ymovefromfile",
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8": "Ybodychange",
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22": "Ymultichange(Ybodychange,Yparametermetachange)",
    "3a6344356a185be43f9be4b33702f97827f9ff96": "Ybodychange",
    "fc6b5168684ca298d8b025c839d9a4e48e470790": "Yfilerename",
    "33cb2ca9898809d2fc90765996ea56bbea458e59": "Yfilerename",
    "88d7305a5267aac598949519275123208195daf7": "Ybodychange",
    "d0c21f4c470812d699ec141210ad5119b3450de3": "Ybodychange",
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3": "Yparametermetachange",
    "75e67a701cbabe5577967037c0e865d1c2e9a25b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d7c2c417213502130b1aeab1868313df178555cc": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-8125] [core] Introduce limiting of outgoing file system connections\n",
      "commitDate": "2017/11/24 下午6:41",
      "commitName": "d7c2c417213502130b1aeab1868313df178555cc",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2017/11/24 下午6:41",
      "commitNameOld": "f04b32b02900181db82c6c518ffbd6430a0a369a",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Internal\npublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n    checkNotNull(fsUri, \"file system URI\");\n    LOCK.lock();\n    try {\n        final URI uri;\n        if (fsUri.getScheme() !\u003d null) {\n            uri \u003d fsUri;\n        } else {\n            final URI defaultUri \u003d getDefaultFsUri();\n            URI rewrittenUri \u003d null;\n            try {\n                rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                if (defaultUri.getScheme().equals(\"file\")) {\n                    try {\n                        rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    } catch (URISyntaxException ignored) {\n                    }\n                }\n            }\n            if (rewrittenUri !\u003d null) {\n                uri \u003d rewrittenUri;\n            } else {\n                throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        {\n            FileSystem cached \u003d CACHE.get(key);\n            if (cached !\u003d null) {\n                return cached;\n            }\n        }\n        if (FS_FACTORIES.isEmpty()) {\n            initialize(new Configuration());\n        }\n        final FileSystem fs;\n        final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n        if (factory !\u003d null) {\n            fs \u003d factory.create(uri);\n        } else {\n            try {\n                fs \u003d FALLBACK_FACTORY.create(uri);\n            } catch (UnsupportedFileSystemSchemeException e) {\n                throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n            }\n        }\n        CACHE.put(key, fs);\n        return fs;\n    } finally {\n        LOCK.unlock();\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 322,
      "functionName": "getUnguardedFileSystem",
      "functionAnnotation": "@Internal",
      "functionDoc": "",
      "diff": "@@ -1,55 +1,58 @@\n @Internal\n public static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n     checkNotNull(fsUri, \"file system URI\");\n     LOCK.lock();\n     try {\n         final URI uri;\n         if (fsUri.getScheme() !\u003d null) {\n             uri \u003d fsUri;\n         } else {\n             final URI defaultUri \u003d getDefaultFsUri();\n             URI rewrittenUri \u003d null;\n             try {\n                 rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 if (defaultUri.getScheme().equals(\"file\")) {\n                     try {\n                         rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     } catch (URISyntaxException ignored) {\n                     }\n                 }\n             }\n             if (rewrittenUri !\u003d null) {\n                 uri \u003d rewrittenUri;\n             } else {\n                 throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         {\n             FileSystem cached \u003d CACHE.get(key);\n             if (cached !\u003d null) {\n                 return cached;\n             }\n         }\n+        if (FS_FACTORIES.isEmpty()) {\n+            initialize(new Configuration());\n+        }\n         final FileSystem fs;\n         final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n         if (factory !\u003d null) {\n             fs \u003d factory.create(uri);\n         } else {\n             try {\n                 fs \u003d FALLBACK_FACTORY.create(uri);\n             } catch (UnsupportedFileSystemSchemeException e) {\n                 throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n             }\n         }\n         CACHE.put(key, fs);\n         return fs;\n     } finally {\n         LOCK.unlock();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "536675b03a5050fda9c3e1fd403818cb50dcc6ff": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
      "commitDate": "2017/10/6 下午5:16",
      "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
      "commitAuthor": "Stephan Ewen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
          "commitDate": "2017/10/6 下午5:16",
          "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2017/10/6 上午1:14",
          "commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
          "commitAuthorOld": "Stephan Ewen",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Internal\npublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n    checkNotNull(fsUri, \"file system URI\");\n    LOCK.lock();\n    try {\n        final URI uri;\n        if (fsUri.getScheme() !\u003d null) {\n            uri \u003d fsUri;\n        } else {\n            final URI defaultUri \u003d getDefaultFsUri();\n            URI rewrittenUri \u003d null;\n            try {\n                rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                if (defaultUri.getScheme().equals(\"file\")) {\n                    try {\n                        rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    } catch (URISyntaxException ignored) {\n                    }\n                }\n            }\n            if (rewrittenUri !\u003d null) {\n                uri \u003d rewrittenUri;\n            } else {\n                throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        {\n            FileSystem cached \u003d CACHE.get(key);\n            if (cached !\u003d null) {\n                return cached;\n            }\n        }\n        final FileSystem fs;\n        final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n        if (factory !\u003d null) {\n            fs \u003d factory.create(uri);\n        } else {\n            try {\n                fs \u003d FALLBACK_FACTORY.create(uri);\n            } catch (UnsupportedFileSystemSchemeException e) {\n                throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n            }\n        }\n        CACHE.put(key, fs);\n        return fs;\n    } finally {\n        LOCK.unlock();\n    }\n}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 309,
          "functionName": "getUnguardedFileSystem",
          "functionAnnotation": "@Internal",
          "functionDoc": "",
          "diff": "@@ -1,61 +1,55 @@\n @Internal\n-public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-    final URI asked \u003d uri;\n+public static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+    checkNotNull(fsUri, \"file system URI\");\n     LOCK.lock();\n     try {\n-        if (uri.getScheme() \u003d\u003d null) {\n+        final URI uri;\n+        if (fsUri.getScheme() !\u003d null) {\n+            uri \u003d fsUri;\n+        } else {\n+            final URI defaultUri \u003d getDefaultFsUri();\n+            URI rewrittenUri \u003d null;\n             try {\n-                if (defaultScheme \u003d\u003d null) {\n-                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-                }\n-                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n+                rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n-                try {\n-                    if (defaultScheme.getScheme().equals(\"file\")) {\n-                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                if (defaultUri.getScheme().equals(\"file\")) {\n+                    try {\n+                        rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                    } catch (URISyntaxException ignored) {\n                     }\n-                } catch (URISyntaxException ex) {\n-                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n-        }\n-        if (uri.getScheme() \u003d\u003d null) {\n-            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n+            if (rewrittenUri !\u003d null) {\n+                uri \u003d rewrittenUri;\n+            } else {\n+                throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n+            }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n-        if (CACHE.containsKey(key)) {\n-            return CACHE.get(key);\n+        {\n+            FileSystem cached \u003d CACHE.get(key);\n+            if (cached !\u003d null) {\n+                return cached;\n+            }\n         }\n         final FileSystem fs;\n-        if (!isFlinkSupportedScheme(uri.getScheme())) {\n-            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-            if (wrapperClass !\u003d null) {\n-                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-                if (CACHE.containsKey(wrappedKey)) {\n-                    return CACHE.get(wrappedKey);\n-                }\n-                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n-                fs.initialize(uri);\n-                CACHE.put(wrappedKey, fs);\n-            } else {\n-                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n-            }\n+        final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n+        if (factory !\u003d null) {\n+            fs \u003d factory.create(uri);\n         } else {\n-            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n-            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-                fs \u003d instantiateHadoopFileSystemWrapper(null);\n-            } else {\n-                fs \u003d instantiateFileSystem(fsClass);\n+            try {\n+                fs \u003d FALLBACK_FACTORY.create(uri);\n+            } catch (UnsupportedFileSystemSchemeException e) {\n+                throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n             }\n-            fs.initialize(uri);\n-            CACHE.put(key, fs);\n         }\n+        CACHE.put(key, fs);\n         return fs;\n     } finally {\n         LOCK.unlock();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI]",
            "newValue": "[fsUri-URI(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "[FLINK-7643] [core] Rework FileSystem loading to use factories\n\nThis makes sure that configurations are loaded once and file system instances are\nproperly reused by scheme and authority.\n\nThis also factors out a lot of the special treatment of Hadoop file systems and simply\nmakes the Hadoop File System factory the default fallback factory.\n",
          "commitDate": "2017/10/6 下午5:16",
          "commitName": "536675b03a5050fda9c3e1fd403818cb50dcc6ff",
          "commitAuthor": "Stephan Ewen",
          "commitDateOld": "2017/10/6 上午1:14",
          "commitNameOld": "a5ef09bb601cdd77fcb94e9ce633fdf979031aaf",
          "commitAuthorOld": "Stephan Ewen",
          "daysBetweenCommits": 0.67,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Internal\npublic static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n    checkNotNull(fsUri, \"file system URI\");\n    LOCK.lock();\n    try {\n        final URI uri;\n        if (fsUri.getScheme() !\u003d null) {\n            uri \u003d fsUri;\n        } else {\n            final URI defaultUri \u003d getDefaultFsUri();\n            URI rewrittenUri \u003d null;\n            try {\n                rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                if (defaultUri.getScheme().equals(\"file\")) {\n                    try {\n                        rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    } catch (URISyntaxException ignored) {\n                    }\n                }\n            }\n            if (rewrittenUri !\u003d null) {\n                uri \u003d rewrittenUri;\n            } else {\n                throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        {\n            FileSystem cached \u003d CACHE.get(key);\n            if (cached !\u003d null) {\n                return cached;\n            }\n        }\n        final FileSystem fs;\n        final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n        if (factory !\u003d null) {\n            fs \u003d factory.create(uri);\n        } else {\n            try {\n                fs \u003d FALLBACK_FACTORY.create(uri);\n            } catch (UnsupportedFileSystemSchemeException e) {\n                throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n            }\n        }\n        CACHE.put(key, fs);\n        return fs;\n    } finally {\n        LOCK.unlock();\n    }\n}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 309,
          "functionName": "getUnguardedFileSystem",
          "functionAnnotation": "@Internal",
          "functionDoc": "",
          "diff": "@@ -1,61 +1,55 @@\n @Internal\n-public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-    final URI asked \u003d uri;\n+public static FileSystem getUnguardedFileSystem(final URI fsUri) throws IOException {\n+    checkNotNull(fsUri, \"file system URI\");\n     LOCK.lock();\n     try {\n-        if (uri.getScheme() \u003d\u003d null) {\n+        final URI uri;\n+        if (fsUri.getScheme() !\u003d null) {\n+            uri \u003d fsUri;\n+        } else {\n+            final URI defaultUri \u003d getDefaultFsUri();\n+            URI rewrittenUri \u003d null;\n             try {\n-                if (defaultScheme \u003d\u003d null) {\n-                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n-                }\n-                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n+                rewrittenUri \u003d new URI(defaultUri.getScheme(), null, defaultUri.getHost(), defaultUri.getPort(), fsUri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n-                try {\n-                    if (defaultScheme.getScheme().equals(\"file\")) {\n-                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                if (defaultUri.getScheme().equals(\"file\")) {\n+                    try {\n+                        rewrittenUri \u003d new URI(\"file\", null, new Path(new File(fsUri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                    } catch (URISyntaxException ignored) {\n                     }\n-                } catch (URISyntaxException ex) {\n-                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n-        }\n-        if (uri.getScheme() \u003d\u003d null) {\n-            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n+            if (rewrittenUri !\u003d null) {\n+                uri \u003d rewrittenUri;\n+            } else {\n+                throw new IOException(\"The file system URI \u0027\" + fsUri + \"\u0027 declares no scheme and cannot be interpreted relative to the default file system URI (\" + defaultUri + \").\");\n+            }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n-        if (CACHE.containsKey(key)) {\n-            return CACHE.get(key);\n+        {\n+            FileSystem cached \u003d CACHE.get(key);\n+            if (cached !\u003d null) {\n+                return cached;\n+            }\n         }\n         final FileSystem fs;\n-        if (!isFlinkSupportedScheme(uri.getScheme())) {\n-            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n-            if (wrapperClass !\u003d null) {\n-                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n-                if (CACHE.containsKey(wrappedKey)) {\n-                    return CACHE.get(wrappedKey);\n-                }\n-                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n-                fs.initialize(uri);\n-                CACHE.put(wrappedKey, fs);\n-            } else {\n-                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n-            }\n+        final FileSystemFactory factory \u003d FS_FACTORIES.get(uri.getScheme());\n+        if (factory !\u003d null) {\n+            fs \u003d factory.create(uri);\n         } else {\n-            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n-            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n-                fs \u003d instantiateHadoopFileSystemWrapper(null);\n-            } else {\n-                fs \u003d instantiateFileSystem(fsClass);\n+            try {\n+                fs \u003d FALLBACK_FACTORY.create(uri);\n+            } catch (UnsupportedFileSystemSchemeException e) {\n+                throw new UnsupportedFileSystemSchemeException(\"Could not find a file system implementation for scheme \u0027\" + uri.getScheme() + \"\u0027. The scheme is not directly supported by Flink and no Hadoop file \" + \"system to support this scheme could be loaded.\", e);\n             }\n-            fs.initialize(uri);\n-            CACHE.put(key, fs);\n         }\n+        CACHE.put(key, fs);\n         return fs;\n     } finally {\n         LOCK.unlock();\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-7643] [core] Misc. cleanups in FileSystem\n\n  - Simplify access to local file system\n  - Use a fair lock for all FileSystem.get() operations\n  - Robust falback to local fs for default scheme (avoids URI parsing error on Windows)\n  - Deprecate \u0027getDefaultBlockSize()\u0027\n  - Deprecate create(...) with block sizes and replication factor, which is not applicable to many FS\n",
      "commitDate": "2017/10/6 上午1:14",
      "commitName": "3b786844dd9c0ce176eac98c8a05ebe50cb1ebe7",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2017/2/20 上午8:01",
      "commitNameOld": "5902ea0e88c70f330c23b9ace94033ae34c84445",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 227.72,
      "commitsBetweenForRepo": 1498,
      "commitsBetweenForFile": 1,
      "actualSource": "@Internal\npublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n    final URI asked \u003d uri;\n    LOCK.lock();\n    try {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        final FileSystem fs;\n        if (!isFlinkSupportedScheme(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n        return fs;\n    } finally {\n        LOCK.unlock();\n    }\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 300,
      "functionName": "getUnguardedFileSystem",
      "functionAnnotation": "@Internal",
      "functionDoc": "",
      "diff": "@@ -1,58 +1,61 @@\n @Internal\n public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n-    FileSystem fs;\n-    URI asked \u003d uri;\n-    synchronized (SYNCHRONIZATION_OBJECT) {\n+    final URI asked \u003d uri;\n+    LOCK.lock();\n+    try {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 if (defaultScheme \u003d\u003d null) {\n                     defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                 }\n                 uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n                     if (defaultScheme.getScheme().equals(\"file\")) {\n                         uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     }\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n+        final FileSystem fs;\n         if (!isFlinkSupportedScheme(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n+        return fs;\n+    } finally {\n+        LOCK.unlock();\n     }\n-    return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "19ef82cf358da54bf204e678bf203f25147b11f9": {
      "type": "Yannotationchange",
      "commitMessage": "[FLINK-5617] Mark some methods as PublicEvolving or Internal\n\nThis closes #3195\n",
      "commitDate": "2017/1/24 下午7:01",
      "commitName": "19ef82cf358da54bf204e678bf203f25147b11f9",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2016/12/14 下午7:43",
      "commitNameOld": "2f3ad58b7b73463aa1827baef0eb2e9d87fdb882",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 40.97,
      "commitsBetweenForRepo": 396,
      "commitsBetweenForFile": 1,
      "actualSource": "@Internal\npublic static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n    FileSystem fs;\n    URI asked \u003d uri;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!isFlinkSupportedScheme(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 207,
      "functionName": "getUnguardedFileSystem",
      "functionAnnotation": "@Internal",
      "functionDoc": "",
      "diff": "@@ -1,57 +1,58 @@\n+@Internal\n public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n     FileSystem fs;\n     URI asked \u003d uri;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 if (defaultScheme \u003d\u003d null) {\n                     defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                 }\n                 uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n                     if (defaultScheme.getScheme().equals(\"file\")) {\n                         uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     }\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!isFlinkSupportedScheme(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Internal"
      }
    },
    "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed": {
      "type": "Ymultichange(Yrename,Ydocchange)",
      "commitMessage": "[FLINK-4910] Introduce safety net for closing file system streams\n\nThis closes #2691.\n",
      "commitDate": "2016/11/23 上午6:16",
      "commitName": "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
      "commitAuthor": "Stefan Richter",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "[FLINK-4910] Introduce safety net for closing file system streams\n\nThis closes #2691.\n",
          "commitDate": "2016/11/23 上午6:16",
          "commitName": "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
          "commitAuthor": "Stefan Richter",
          "commitDateOld": "2016/7/5 下午4:39",
          "commitNameOld": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
          "commitAuthorOld": "Josh",
          "daysBetweenCommits": 140.57,
          "commitsBetweenForRepo": 710,
          "commitsBetweenForFile": 1,
          "actualSource": "public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n    FileSystem fs;\n    URI asked \u003d uri;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!isFlinkSupportedScheme(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 255,
          "functionName": "getUnguardedFileSystem",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,57 +1,57 @@\n-public static FileSystem get(URI uri) throws IOException {\n+public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n     FileSystem fs;\n     URI asked \u003d uri;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 if (defaultScheme \u003d\u003d null) {\n                     defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                 }\n                 uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n                     if (defaultScheme.getScheme().equals(\"file\")) {\n                         uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     }\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!isFlinkSupportedScheme(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "get",
            "newValue": "getUnguardedFileSystem"
          }
        },
        {
          "type": "Ydocchange",
          "commitMessage": "[FLINK-4910] Introduce safety net for closing file system streams\n\nThis closes #2691.\n",
          "commitDate": "2016/11/23 上午6:16",
          "commitName": "ba8ed263695d16eacb4bdfdf195dd22c83bb53ed",
          "commitAuthor": "Stefan Richter",
          "commitDateOld": "2016/7/5 下午4:39",
          "commitNameOld": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
          "commitAuthorOld": "Josh",
          "daysBetweenCommits": 140.57,
          "commitsBetweenForRepo": 710,
          "commitsBetweenForFile": 1,
          "actualSource": "public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n    FileSystem fs;\n    URI asked \u003d uri;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!isFlinkSupportedScheme(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
          "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
          "functionStartLine": 255,
          "functionName": "getUnguardedFileSystem",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,57 +1,57 @@\n-public static FileSystem get(URI uri) throws IOException {\n+public static FileSystem getUnguardedFileSystem(URI uri) throws IOException {\n     FileSystem fs;\n     URI asked \u003d uri;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 if (defaultScheme \u003d\u003d null) {\n                     defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                 }\n                 uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n                     if (defaultScheme.getScheme().equals(\"file\")) {\n                         uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     }\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!isFlinkSupportedScheme(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
            "newValue": ""
          }
        }
      ]
    },
    "a3d1a17406749e41185a77a64c23fc1cb3eabc76": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-4115] Skip filesystem checks for filesystems with no built-in support\n",
      "commitDate": "2016/7/5 下午4:39",
      "commitName": "a3d1a17406749e41185a77a64c23fc1cb3eabc76",
      "commitAuthor": "Josh",
      "commitDateOld": "2016/2/16 下午10:23",
      "commitNameOld": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
      "commitAuthorOld": "Kostas Kloudas",
      "daysBetweenCommits": 139.76,
      "commitsBetweenForRepo": 702,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs;\n    URI asked \u003d uri;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!isFlinkSupportedScheme(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 228,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,57 +1,57 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs;\n     URI asked \u003d uri;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 if (defaultScheme \u003d\u003d null) {\n                     defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                 }\n                 uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n                     if (defaultScheme.getScheme().equals(\"file\")) {\n                         uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                     }\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n-        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n+        if (!isFlinkSupportedScheme(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e": {
      "type": "Ybodychange",
      "commitMessage": "FLINK-2380: allow the specification of a default filesystem scheme in the flink configuration file.\n\nThis closes #1524\n",
      "commitDate": "2016/2/16 下午10:23",
      "commitName": "76d3a6353a0a3f8960dc2b49d9eac6a4a279ea9e",
      "commitAuthor": "Kostas Kloudas",
      "commitDateOld": "2016/1/7 下午11:01",
      "commitNameOld": "c674a6558e07f1d918961a21ddaad4a6148698a0",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 39.97,
      "commitsBetweenForRepo": 256,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs;\n    URI asked \u003d uri;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                if (defaultScheme \u003d\u003d null) {\n                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n                }\n                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n            } catch (URISyntaxException e) {\n                try {\n                    if (defaultScheme.getScheme().equals(\"file\")) {\n                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                    }\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 228,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,48 +1,57 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs;\n+    URI asked \u003d uri;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n-                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n+                if (defaultScheme \u003d\u003d null) {\n+                    defaultScheme \u003d new URI(ConfigConstants.DEFAULT_FILESYSTEM_SCHEME);\n+                }\n+                uri \u003d new URI(defaultScheme.getScheme(), null, defaultScheme.getHost(), defaultScheme.getPort(), uri.getPath(), null, null);\n             } catch (URISyntaxException e) {\n                 try {\n-                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                    if (defaultScheme.getScheme().equals(\"file\")) {\n+                        uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                    }\n                 } catch (URISyntaxException ex) {\n-                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n+                    throw new IOException(\"The URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n+        if (uri.getScheme() \u003d\u003d null) {\n+            throw new IOException(\"The URI \u0027\" + uri + \"\u0027 is invalid.\\n\" + \"The fs.default-scheme \u003d \" + defaultScheme + \", the requested URI \u003d \" + asked + \", and the final URI \u003d \" + uri + \".\");\n+        }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1c8d866a83065e3d1bc9707dab81117f24c9f678": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1968] [runtime] Clean up and improve the distributed cache.\n\n - Gives a proper exception when a non-cached file is accessed\n - Forwards I/O exceptions that happen during file transfer, rather than only returning null when transfer failed\n - Consistently keeps reference counts and copies only when needed\n - Properly removes all files when shutdown\n - Uses a shutdown hook to remove files when process is killed\n",
      "commitDate": "2015/5/12 上午3:07",
      "commitName": "1c8d866a83065e3d1bc9707dab81117f24c9f678",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2015/4/1 上午1:54",
      "commitNameOld": "d8c74d20970e6cf379165ffafe8550a5b98d7c4d",
      "commitAuthorOld": "hongsibao",
      "daysBetweenCommits": 41.05,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                try {\n                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 193,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,48 +1,48 @@\n public static FileSystem get(URI uri) throws IOException {\n-    FileSystem fs \u003d null;\n+    FileSystem fs;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n                 try {\n                     uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2af658673f877a7e0fd73fdd2907f88824d793a5": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1295][FLINK-883] Allow to deploy \u0027job only\u0027 YARN cluster. Add tests to YARN\n\n- users can now also deploy Flink on YARN for executing a single job.\n- The flink-yarn project has been moved out of the flink-addons module\n- the MiniYARNCluster is used for testing Flink on YARN\n- There is now a (undocumented) Java interface Flink\u0027s YARN client, allowing users to manually control the Yarn session.\n- ALL ports used by Flink when running on YARN are automatically determined. In the past users reported problems with blocked ports (YARN is telling the client the RPC address of the application master)\n- The checks before deployment have been improved to give better error messages if the user is requesting too many resources for a YARN session\n",
      "commitDate": "2015/1/24 上午1:39",
      "commitName": "2af658673f877a7e0fd73fdd2907f88824d793a5",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015/1/8 下午11:42",
      "commitNameOld": "39fb7c945359465ce5241539559daac416e210b8",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                try {\n                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,49 +1,48 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n                 try {\n                     uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n-                System.out.println(\"Initializing new instance of wrapper for \" + wrapperClass);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39fb7c945359465ce5241539559daac416e210b8": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1266] More dependency exclusions \u0026 fixed image in web client\n\nThis closes #268\n",
      "commitDate": "2015/1/8 下午11:42",
      "commitName": "39fb7c945359465ce5241539559daac416e210b8",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2015/1/8 下午11:35",
      "commitNameOld": "0af4d3abf3afdeff89fee479a37413bc303d0ed0",
      "commitAuthorOld": "Robert Metzger",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                try {\n                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                System.out.println(\"Initializing new instance of wrapper for \" + wrapperClass);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,50 +1,49 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n                 try {\n                     uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n             if (wrapperClass !\u003d null) {\n                 FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                 if (CACHE.containsKey(wrappedKey)) {\n                     return CACHE.get(wrappedKey);\n                 }\n                 fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                 fs.initialize(uri);\n                 System.out.println(\"Initializing new instance of wrapper for \" + wrapperClass);\n                 CACHE.put(wrappedKey, fs);\n             } else {\n                 throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n             }\n         } else {\n             String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n             if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                 fs \u003d instantiateHadoopFileSystemWrapper(null);\n             } else {\n                 fs \u003d instantiateFileSystem(fsClass);\n             }\n-            System.out.println(\"Initializing new instance of native class for \" + fsClass);\n             fs.initialize(uri);\n             CACHE.put(key, fs);\n         }\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f2909293cbb37cc4b4516e3bef4db66376159e52": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1266] Generalize DistributedFileSystem implementation\nto HadoopFileSystem wrapper, which supports all subclasses of org.apache.hadoop.fs.FileSystem.\nThis allows us to let users use all file systems with support for HDFS.\nThe change has been tested with Tachyon, Google Cloud Storage Hadoop Adapter and HDFS.\n\nThe change also cleans up the Hadoop dependency exclusions.\n",
      "commitDate": "2015/1/8 下午11:35",
      "commitName": "f2909293cbb37cc4b4516e3bef4db66376159e52",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014/11/28 上午1:18",
      "commitNameOld": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
      "commitAuthorOld": "zentol",
      "daysBetweenCommits": 41.93,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                try {\n                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n            if (wrapperClass !\u003d null) {\n                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n                if (CACHE.containsKey(wrappedKey)) {\n                    return CACHE.get(wrappedKey);\n                }\n                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n                fs.initialize(uri);\n                System.out.println(\"Initializing new instance of wrapper for \" + wrapperClass);\n                CACHE.put(wrappedKey, fs);\n            } else {\n                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n            }\n        } else {\n            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n                fs \u003d instantiateHadoopFileSystemWrapper(null);\n            } else {\n                fs \u003d instantiateFileSystem(fsClass);\n            }\n            System.out.println(\"Initializing new instance of native class for \" + fsClass);\n            fs.initialize(uri);\n            CACHE.put(key, fs);\n        }\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 196,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,43 +1,50 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n                 try {\n                     uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                 } catch (URISyntaxException ex) {\n                     throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                 }\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+            Class\u003c?\u003e wrapperClass \u003d getHadoopWrapperClassNameForFileSystem(uri.getScheme());\n+            if (wrapperClass !\u003d null) {\n+                FSKey wrappedKey \u003d new FSKey(HADOOP_WRAPPER_SCHEME + \"+\" + uri.getScheme(), uri.getAuthority());\n+                if (CACHE.containsKey(wrappedKey)) {\n+                    return CACHE.get(wrappedKey);\n+                }\n+                fs \u003d instantiateHadoopFileSystemWrapper(wrapperClass);\n+                fs.initialize(uri);\n+                System.out.println(\"Initializing new instance of wrapper for \" + wrapperClass);\n+                CACHE.put(wrappedKey, fs);\n+            } else {\n+                throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n+            }\n+        } else {\n+            String fsClass \u003d FSDIRECTORY.get(uri.getScheme());\n+            if (fsClass.equals(HADOOP_WRAPPER_FILESYSTEM_CLASS)) {\n+                fs \u003d instantiateHadoopFileSystemWrapper(null);\n+            } else {\n+                fs \u003d instantiateFileSystem(fsClass);\n+            }\n+            System.out.println(\"Initializing new instance of native class for \" + fsClass);\n+            fs.initialize(uri);\n+            CACHE.put(key, fs);\n         }\n-        Class\u003c? extends FileSystem\u003e fsClass;\n-        try {\n-            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n-        } catch (ClassNotFoundException e1) {\n-            throw new IOException(StringUtils.stringifyException(e1));\n-        }\n-        try {\n-            fs \u003d fsClass.newInstance();\n-        } catch (InstantiationException e) {\n-            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-        } catch (IllegalAccessException e) {\n-            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n-        }\n-        fs.initialize(uri);\n-        CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbe54ac09154dd3e60870b0d26085e2e2ee564af": {
      "type": "Ybodychange",
      "commitMessage": "[FLINK-1270] [APIs] FS.get() supports relative paths\n\nThis closes #224\n",
      "commitDate": "2014/11/28 上午1:18",
      "commitName": "bbe54ac09154dd3e60870b0d26085e2e2ee564af",
      "commitAuthor": "zentol",
      "commitDateOld": "2014/11/20 下午7:17",
      "commitNameOld": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
      "commitAuthorOld": "Suneel Marthi",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                try {\n                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n                } catch (URISyntaxException ex) {\n                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n                }\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 190,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,39 +1,43 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n-                throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \" + \" File URIs need to specify aboslute file paths.\");\n+                try {\n+                    uri \u003d new URI(\"file\", null, new Path(new File(uri.getPath()).getAbsolutePath()).toUri().getPath(), null);\n+                } catch (URISyntaxException ex) {\n+                    throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid.\");\n+                }\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n         }\n         Class\u003c? extends FileSystem\u003e fsClass;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4203bf99ddd009b72681ba0dc554cabd47e1c85c": {
      "type": "Ybodychange",
      "commitMessage": "Minor code clean up\n\nThis closes #221.\n",
      "commitDate": "2014/11/20 下午7:17",
      "commitName": "4203bf99ddd009b72681ba0dc554cabd47e1c85c",
      "commitAuthor": "Suneel Marthi",
      "commitDateOld": "2014/11/10 下午6:59",
      "commitNameOld": "81c5b2adee778532634e52b7915ec682bb939a15",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 10.01,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \" + \" File URIs need to specify aboslute file paths.\");\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 189,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,39 +1,39 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n                 throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \" + \" File URIs need to specify aboslute file paths.\");\n             }\n         }\n         if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n             String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n             throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n         }\n-        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n+        Class\u003c? extends FileSystem\u003e fsClass;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a": {
      "type": "Ybodychange",
      "commitMessage": "Improve error messages in case of invalid file paths or URIs\n\nThis closes #170\n",
      "commitDate": "2014/11/4 上午12:10",
      "commitName": "8b39ba9e45145a30c2b95c47d7b03bc3ed2a8a3a",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014/9/23 下午7:59",
      "commitNameOld": "b904b0041cf97b2c6181b1985afc457ed01cf626",
      "commitAuthorOld": "Till Rohrmann",
      "daysBetweenCommits": 41.17,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \" + \" File URIs need to specify aboslute file paths.\");\n            }\n        }\n        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 200,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,35 +1,39 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n-                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \" + \"Failed for \" + uri.toString() + \".\");\n+                throw new IOException(\"The file URI \u0027\" + uri.toString() + \"\u0027 is not valid. \" + \" File URIs need to specify aboslute file paths.\");\n             }\n         }\n+        if (uri.getScheme().equals(\"file\") \u0026\u0026 uri.getAuthority() !\u003d null \u0026\u0026 !uri.getAuthority().isEmpty()) {\n+            String supposedUri \u003d \"file:///\" + uri.getAuthority() + uri.getPath();\n+            throw new IOException(\"Found local file path with authority \u0027\" + uri.getAuthority() + \"\u0027 in path \u0027\" + uri.toString() + \"\u0027. Hint: Did you forget a slash? (correct path would be \u0027\" + supposedUri + \"\u0027)\");\n+        }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \". Failed for \" + uri.toString() + \".\");\n+            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \", referenced in file URI \u0027\" + uri.toString() + \"\u0027.\");\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8563d511da8ab8ac0e1362775f11aef7b67375be": {
      "type": "Yfilerename",
      "commitMessage": "Rename POMs, scripts, quickstarts and other minor renames\n",
      "commitDate": "2014/7/11 上午4:35",
      "commitName": "8563d511da8ab8ac0e1362775f11aef7b67375be",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2014/7/10 下午10:46",
      "commitNameOld": "5f011547378ad03c033770503c6dcfd6b64e9647",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \" + \"Failed for \" + uri.toString() + \".\");\n            }\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \". Failed for \" + uri.toString() + \".\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
        "newPath": "flink-core/src/main/java/org/apache/flink/core/fs/FileSystem.java"
      }
    },
    "24eb47ac86299920aa137d5b6394a248ff58d19e": {
      "type": "Ymovefromfile",
      "commitMessage": "Renaming part 2 (core and java api)\n",
      "commitDate": "2014/7/10 上午1:14",
      "commitName": "24eb47ac86299920aa137d5b6394a248ff58d19e",
      "commitAuthor": "Stephan Ewen",
      "commitDateOld": "2014/7/9 下午10:08",
      "commitNameOld": "6d9a40d83c3e339c4e820a6b3632fc85ebcbc3de",
      "commitAuthorOld": "Stephan Ewen",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \" + \"Failed for \" + uri.toString() + \".\");\n            }\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \". Failed for \" + uri.toString() + \".\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/org/apache/flink/core/fs/FileSystem.java",
        "oldMethodName": "get",
        "newMethodName": "get"
      }
    },
    "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8": {
      "type": "Ybodychange",
      "commitMessage": "FS.get(): Add URI causing exception to message.\n",
      "commitDate": "2014/6/13 上午5:07",
      "commitName": "d784bf9467bbaf8ffb37621c13fa30dfbb98e4d8",
      "commitAuthor": "zentol",
      "commitDateOld": "2014/3/23 下午8:27",
      "commitNameOld": "a65ee8f600d16596f6193af444265de515ec80c4",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 81.36,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \" + \"Failed for \" + uri.toString() + \".\");\n            }\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \". Failed for \" + uri.toString() + \".\");\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,35 +1,35 @@\n public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             try {\n                 uri \u003d new URI(\"file\", null, uri.getPath(), null);\n             } catch (URISyntaxException e) {\n-                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes. \" + \"Failed for \" + uri.toString() + \".\");\n             }\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n-            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n+            throw new IOException(\"No file system found with scheme \" + uri.getScheme() + \". Failed for \" + uri.toString() + \".\");\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0038c9d0773e90676b1ee2a8a94dcf764f023e22": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
      "commitDate": "2014/3/7 上午6:45",
      "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
      "commitAuthor": "StephanEwen",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
          "commitDate": "2014/3/7 上午6:45",
          "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
          "commitAuthor": "StephanEwen",
          "commitDateOld": "2014/3/3 上午9:52",
          "commitNameOld": "3a6344356a185be43f9be4b33702f97827f9ff96",
          "commitAuthorOld": "StephanEwen",
          "daysBetweenCommits": 3.87,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n            }\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
          "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
          "functionStartLine": 191,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
          "diff": "@@ -1,31 +1,35 @@\n-public static FileSystem get(final URI uri) throws IOException {\n+public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n-            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n+            try {\n+                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n+            } catch (URISyntaxException e) {\n+                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+            }\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Fix the external packaged program test after merge with the new java api\nRelax generic bound in tuple type infor to work around bug in Java 6 compiler type inference.\nLocal file system is used by default when URI is missing\nRemoved final declaration from Tuple classes to allow inheritance (Fabian Hueske)\nFix in TupleType comparator generation (Fabian Hueske)\nCogroup Implementation (Markus Holzemer)\nAdded missing Apache license header (Fabian Hueske)\nInitial commit for join operator for new Java API (Fabian Hueske)\nAdded cross operator to new Java API (Fabian Hueske)\nFirst part of CoGroup (Markus Holzemer)\nAdded join example prog and fix in join operator (Fabian Hueske)\nUnified operator translation (Fabian Hueske)\nAdd Cross Prog for API implementation (Fabian Hueske)\nImplement CsvInputFormat for new Java API, including tests.\nFix logging messages in data source and sink tasks.\nFix error in data source task with new InputFormat siignatures\nAdd group reduce to new java api.\nFinaliz Key Extractors for new Java API\nFix bug in intitialization of broadcast serializers.\nAdded first set of comparators.\nAdded generic type serialization via avro\nAdd first stab at KeyExtractor implementation (Aljoscha Krettek)\nAdd trivial parts of serialization (Aljoscha Krettek)\nConnected serializers to the typeutils.\nFix tests to run with the NEW-API changes (Aljoscha Krettek)\nScala Post pass got confused because of ReduceNode renaming. (Aljoscha Krettek)\nSome input format mishaps. (Aljoscha Krettek)\nFirst set of new simple type serializers.\nConnect first paths of new Java API to optimizer.\nAdd name() to Operator plus some other stuff (Aljoscha Krettek)\nClean up moved annotations\nAdd CoGroup, Cross, and Union operators (Aljoscha Krettek)\nMake reduce operators children of UdfOperator (Aljoscha Krettek)\nAdjust input formats to new signature\nAdjusted, extended, and tested parsers for new java api compatibility.\nFirst draft of new java api.\nRemoving dependency to Combinable annotation. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API. (Jesus Camacho Rodriguez)\nMoving all annotations from the core to the Java API package. Created SemanticProperties in the core to store properties inferred currently from Java annotations. (Jesus Camacho Rodriguez)\nMoving all annotations to Java API (Jesus Camacho Rodriguez)\n",
          "commitDate": "2014/3/7 上午6:45",
          "commitName": "0038c9d0773e90676b1ee2a8a94dcf764f023e22",
          "commitAuthor": "StephanEwen",
          "commitDateOld": "2014/3/3 上午9:52",
          "commitNameOld": "3a6344356a185be43f9be4b33702f97827f9ff96",
          "commitAuthorOld": "StephanEwen",
          "daysBetweenCommits": 3.87,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            try {\n                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n            } catch (URISyntaxException e) {\n                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n            }\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
          "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
          "functionStartLine": 191,
          "functionName": "get",
          "functionAnnotation": "",
          "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
          "diff": "@@ -1,31 +1,35 @@\n-public static FileSystem get(final URI uri) throws IOException {\n+public static FileSystem get(URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n-            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n+            try {\n+                uri \u003d new URI(\"file\", null, uri.getPath(), null);\n+            } catch (URISyntaxException e) {\n+                throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are example schemes.\");\n+            }\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n             throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[uri-URI(modifiers-final)]",
            "newValue": "[uri-URI]"
          }
        }
      ]
    },
    "3a6344356a185be43f9be4b33702f97827f9ff96": {
      "type": "Ybodychange",
      "commitMessage": "Default mode for output formats is not to overwrite existing files.\nGlobally configurable default modes for overwrite / output directory behavior.\nConfigurable behavior for FileOutputFormat through regular parameters, rather than configuration.\n",
      "commitDate": "2014/3/3 上午9:52",
      "commitName": "3a6344356a185be43f9be4b33702f97827f9ff96",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2014/1/30 下午5:34",
      "commitNameOld": "31bae021b7639e2cba52c50df650cdd8f8677c08",
      "commitAuthorOld": "Fabian Hueske",
      "daysBetweenCommits": 31.68,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 191,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,31 +1,31 @@\n public static FileSystem get(final URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n-            throw new IOException(StringUtils.stringifyException(e));\n+            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         } catch (IllegalAccessException e) {\n-            throw new IOException(StringUtils.stringifyException(e));\n+            throw new IOException(\"Could not instantiate file system class: \" + e.getMessage(), e);\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fc6b5168684ca298d8b025c839d9a4e48e470790": {
      "type": "Yfilerename",
      "commitMessage": "Renamed packages in stratosphere-core.\n",
      "commitDate": "2013/12/14 上午10:09",
      "commitName": "fc6b5168684ca298d8b025c839d9a4e48e470790",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013/12/14 上午6:24",
      "commitNameOld": "eb8c49ebdff229c711cbd1e6be549d69667961a5",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java",
      "functionStartLine": 185,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/eu/stratosphere/core/fs/FileSystem.java"
      }
    },
    "33cb2ca9898809d2fc90765996ea56bbea458e59": {
      "type": "Yfilerename",
      "commitMessage": "Reorganized basic project structures. No renamings yet.\n",
      "commitDate": "2013/12/14 上午3:52",
      "commitName": "33cb2ca9898809d2fc90765996ea56bbea458e59",
      "commitAuthor": "StephanEwen",
      "commitDateOld": "2013/12/14 上午1:11",
      "commitNameOld": "0ad1dcc7dbd432d01d3cb4ed2db86b79534c68ad",
      "commitAuthorOld": "StephanEwen",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 188,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
        "newPath": "stratosphere-core/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java"
      }
    },
    "88d7305a5267aac598949519275123208195daf7": {
      "type": "Ybodychange",
      "commitMessage": "added test case (without fix) for a pact compiler bug with ALL_GROUP-reducer.\n",
      "commitDate": "2013/8/16 下午12:33",
      "commitName": "88d7305a5267aac598949519275123208195daf7",
      "commitAuthor": "Robert Metzger",
      "commitDateOld": "2012/2/26 下午11:56",
      "commitNameOld": "c1241753eb74b0fbb2b84ce76b6ae5be30477118",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 536.53,
      "commitsBetweenForRepo": 1129,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,31 +1,31 @@\n public static FileSystem get(final URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n-            throw new IOException(\"FileSystem: Scheme is null\");\n+            throw new IOException(\"FileSystem: Scheme is null. file:// or hdfs:// are schemes.\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         } catch (IllegalAccessException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0c21f4c470812d699ec141210ad5119b3450de3": {
      "type": "Ybodychange",
      "commitMessage": "Improved code style\n",
      "commitDate": "2011/8/17 下午10:26",
      "commitName": "d0c21f4c470812d699ec141210ad5119b3450de3",
      "commitAuthor": "Daniel Warneke",
      "commitDateOld": "2011/6/17 上午12:26",
      "commitNameOld": "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 61.92,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (SYNCHRONIZATION_OBJECT) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,31 +1,31 @@\n public static FileSystem get(final URI uri) throws IOException {\n     FileSystem fs \u003d null;\n-    synchronized (synchronizationObject) {\n+    synchronized (SYNCHRONIZATION_OBJECT) {\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"FileSystem: Scheme is null\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         } catch (IllegalAccessException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b27a112add2f4c221f9bfd8e4e953a750e8d64b3": {
      "type": "Yparametermetachange",
      "commitMessage": "Implemented S3DataOutputStream featuring HTTP multi part upload\n",
      "commitDate": "2011/6/17 上午12:26",
      "commitName": "b27a112add2f4c221f9bfd8e4e953a750e8d64b3",
      "commitAuthor": "Daniel Warneke",
      "commitDateOld": "2011/6/14 上午12:59",
      "commitNameOld": "a4c9876ef72888f99de798314f64cfd2450e43b4",
      "commitAuthorOld": "Daniel Warneke",
      "daysBetweenCommits": 2.98,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "public static FileSystem get(final URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (synchronizationObject) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 186,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n",
      "diff": "@@ -1,31 +1,31 @@\n-public static FileSystem get(URI uri) throws IOException {\n+public static FileSystem get(final URI uri) throws IOException {\n     FileSystem fs \u003d null;\n     synchronized (synchronizationObject) {\n         if (uri.getScheme() \u003d\u003d null) {\n             throw new IOException(\"FileSystem: Scheme is null\");\n         }\n         final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n         if (CACHE.containsKey(key)) {\n             return CACHE.get(key);\n         }\n         if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n             throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n         }\n         Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n         try {\n             fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n         } catch (ClassNotFoundException e1) {\n             throw new IOException(StringUtils.stringifyException(e1));\n         }\n         try {\n             fs \u003d fsClass.newInstance();\n         } catch (InstantiationException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         } catch (IllegalAccessException e) {\n             throw new IOException(StringUtils.stringifyException(e));\n         }\n         fs.initialize(uri);\n         CACHE.put(key, fs);\n     }\n     return fs;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[uri-URI]",
        "newValue": "[uri-URI(modifiers-final)]"
      }
    },
    "75e67a701cbabe5577967037c0e865d1c2e9a25b": {
      "type": "Yintroduced",
      "commitMessage": "Initial checkin.\n",
      "commitDate": "2010/12/17 上午2:09",
      "commitName": "75e67a701cbabe5577967037c0e865d1c2e9a25b",
      "commitAuthor": "sewen",
      "diff": "@@ -0,0 +1,31 @@\n+public static FileSystem get(URI uri) throws IOException {\n+    FileSystem fs \u003d null;\n+    synchronized (synchronizationObject) {\n+        if (uri.getScheme() \u003d\u003d null) {\n+            throw new IOException(\"FileSystem: Scheme is null\");\n+        }\n+        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n+        if (CACHE.containsKey(key)) {\n+            return CACHE.get(key);\n+        }\n+        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n+            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n+        }\n+        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n+        try {\n+            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n+        } catch (ClassNotFoundException e1) {\n+            throw new IOException(StringUtils.stringifyException(e1));\n+        }\n+        try {\n+            fs \u003d fsClass.newInstance();\n+        } catch (InstantiationException e) {\n+            throw new IOException(StringUtils.stringifyException(e));\n+        } catch (IllegalAccessException e) {\n+            throw new IOException(StringUtils.stringifyException(e));\n+        }\n+        fs.initialize(uri);\n+        CACHE.put(key, fs);\n+    }\n+    return fs;\n+}\n\\ No newline at end of file\n",
      "actualSource": "public static FileSystem get(URI uri) throws IOException {\n    FileSystem fs \u003d null;\n    synchronized (synchronizationObject) {\n        if (uri.getScheme() \u003d\u003d null) {\n            throw new IOException(\"FileSystem: Scheme is null\");\n        }\n        final FSKey key \u003d new FSKey(uri.getScheme(), uri.getAuthority());\n        if (CACHE.containsKey(key)) {\n            return CACHE.get(key);\n        }\n        if (!FSDIRECTORY.containsKey(uri.getScheme())) {\n            throw new IOException(\"No file system found with scheme \" + uri.getScheme());\n        }\n        Class\u003c? extends FileSystem\u003e fsClass \u003d null;\n        try {\n            fsClass \u003d ClassUtils.getFileSystemByName(FSDIRECTORY.get(uri.getScheme()));\n        } catch (ClassNotFoundException e1) {\n            throw new IOException(StringUtils.stringifyException(e1));\n        }\n        try {\n            fs \u003d fsClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        } catch (IllegalAccessException e) {\n            throw new IOException(StringUtils.stringifyException(e));\n        }\n        fs.initialize(uri);\n        CACHE.put(key, fs);\n    }\n    return fs;\n}",
      "path": "nephele/nephele-common/src/main/java/eu/stratosphere/nephele/fs/FileSystem.java",
      "functionStartLine": 158,
      "functionName": "get",
      "functionAnnotation": "",
      "functionDoc": "Returns a reference to the {@link FileSystem} instance for accessing the\nfile system identified by the given {@link URI}.\n\n@param uri the {@link URI} identifying the file system\n@return a reference to the {@link FileSystem} instance for accessing the file system identified by the given\n        {@link URI}.\n@throws IOException\n        thrown if a reference to the file system instance could not be obtained\n"
    }
  }
}