{
  "origin": "codeshovel",
  "repositoryName": "lucene-solr",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/lucene-solr/.git",
  "startCommitName": "38bf976cd4b9e324c21664bd7ae3d554df803705",
  "sourceFileName": "ConcurrentMergeScheduler.java",
  "functionName": "updateMergeThreads",
  "functionId": "updateMergeThreads",
  "sourceFilePath": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
  "functionAnnotation": "",
  "functionDoc": "",
  "functionStartLine": 300,
  "functionEndLine": 408,
  "numCommitsSeen": 86,
  "timeTaken": 4567,
  "changeHistory": [
    "9540bc37583dfd4e995b893154039fcf031dc3c3",
    "41fcc722ff07393586f7758d8a733c7e2e59bebc",
    "bab0b4633710f050886ab940095fd04cac824820",
    "3b67b17493216f6b0c81a981073fd5f61eace6f4",
    "b895ebde4340ed8ae903c7ae51750da3d9837394",
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
    "3a76e3a8f59a7c65662e1fae898f076e73a51685",
    "9906198ff3d65f8c9b7e99462aab19feb5334790",
    "765eab4008f44bb655b3dbbe4cc625455711536b",
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
    "7d35aafe71661e51ee01639ddf88503184610329"
  ],
  "changeHistoryShort": {
    "9540bc37583dfd4e995b893154039fcf031dc3c3": "Ybodychange",
    "41fcc722ff07393586f7758d8a733c7e2e59bebc": "Ymultichange(Ybodychange,Ydocchange)",
    "bab0b4633710f050886ab940095fd04cac824820": "Ydocchange",
    "3b67b17493216f6b0c81a981073fd5f61eace6f4": "Ybodychange",
    "b895ebde4340ed8ae903c7ae51750da3d9837394": "Ybodychange",
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c": "Yfilerename",
    "3a76e3a8f59a7c65662e1fae898f076e73a51685": "Ydocchange",
    "9906198ff3d65f8c9b7e99462aab19feb5334790": "Ymultichange(Ybodychange,Ydocchange)",
    "765eab4008f44bb655b3dbbe4cc625455711536b": "Ybodychange",
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da": "Ybodychange",
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80": "Ybodychange",
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93": "Ybodychange",
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": "Yfilerename",
    "7d35aafe71661e51ee01639ddf88503184610329": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9540bc37583dfd4e995b893154039fcf031dc3c3": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-7700: Move throughput control and merge aborting out of IndexWriter\u0027s core.\n",
      "commitDate": "2017/3/10 下午5:23",
      "commitName": "9540bc37583dfd4e995b893154039fcf031dc3c3",
      "commitAuthor": "Dawid Weiss",
      "commitDateOld": "2016/2/22 下午6:08",
      "commitNameOld": "fa602bf635d4710be2ffe891e252f7d4c2baf302",
      "commitAuthorOld": "Mike McCandless",
      "daysBetweenCommits": 381.97,
      "commitsBetweenForRepo": 2379,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        activeMerges.add(mergeThread);\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges);\n    final int activeMergeCount \u003d activeMerges.size();\n    int bigMergeCount \u003d 0;\n    for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n            bigMergeCount \u003d 1 + threadIdx;\n            break;\n        }\n    }\n    long now \u003d System.nanoTime();\n    StringBuilder message;\n    if (verbose()) {\n        message \u003d new StringBuilder();\n        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n        message \u003d null;\n    }\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        OneMerge merge \u003d mergeThread.merge;\n        final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n        double newMBPerSec;\n        if (doPause) {\n            newMBPerSec \u003d 0.0;\n        } else if (merge.maxNumSegments !\u003d -1) {\n            newMBPerSec \u003d forceMergeMBPerSec;\n        } else if (doAutoIOThrottle \u003d\u003d false) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else {\n            newMBPerSec \u003d targetMBPerSec;\n        }\n        MergeRateLimiter rateLimiter \u003d mergeThread.rateLimiter;\n        double curMBPerSec \u003d rateLimiter.getMBPerSec();\n        if (verbose()) {\n            long mergeStartNS \u003d merge.mergeStartNS;\n            if (mergeStartNS \u003d\u003d -1) {\n                mergeStartNS \u003d now;\n            }\n            message.append(\u0027\\n\u0027);\n            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(rateLimiter.getTotalBytesWritten()), nsToSec(now - mergeStartNS), nsToSec(rateLimiter.getTotalStoppedNS()), nsToSec(rateLimiter.getTotalPausedNS()), rateToString(rateLimiter.getMBPerSec())));\n            if (newMBPerSec !\u003d curMBPerSec) {\n                if (newMBPerSec \u003d\u003d 0.0) {\n                    message.append(\"  now stop\");\n                } else if (curMBPerSec \u003d\u003d 0.0) {\n                    if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n                        message.append(\"  now resume\");\n                    } else {\n                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                    }\n                } else {\n                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                }\n            } else if (curMBPerSec \u003d\u003d 0.0) {\n                message.append(\"  leave stopped\");\n            } else {\n                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n            }\n        }\n        rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n        message(message.toString());\n    }\n}",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 300,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,78 +1,79 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n         activeMerges.add(mergeThread);\n         threadIdx++;\n     }\n     CollectionUtil.timSort(activeMerges);\n     final int activeMergeCount \u003d activeMerges.size();\n     int bigMergeCount \u003d 0;\n     for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n         MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n             bigMergeCount \u003d 1 + threadIdx;\n             break;\n         }\n     }\n     long now \u003d System.nanoTime();\n     StringBuilder message;\n     if (verbose()) {\n         message \u003d new StringBuilder();\n         message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n     } else {\n         message \u003d null;\n     }\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n         MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         OneMerge merge \u003d mergeThread.merge;\n         final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n         double newMBPerSec;\n         if (doPause) {\n             newMBPerSec \u003d 0.0;\n         } else if (merge.maxNumSegments !\u003d -1) {\n             newMBPerSec \u003d forceMergeMBPerSec;\n         } else if (doAutoIOThrottle \u003d\u003d false) {\n             newMBPerSec \u003d Double.POSITIVE_INFINITY;\n         } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n             newMBPerSec \u003d Double.POSITIVE_INFINITY;\n         } else {\n             newMBPerSec \u003d targetMBPerSec;\n         }\n-        double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n+        MergeRateLimiter rateLimiter \u003d mergeThread.rateLimiter;\n+        double curMBPerSec \u003d rateLimiter.getMBPerSec();\n         if (verbose()) {\n             long mergeStartNS \u003d merge.mergeStartNS;\n             if (mergeStartNS \u003d\u003d -1) {\n                 mergeStartNS \u003d now;\n             }\n             message.append(\u0027\\n\u0027);\n-            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n+            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(rateLimiter.getTotalBytesWritten()), nsToSec(now - mergeStartNS), nsToSec(rateLimiter.getTotalStoppedNS()), nsToSec(rateLimiter.getTotalPausedNS()), rateToString(rateLimiter.getMBPerSec())));\n             if (newMBPerSec !\u003d curMBPerSec) {\n                 if (newMBPerSec \u003d\u003d 0.0) {\n                     message.append(\"  now stop\");\n                 } else if (curMBPerSec \u003d\u003d 0.0) {\n                     if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n                         message.append(\"  now resume\");\n                     } else {\n                         message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                     }\n                 } else {\n                     message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                 }\n             } else if (curMBPerSec \u003d\u003d 0.0) {\n                 message.append(\"  leave stopped\");\n             } else {\n                 message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n             }\n         }\n-        merge.rateLimiter.setMBPerSec(newMBPerSec);\n+        rateLimiter.setMBPerSec(newMBPerSec);\n     }\n     if (verbose()) {\n         message(message.toString());\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "41fcc722ff07393586f7758d8a733c7e2e59bebc": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LUCENE-6119: CMS dynamically rate limits IO writes of each merge depending on incoming merge rate\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1649532 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2015/1/5 下午10:28",
      "commitName": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
      "commitAuthor": "Michael McCandless",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LUCENE-6119: CMS dynamically rate limits IO writes of each merge depending on incoming merge rate\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1649532 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2015/1/5 下午10:28",
          "commitName": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
          "commitAuthor": "Michael McCandless",
          "commitDateOld": "2014/12/22 下午6:10",
          "commitNameOld": "ddc5c0c6b206e985f78f4479663583d1b64e61ac",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 14.18,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        activeMerges.add(mergeThread);\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges);\n    final int activeMergeCount \u003d activeMerges.size();\n    int bigMergeCount \u003d 0;\n    for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n            bigMergeCount \u003d 1 + threadIdx;\n            break;\n        }\n    }\n    long now \u003d System.nanoTime();\n    StringBuilder message;\n    if (verbose()) {\n        message \u003d new StringBuilder();\n        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n        message \u003d null;\n    }\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        OneMerge merge \u003d mergeThread.merge;\n        final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n        double newMBPerSec;\n        if (doPause) {\n            newMBPerSec \u003d 0.0;\n        } else if (merge.maxNumSegments !\u003d -1) {\n            newMBPerSec \u003d forceMergeMBPerSec;\n        } else if (doAutoIOThrottle \u003d\u003d false) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else {\n            newMBPerSec \u003d targetMBPerSec;\n        }\n        double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n        if (verbose()) {\n            long mergeStartNS \u003d merge.mergeStartNS;\n            if (mergeStartNS \u003d\u003d -1) {\n                mergeStartNS \u003d now;\n            }\n            message.append(\u0027\\n\u0027);\n            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n            if (newMBPerSec !\u003d curMBPerSec) {\n                if (newMBPerSec \u003d\u003d 0.0) {\n                    message.append(\"  now stop\");\n                } else if (curMBPerSec \u003d\u003d 0.0) {\n                    if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n                        message.append(\"  now resume\");\n                    } else {\n                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                    }\n                } else {\n                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                }\n            } else if (curMBPerSec \u003d\u003d 0.0) {\n                message.append(\"  leave stopped\");\n            } else {\n                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n            }\n        }\n        merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n        message(message.toString());\n    }\n}",
          "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
          "functionStartLine": 226,
          "functionName": "updateMergeThreads",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,78 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n-        if (mergeThread.getCurrentMerge() !\u003d null) {\n-            activeMerges.add(mergeThread);\n-        }\n+        activeMerges.add(mergeThread);\n         threadIdx++;\n     }\n-    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n-    int pri \u003d mergeThreadPriority;\n+    CollectionUtil.timSort(activeMerges);\n     final int activeMergeCount \u003d activeMerges.size();\n+    int bigMergeCount \u003d 0;\n+    for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n+        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+        if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n+            bigMergeCount \u003d 1 + threadIdx;\n+            break;\n+        }\n+    }\n+    long now \u003d System.nanoTime();\n+    StringBuilder message;\n+    if (verbose()) {\n+        message \u003d new StringBuilder();\n+        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n+    } else {\n+        message \u003d null;\n+    }\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n-        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n-        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-        if (merge \u003d\u003d null) {\n-            continue;\n+        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+        OneMerge merge \u003d mergeThread.merge;\n+        final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n+        double newMBPerSec;\n+        if (doPause) {\n+            newMBPerSec \u003d 0.0;\n+        } else if (merge.maxNumSegments !\u003d -1) {\n+            newMBPerSec \u003d forceMergeMBPerSec;\n+        } else if (doAutoIOThrottle \u003d\u003d false) {\n+            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+        } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n+            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+        } else {\n+            newMBPerSec \u003d targetMBPerSec;\n         }\n-        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n+        double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n         if (verbose()) {\n-            if (doPause !\u003d merge.getPause()) {\n-                if (doPause) {\n-                    message(\"pause thread \" + mergeThread.getName());\n+            long mergeStartNS \u003d merge.mergeStartNS;\n+            if (mergeStartNS \u003d\u003d -1) {\n+                mergeStartNS \u003d now;\n+            }\n+            message.append(\u0027\\n\u0027);\n+            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n+            if (newMBPerSec !\u003d curMBPerSec) {\n+                if (newMBPerSec \u003d\u003d 0.0) {\n+                    message.append(\"  now stop\");\n+                } else if (curMBPerSec \u003d\u003d 0.0) {\n+                    if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n+                        message.append(\"  now resume\");\n+                    } else {\n+                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n+                    }\n                 } else {\n-                    message(\"unpause thread \" + mergeThread.getName());\n+                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                 }\n+            } else if (curMBPerSec \u003d\u003d 0.0) {\n+                message.append(\"  leave stopped\");\n+            } else {\n+                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n             }\n         }\n-        if (doPause !\u003d merge.getPause()) {\n-            merge.setPause(doPause);\n-        }\n-        if (!doPause) {\n-            if (verbose()) {\n-                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n-            }\n-            mergeThread.setThreadPriority(pri);\n-            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n-        }\n+        merge.rateLimiter.setMBPerSec(newMBPerSec);\n+    }\n+    if (verbose()) {\n+        message(message.toString());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LUCENE-6119: CMS dynamically rate limits IO writes of each merge depending on incoming merge rate\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1649532 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2015/1/5 下午10:28",
          "commitName": "41fcc722ff07393586f7758d8a733c7e2e59bebc",
          "commitAuthor": "Michael McCandless",
          "commitDateOld": "2014/12/22 下午6:10",
          "commitNameOld": "ddc5c0c6b206e985f78f4479663583d1b64e61ac",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 14.18,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        activeMerges.add(mergeThread);\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges);\n    final int activeMergeCount \u003d activeMerges.size();\n    int bigMergeCount \u003d 0;\n    for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n            bigMergeCount \u003d 1 + threadIdx;\n            break;\n        }\n    }\n    long now \u003d System.nanoTime();\n    StringBuilder message;\n    if (verbose()) {\n        message \u003d new StringBuilder();\n        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n    } else {\n        message \u003d null;\n    }\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        OneMerge merge \u003d mergeThread.merge;\n        final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n        double newMBPerSec;\n        if (doPause) {\n            newMBPerSec \u003d 0.0;\n        } else if (merge.maxNumSegments !\u003d -1) {\n            newMBPerSec \u003d forceMergeMBPerSec;\n        } else if (doAutoIOThrottle \u003d\u003d false) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n        } else {\n            newMBPerSec \u003d targetMBPerSec;\n        }\n        double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n        if (verbose()) {\n            long mergeStartNS \u003d merge.mergeStartNS;\n            if (mergeStartNS \u003d\u003d -1) {\n                mergeStartNS \u003d now;\n            }\n            message.append(\u0027\\n\u0027);\n            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n            if (newMBPerSec !\u003d curMBPerSec) {\n                if (newMBPerSec \u003d\u003d 0.0) {\n                    message.append(\"  now stop\");\n                } else if (curMBPerSec \u003d\u003d 0.0) {\n                    if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n                        message.append(\"  now resume\");\n                    } else {\n                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n                    }\n                } else {\n                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                }\n            } else if (curMBPerSec \u003d\u003d 0.0) {\n                message.append(\"  leave stopped\");\n            } else {\n                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n            }\n        }\n        merge.rateLimiter.setMBPerSec(newMBPerSec);\n    }\n    if (verbose()) {\n        message(message.toString());\n    }\n}",
          "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
          "functionStartLine": 226,
          "functionName": "updateMergeThreads",
          "functionAnnotation": "",
          "functionDoc": "",
          "diff": "@@ -1,45 +1,78 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n-        if (mergeThread.getCurrentMerge() !\u003d null) {\n-            activeMerges.add(mergeThread);\n-        }\n+        activeMerges.add(mergeThread);\n         threadIdx++;\n     }\n-    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n-    int pri \u003d mergeThreadPriority;\n+    CollectionUtil.timSort(activeMerges);\n     final int activeMergeCount \u003d activeMerges.size();\n+    int bigMergeCount \u003d 0;\n+    for (threadIdx \u003d activeMergeCount - 1; threadIdx \u003e\u003d 0; threadIdx--) {\n+        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+        if (mergeThread.merge.estimatedMergeBytes \u003e MIN_BIG_MERGE_MB * 1024 * 1024) {\n+            bigMergeCount \u003d 1 + threadIdx;\n+            break;\n+        }\n+    }\n+    long now \u003d System.nanoTime();\n+    StringBuilder message;\n+    if (verbose()) {\n+        message \u003d new StringBuilder();\n+        message.append(String.format(Locale.ROOT, \"updateMergeThreads ioThrottle\u003d%s targetMBPerSec\u003d%.1f MB/sec\", doAutoIOThrottle, targetMBPerSec));\n+    } else {\n+        message \u003d null;\n+    }\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n-        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n-        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n-        if (merge \u003d\u003d null) {\n-            continue;\n+        MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+        OneMerge merge \u003d mergeThread.merge;\n+        final boolean doPause \u003d threadIdx \u003c bigMergeCount - maxThreadCount;\n+        double newMBPerSec;\n+        if (doPause) {\n+            newMBPerSec \u003d 0.0;\n+        } else if (merge.maxNumSegments !\u003d -1) {\n+            newMBPerSec \u003d forceMergeMBPerSec;\n+        } else if (doAutoIOThrottle \u003d\u003d false) {\n+            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+        } else if (merge.estimatedMergeBytes \u003c MIN_BIG_MERGE_MB * 1024 * 1024) {\n+            newMBPerSec \u003d Double.POSITIVE_INFINITY;\n+        } else {\n+            newMBPerSec \u003d targetMBPerSec;\n         }\n-        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n+        double curMBPerSec \u003d merge.rateLimiter.getMBPerSec();\n         if (verbose()) {\n-            if (doPause !\u003d merge.getPause()) {\n-                if (doPause) {\n-                    message(\"pause thread \" + mergeThread.getName());\n+            long mergeStartNS \u003d merge.mergeStartNS;\n+            if (mergeStartNS \u003d\u003d -1) {\n+                mergeStartNS \u003d now;\n+            }\n+            message.append(\u0027\\n\u0027);\n+            message.append(String.format(Locale.ROOT, \"merge thread %s estSize\u003d%.1f MB (written\u003d%.1f MB) runTime\u003d%.1fs (stopped\u003d%.1fs, paused\u003d%.1fs) rate\u003d%s\\n\", mergeThread.getName(), bytesToMB(merge.estimatedMergeBytes), bytesToMB(merge.rateLimiter.totalBytesWritten), nsToSec(now - mergeStartNS), nsToSec(merge.rateLimiter.getTotalStoppedNS()), nsToSec(merge.rateLimiter.getTotalPausedNS()), rateToString(merge.rateLimiter.getMBPerSec())));\n+            if (newMBPerSec !\u003d curMBPerSec) {\n+                if (newMBPerSec \u003d\u003d 0.0) {\n+                    message.append(\"  now stop\");\n+                } else if (curMBPerSec \u003d\u003d 0.0) {\n+                    if (newMBPerSec \u003d\u003d Double.POSITIVE_INFINITY) {\n+                        message.append(\"  now resume\");\n+                    } else {\n+                        message.append(String.format(Locale.ROOT, \"  now resume to %.1f MB/sec\", newMBPerSec));\n+                    }\n                 } else {\n-                    message(\"unpause thread \" + mergeThread.getName());\n+                    message.append(String.format(Locale.ROOT, \"  now change from %.1f MB/sec to %.1f MB/sec\", curMBPerSec, newMBPerSec));\n                 }\n+            } else if (curMBPerSec \u003d\u003d 0.0) {\n+                message.append(\"  leave stopped\");\n+            } else {\n+                message.append(String.format(Locale.ROOT, \"  leave running at %.1f MB/sec\", curMBPerSec));\n             }\n         }\n-        if (doPause !\u003d merge.getPause()) {\n-            merge.setPause(doPause);\n-        }\n-        if (!doPause) {\n-            if (verbose()) {\n-                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n-            }\n-            mergeThread.setThreadPriority(pri);\n-            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n-        }\n+        merge.rateLimiter.setMBPerSec(newMBPerSec);\n+    }\n+    if (verbose()) {\n+        message(message.toString());\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Called whenever the running merges have changed, to pause and unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
            "newValue": ""
          }
        }
      ]
    },
    "bab0b4633710f050886ab940095fd04cac824820": {
      "type": "Ydocchange",
      "commitMessage": "docs: get minimal doclint options passing\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1642250 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/11/28 上午9:16",
      "commitName": "bab0b4633710f050886ab940095fd04cac824820",
      "commitAuthor": "Robert Muir",
      "commitDateOld": "2014/11/19 上午8:03",
      "commitNameOld": "90a64497dd0a903eb0797ed0d95d47969d640387",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 9.05,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 170,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to pause and unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
        "newValue": "Called whenever the running merges have changed, to pause and unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n"
      }
    },
    "3b67b17493216f6b0c81a981073fd5f61eace6f4": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-5512: remove redundant typing (diamond operator) in trunk\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1576755 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2014/3/12 下午10:39",
      "commitName": "3b67b17493216f6b0c81a981073fd5f61eace6f4",
      "commitAuthor": "Robert Muir",
      "commitDateOld": "2014/3/12 上午3:11",
      "commitNameOld": "7efebfa50ac667fa1714c9fc43c3d6bc113fdd34",
      "commitAuthorOld": "Simon Willnauer",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 170,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
      "diff": "@@ -1,45 +1,45 @@\n protected synchronized void updateMergeThreads() {\n-    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003c\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n         if (mergeThread.getCurrentMerge() !\u003d null) {\n             activeMerges.add(mergeThread);\n         }\n         threadIdx++;\n     }\n     CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n         final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b895ebde4340ed8ae903c7ae51750da3d9837394": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-4946: Refactor SorterTemplate (now Sorter).\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1478785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2013/5/3 下午9:37",
      "commitName": "b895ebde4340ed8ae903c7ae51750da3d9837394",
      "commitAuthor": "Adrien Grand",
      "commitDateOld": "2013/3/30 上午5:56",
      "commitNameOld": "1f964c57642e4a686b4812241eae67e0dc83ce06",
      "commitAuthorOld": "Adrien Grand",
      "daysBetweenCommits": 34.65,
      "commitsBetweenForRepo": 231,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 166,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
      "diff": "@@ -1,45 +1,45 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n         if (mergeThread.getCurrentMerge() !\u003d null) {\n             activeMerges.add(mergeThread);\n         }\n         threadIdx++;\n     }\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.timSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n         final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c": {
      "type": "Yfilerename",
      "commitMessage": "LUCENE-3753: Restructure the Lucene build system\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1241588 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2012/2/8 上午3:59",
      "commitName": "eb0ab3d392a42c1835f79bcd7f5404bcc50c8e4c",
      "commitAuthor": "Steven Rowe",
      "commitDateOld": "2012/2/8 上午2:58",
      "commitNameOld": "8b939cb7d20160f9f8a7baf2030613f0e1e877b4",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 151,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
        "newPath": "lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
      }
    },
    "3a76e3a8f59a7c65662e1fae898f076e73a51685": {
      "type": "Ydocchange",
      "commitMessage": "typo police\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1065410 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/1/31 上午6:34",
      "commitName": "3a76e3a8f59a7c65662e1fae898f076e73a51685",
      "commitAuthor": "Robert Muir",
      "commitDateOld": "2011/1/30 上午12:22",
      "commitNameOld": "5342d8676da8f794efbcf93b5001b107514f1363",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 1.26,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 151,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to lsat --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
        "newValue": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to last --\nthat way, smaller merges are guaranteed to run before larger ones.\n"
      }
    },
    "9906198ff3d65f8c9b7e99462aab19feb5334790": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "LUCENE-2755: documentation updates, formatting and tiny mods to CMS (trunk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1059905 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2011/1/17 下午8:49",
      "commitName": "9906198ff3d65f8c9b7e99462aab19feb5334790",
      "commitAuthor": "Shai Erera",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "LUCENE-2755: documentation updates, formatting and tiny mods to CMS (trunk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1059905 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2011/1/17 下午8:49",
          "commitName": "9906198ff3d65f8c9b7e99462aab19feb5334790",
          "commitAuthor": "Shai Erera",
          "commitDateOld": "2010/12/20 下午6:35",
          "commitNameOld": "765eab4008f44bb655b3dbbe4cc625455711536b",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 28.09,
          "commitsBetweenForRepo": 179,
          "commitsBetweenForFile": 1,
          "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
          "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
          "functionStartLine": 151,
          "functionName": "updateMergeThreads",
          "functionAnnotation": "",
          "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to lsat --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
          "diff": "@@ -1,50 +1,45 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n         if (mergeThread.getCurrentMerge() !\u003d null) {\n             activeMerges.add(mergeThread);\n         }\n         threadIdx++;\n     }\n     CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n         final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n-        final boolean doPause;\n-        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n-            doPause \u003d true;\n-        } else {\n-            doPause \u003d false;\n-        }\n+        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "LUCENE-2755: documentation updates, formatting and tiny mods to CMS (trunk)\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1059905 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "2011/1/17 下午8:49",
          "commitName": "9906198ff3d65f8c9b7e99462aab19feb5334790",
          "commitAuthor": "Shai Erera",
          "commitDateOld": "2010/12/20 下午6:35",
          "commitNameOld": "765eab4008f44bb655b3dbbe4cc625455711536b",
          "commitAuthorOld": "Michael McCandless",
          "daysBetweenCommits": 28.09,
          "commitsBetweenForRepo": 179,
          "commitsBetweenForFile": 1,
          "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
          "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
          "functionStartLine": 151,
          "functionName": "updateMergeThreads",
          "functionAnnotation": "",
          "functionDoc": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to lsat --\nthat way, smaller merges are guaranteed to run before larger ones.\n",
          "diff": "@@ -1,50 +1,45 @@\n protected synchronized void updateMergeThreads() {\n     final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n     int threadIdx \u003d 0;\n     while (threadIdx \u003c mergeThreads.size()) {\n         final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n         if (!mergeThread.isAlive()) {\n             mergeThreads.remove(threadIdx);\n             continue;\n         }\n         if (mergeThread.getCurrentMerge() !\u003d null) {\n             activeMerges.add(mergeThread);\n         }\n         threadIdx++;\n     }\n     CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n     final int activeMergeCount \u003d activeMerges.size();\n     for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n         final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n-        final boolean doPause;\n-        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n-            doPause \u003d true;\n-        } else {\n-            doPause \u003d false;\n-        }\n+        final boolean doPause \u003d threadIdx \u003c activeMergeCount - maxThreadCount;\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
            "newValue": "Called whenever the running merges have changed, to pause \u0026 unpause\nthreads. This method sorts the merge threads by their merge size in\ndescending order and then pauses/unpauses threads from first to lsat --\nthat way, smaller merges are guaranteed to run before larger ones.\n"
          }
        }
      ]
    },
    "765eab4008f44bb655b3dbbe4cc625455711536b": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: fix CMS to stop its threads without deadlocking!\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1051041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/12/20 下午6:35",
      "commitName": "765eab4008f44bb655b3dbbe4cc625455711536b",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010/12/20 上午1:07",
      "commitNameOld": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 147,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
      "diff": "@@ -1,37 +1,50 @@\n protected synchronized void updateMergeThreads() {\n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    final int count \u003d mergeThreads.size();\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+    int threadIdx \u003d 0;\n+    while (threadIdx \u003c mergeThreads.size()) {\n+        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n+        if (!mergeThread.isAlive()) {\n+            mergeThreads.remove(threadIdx);\n+            continue;\n+        }\n+        if (mergeThread.getCurrentMerge() !\u003d null) {\n+            activeMerges.add(mergeThread);\n+        }\n+        threadIdx++;\n+    }\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n-    for (int i \u003d 0; i \u003c count; i++) {\n-        final MergeThread mergeThread \u003d mergeThreads.get(i);\n+    final int activeMergeCount \u003d activeMerges.size();\n+    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n+        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause;\n-        if (i \u003c count - maxThreadCount) {\n+        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n             doPause \u003d true;\n         } else {\n             doPause \u003d false;\n         }\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "65b27c2adb9000b64ccd9d3a3b1a5030550b06da": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: revert until I find the cause of the deadlock\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050899 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/12/20 上午1:07",
      "commitName": "65b27c2adb9000b64ccd9d3a3b1a5030550b06da",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010/12/19 下午9:57",
      "commitNameOld": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for (int i \u003d 0; i \u003c count; i++) {\n        final MergeThread mergeThread \u003d mergeThreads.get(i);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i \u003c count - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 148,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
      "diff": "@@ -1,50 +1,37 @@\n protected synchronized void updateMergeThreads() {\n-    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n-    int threadIdx \u003d 0;\n-    while (threadIdx \u003c mergeThreads.size()) {\n-        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n-        if (!mergeThread.isAlive()) {\n-            mergeThreads.remove(threadIdx);\n-            continue;\n-        }\n-        if (mergeThread.getCurrentMerge() !\u003d null) {\n-            activeMerges.add(mergeThread);\n-        }\n-        threadIdx++;\n-    }\n-    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n+    final int count \u003d mergeThreads.size();\n     int pri \u003d mergeThreadPriority;\n-    final int activeMergeCount \u003d activeMerges.size();\n-    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n-        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n+    for (int i \u003d 0; i \u003c count; i++) {\n+        final MergeThread mergeThread \u003d mergeThreads.get(i);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause;\n-        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n+        if (i \u003c count - maxThreadCount) {\n             doPause \u003d true;\n         } else {\n             doPause \u003d false;\n         }\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2820: fix CMS to stop all threads during close\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1050853 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/12/19 下午9:57",
      "commitName": "5f9bb3f0a860097352abfc5b4c2ac7d486c06c80",
      "commitAuthor": "Michael McCandless",
      "commitDateOld": "2010/12/19 上午3:14",
      "commitNameOld": "623fd7bcd7470d5d5330d721ea89269ce93c02e5",
      "commitAuthorOld": "Robert Muir",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n    int threadIdx \u003d 0;\n    while (threadIdx \u003c mergeThreads.size()) {\n        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n        if (!mergeThread.isAlive()) {\n            mergeThreads.remove(threadIdx);\n            continue;\n        }\n        if (mergeThread.getCurrentMerge() !\u003d null) {\n            activeMerges.add(mergeThread);\n        }\n        threadIdx++;\n    }\n    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n    int pri \u003d mergeThreadPriority;\n    final int activeMergeCount \u003d activeMerges.size();\n    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 147,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
      "diff": "@@ -1,37 +1,50 @@\n protected synchronized void updateMergeThreads() {\n-    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n-    final int count \u003d mergeThreads.size();\n+    final List\u003cMergeThread\u003e activeMerges \u003d new ArrayList\u003cMergeThread\u003e();\n+    int threadIdx \u003d 0;\n+    while (threadIdx \u003c mergeThreads.size()) {\n+        final MergeThread mergeThread \u003d mergeThreads.get(threadIdx);\n+        if (!mergeThread.isAlive()) {\n+            mergeThreads.remove(threadIdx);\n+            continue;\n+        }\n+        if (mergeThread.getCurrentMerge() !\u003d null) {\n+            activeMerges.add(mergeThread);\n+        }\n+        threadIdx++;\n+    }\n+    CollectionUtil.mergeSort(activeMerges, compareByMergeDocCount);\n     int pri \u003d mergeThreadPriority;\n-    for (int i \u003d 0; i \u003c count; i++) {\n-        final MergeThread mergeThread \u003d mergeThreads.get(i);\n+    final int activeMergeCount \u003d activeMerges.size();\n+    for (threadIdx \u003d 0; threadIdx \u003c activeMergeCount; threadIdx++) {\n+        final MergeThread mergeThread \u003d activeMerges.get(threadIdx);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause;\n-        if (i \u003c count - maxThreadCount) {\n+        if (threadIdx \u003c activeMergeCount - maxThreadCount) {\n             doPause \u003d true;\n         } else {\n             doPause \u003d false;\n         }\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "717c67ab7c2df6901f056ae2a1b5cd8317166b93": {
      "type": "Ybodychange",
      "commitMessage": "LUCENE-2719: Readded utility class org.apche.lucene.util.SorterTemplate with support for faster quickSort using pivot values and also merge sort and insertion sort. This removes code duplication and slow Collections/Arrays.sort usage.\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/dev/trunk@1027998 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2010/10/27 下午11:16",
      "commitName": "717c67ab7c2df6901f056ae2a1b5cd8317166b93",
      "commitAuthor": "Uwe Schindler",
      "commitDateOld": "2010/6/11 下午5:51",
      "commitNameOld": "7fe6c0fb24051748ae3ccb1b5933244deb9570bf",
      "commitAuthorOld": "Michael McCandless",
      "daysBetweenCommits": 138.23,
      "commitsBetweenForRepo": 765,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for (int i \u003d 0; i \u003c count; i++) {\n        final MergeThread mergeThread \u003d mergeThreads.get(i);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i \u003c count - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
      "diff": "@@ -1,37 +1,37 @@\n protected synchronized void updateMergeThreads() {\n-    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n+    CollectionUtil.mergeSort(mergeThreads, compareByMergeDocCount);\n     final int count \u003d mergeThreads.size();\n     int pri \u003d mergeThreadPriority;\n     for (int i \u003d 0; i \u003c count; i++) {\n         final MergeThread mergeThread \u003d mergeThreads.get(i);\n         final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n         if (merge \u003d\u003d null) {\n             continue;\n         }\n         final boolean doPause;\n         if (i \u003c count - maxThreadCount) {\n             doPause \u003d true;\n         } else {\n             doPause \u003d false;\n         }\n         if (verbose()) {\n             if (doPause !\u003d merge.getPause()) {\n                 if (doPause) {\n                     message(\"pause thread \" + mergeThread.getName());\n                 } else {\n                     message(\"unpause thread \" + mergeThread.getName());\n                 }\n             }\n         }\n         if (doPause !\u003d merge.getPause()) {\n             merge.setPause(doPause);\n         }\n         if (!doPause) {\n             if (verbose()) {\n                 message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n             }\n             mergeThread.setThreadPriority(pri);\n             pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "778d96752fa94636a2136ea2b4d58a3fcbe283ec": {
      "type": "Yfilerename",
      "commitMessage": "SVN-GIT conversion, path copy emulation.\n",
      "commitDate": "2016/1/23 上午8:18",
      "commitName": "778d96752fa94636a2136ea2b4d58a3fcbe283ec",
      "commitAuthor": "Dawid Weiss",
      "commitDateOld": "2010/3/17 下午10:57",
      "commitNameOld": "2e5c6cdadc820220f8cb86e1b6e215da941649f9",
      "commitAuthorOld": "Uwe Schindler",
      "daysBetweenCommits": 2137.39,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected synchronized void updateMergeThreads() {\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for (int i \u003d 0; i \u003c count; i++) {\n        final MergeThread mergeThread \u003d mergeThreads.get(i);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i \u003c count - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
        "newPath": "lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java"
      }
    },
    "7d35aafe71661e51ee01639ddf88503184610329": {
      "type": "Yintroduced",
      "commitMessage": "LUCENE-2164: make CMS smarter about prioritizing its threads\n\ngit-svn-id: https://svn.apache.org/repos/asf/lucene/java/trunk@892992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "2009/12/22 上午5:38",
      "commitName": "7d35aafe71661e51ee01639ddf88503184610329",
      "commitAuthor": "Michael McCandless",
      "diff": "@@ -0,0 +1,37 @@\n+protected synchronized void updateMergeThreads() {\n+    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n+    final int count \u003d mergeThreads.size();\n+    int pri \u003d mergeThreadPriority;\n+    for (int i \u003d 0; i \u003c count; i++) {\n+        final MergeThread mergeThread \u003d mergeThreads.get(i);\n+        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n+        if (merge \u003d\u003d null) {\n+            continue;\n+        }\n+        final boolean doPause;\n+        if (i \u003c count - maxThreadCount) {\n+            doPause \u003d true;\n+        } else {\n+            doPause \u003d false;\n+        }\n+        if (verbose()) {\n+            if (doPause !\u003d merge.getPause()) {\n+                if (doPause) {\n+                    message(\"pause thread \" + mergeThread.getName());\n+                } else {\n+                    message(\"unpause thread \" + mergeThread.getName());\n+                }\n+            }\n+        }\n+        if (doPause !\u003d merge.getPause()) {\n+            merge.setPause(doPause);\n+        }\n+        if (!doPause) {\n+            if (verbose()) {\n+                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n+            }\n+            mergeThread.setThreadPriority(pri);\n+            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n+        }\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected synchronized void updateMergeThreads() {\n    Collections.sort(mergeThreads, new CompareByMergeDocCount());\n    final int count \u003d mergeThreads.size();\n    int pri \u003d mergeThreadPriority;\n    for (int i \u003d 0; i \u003c count; i++) {\n        final MergeThread mergeThread \u003d mergeThreads.get(i);\n        final MergePolicy.OneMerge merge \u003d mergeThread.getCurrentMerge();\n        if (merge \u003d\u003d null) {\n            continue;\n        }\n        final boolean doPause;\n        if (i \u003c count - maxThreadCount) {\n            doPause \u003d true;\n        } else {\n            doPause \u003d false;\n        }\n        if (verbose()) {\n            if (doPause !\u003d merge.getPause()) {\n                if (doPause) {\n                    message(\"pause thread \" + mergeThread.getName());\n                } else {\n                    message(\"unpause thread \" + mergeThread.getName());\n                }\n            }\n        }\n        if (doPause !\u003d merge.getPause()) {\n            merge.setPause(doPause);\n        }\n        if (!doPause) {\n            if (verbose()) {\n                message(\"set priority of merge thread \" + mergeThread.getName() + \" to \" + pri);\n            }\n            mergeThread.setThreadPriority(pri);\n            pri \u003d Math.min(Thread.MAX_PRIORITY, 1 + pri);\n        }\n    }\n}",
      "path": "src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java",
      "functionStartLine": 155,
      "functionName": "updateMergeThreads",
      "functionAnnotation": "",
      "functionDoc": "Called whenever the running merges have changed, to\n pause \u0026 unpause threads.\n"
    }
  }
}