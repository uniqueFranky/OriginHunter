{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "ConfigurationClassParser.java",
  "functionName": "doProcessConfigurationClass",
  "functionId": "doProcessConfigurationClass___configClass-ConfigurationClass__sourceClass-SourceClass",
  "sourceFilePath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
  "functionAnnotation": "@Nullable",
  "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
  "functionStartLine": 261,
  "functionEndLine": 339,
  "numCommitsSeen": 156,
  "timeTaken": 7971,
  "changeHistory": [
    "9a43d2ec208d2e8cd0866431acf26af3529f8677",
    "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
    "3295a4e6ef43c3e3053f41404ccf7da6ab53f310",
    "d96a66ae8fc01cb480132e909b320a6c6addbfde",
    "316244d2bdcb288ef4e6ff58daef6da0511fe765",
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
    "03affa02dbb3d629d12228b1622a1d2c8cd37931",
    "388bd87ef03b3c080f1c351855d01af1df033a94",
    "d3b5aeb768b89d960302b471bd4b3e913dd2df27",
    "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
    "192462902ef3d97c0b6684d467c7d2023ecd5be1",
    "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4",
    "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
    "84564a0c7b6c34cec4beede6ee75078a6073abb9",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
    "bbf58008314bd42dd20c92602c1133287423dc7f",
    "ce1954da1edd64f1280ead0435c7b3923e33f6da",
    "e8dead247c7d421074caf171456e0653d63780f7",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b",
    "d87838fc6d0923659465ca5b75d8e0ba628afb77",
    "ced5ea2f93a474646e9554354ca09c0c12e967e8",
    "620c16f5c7bb543b18f71b2848f90461f8646237",
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
    "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
    "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
    "239ce1466ce118294f5c7b8e842a80815fd813de",
    "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b",
    "d3a406876834b91a4cf3b1e840855caeb0446d28",
    "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
    "a92f7dd474406a02844ec635fde6c22eb8ef8456",
    "4cdf46f83c775c5101bc664c819fd5c0bb0682f7",
    "3416e058a01d80d22c52c8c6fb720454be4c4290",
    "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
    "73832f8c6e51eb305b88dfc11815801d18b4d567",
    "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "d6d169ac5614ca10aa7d5bade5a695f599823d8a",
    "6991cd9cdf610f94ace3cd8072634106830b439f",
    "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c",
    "234bca64624d0fadd0333e1ec3fc2c680308f081",
    "2ceeff370aff402bd669f9125d93e99d09e8ce71",
    "95b1dbadb0014e791b93d73254903a683bd49433",
    "c8bc54e0ccad49f0785856f911349283619eb8ba",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552",
    "9a271ce6c92695b9421aa603c9aa56e805c7920c",
    "89005a5b7034cc1c2f702eac4bd36836b99f3765",
    "0a790c143feeabf571e98f8ee0700a4586cbb67c",
    "d78eda8aebda0704e29fdccf619e9931b5446efc",
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
    "bbd7fb3969b7fd93c814380209d8f28e2a9c6714",
    "ee553f7804c9cc2ac89b963bcff58974503c20fe",
    "0a4463fb71e6901a943a5bafc9d1957da2229333",
    "f519406c37b23eef816704baeb3a496f7430bb89",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089"
  ],
  "changeHistoryShort": {
    "9a43d2ec208d2e8cd0866431acf26af3529f8677": "Ybodychange",
    "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c": "Ybodychange",
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ybodychange",
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Yannotationchange",
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": "Ybodychange",
    "3295a4e6ef43c3e3053f41404ccf7da6ab53f310": "Ybodychange",
    "d96a66ae8fc01cb480132e909b320a6c6addbfde": "Ybodychange",
    "316244d2bdcb288ef4e6ff58daef6da0511fe765": "Ybodychange",
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": "Ybodychange",
    "03affa02dbb3d629d12228b1622a1d2c8cd37931": "Ybodychange",
    "388bd87ef03b3c080f1c351855d01af1df033a94": "Ybodychange",
    "d3b5aeb768b89d960302b471bd4b3e913dd2df27": "Ybodychange",
    "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e": "Ybodychange",
    "192462902ef3d97c0b6684d467c7d2023ecd5be1": "Ybodychange",
    "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4": "Ybodychange",
    "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae": "Ybodychange",
    "84564a0c7b6c34cec4beede6ee75078a6073abb9": "Ybodychange",
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": "Ybodychange",
    "bbf58008314bd42dd20c92602c1133287423dc7f": "Ymultichange(Ybodychange,Ydocchange)",
    "ce1954da1edd64f1280ead0435c7b3923e33f6da": "Ybodychange",
    "e8dead247c7d421074caf171456e0653d63780f7": "Ybodychange",
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": "Ybodychange",
    "d87838fc6d0923659465ca5b75d8e0ba628afb77": "Ybodychange",
    "ced5ea2f93a474646e9554354ca09c0c12e967e8": "Ybodychange",
    "620c16f5c7bb543b18f71b2848f90461f8646237": "Ybodychange",
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": "Ybodychange",
    "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e": "Ybodychange",
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": "Ybodychange",
    "e10e16cd6b2a2342a6b7d169878117046b6c5e16": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange,Ydocchange)",
    "239ce1466ce118294f5c7b8e842a80815fd813de": "Ybodychange",
    "3f7007f73a3b8d660e9ff0224f1d87483650d2c2": "Ymultichange(Ybodychange,Ydocchange)",
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": "Ybodychange",
    "d3a406876834b91a4cf3b1e840855caeb0446d28": "Ybodychange",
    "6d77f1cf3b3f060ead70d49079bc87d75e0b105c": "Ybodychange",
    "a92f7dd474406a02844ec635fde6c22eb8ef8456": "Ybodychange",
    "4cdf46f83c775c5101bc664c819fd5c0bb0682f7": "Ybodychange",
    "3416e058a01d80d22c52c8c6fb720454be4c4290": "Ybodychange",
    "6d8b37d8bbce8c6e6cb4890291469c80742132f7": "Ybodychange",
    "73832f8c6e51eb305b88dfc11815801d18b4d567": "Ybodychange",
    "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "d6d169ac5614ca10aa7d5bade5a695f599823d8a": "Ybodychange",
    "6991cd9cdf610f94ace3cd8072634106830b439f": "Ybodychange",
    "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c": "Ybodychange",
    "234bca64624d0fadd0333e1ec3fc2c680308f081": "Ybodychange",
    "2ceeff370aff402bd669f9125d93e99d09e8ce71": "Ybodychange",
    "95b1dbadb0014e791b93d73254903a683bd49433": "Ybodychange",
    "c8bc54e0ccad49f0785856f911349283619eb8ba": "Ybodychange",
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": "Ybodychange",
    "9a271ce6c92695b9421aa603c9aa56e805c7920c": "Ybodychange",
    "89005a5b7034cc1c2f702eac4bd36836b99f3765": "Ybodychange",
    "0a790c143feeabf571e98f8ee0700a4586cbb67c": "Ybodychange",
    "d78eda8aebda0704e29fdccf619e9931b5446efc": "Ybodychange",
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": "Ybodychange",
    "bbd7fb3969b7fd93c814380209d8f28e2a9c6714": "Ybodychange",
    "ee553f7804c9cc2ac89b963bcff58974503c20fe": "Ybodychange",
    "0a4463fb71e6901a943a5bafc9d1957da2229333": "Ybodychange",
    "f519406c37b23eef816704baeb3a496f7430bb89": "Ybodychange",
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9a43d2ec208d2e8cd0866431acf26af3529f8677": {
      "type": "Ybodychange",
      "commitMessage": "Revised log levels: less WARN and INFO, fine-tuned DEBUG vs TRACE\n\nIssue: SPR-16946\n",
      "commitDate": "2018/7/20 下午9:05",
      "commitName": "9a43d2ec208d2e8cd0866431acf26af3529f8677",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/6/28 下午8:51",
      "commitNameOld": "40efcc933ca2cb5733655d114f36be035dc9fd54",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 22.01,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                BeanDefinition bdCand \u003d holder.getBeanDefinition().getOriginatingBeanDefinition();\n                if (bdCand \u003d\u003d null) {\n                    bdCand \u003d holder.getBeanDefinition();\n                }\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n                    parse(bdCand.getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource !\u003d null) {\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 261,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,49 +1,49 @@\n @Nullable\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n-            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n+            logger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 BeanDefinition bdCand \u003d holder.getBeanDefinition().getOriginatingBeanDefinition();\n                 if (bdCand \u003d\u003d null) {\n                     bdCand \u003d holder.getBeanDefinition();\n                 }\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n                     parse(bdCand.getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n     if (importResource !\u003d null) {\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c": {
      "type": "Ybodychange",
      "commitMessage": "Introspect originating bean definition as configuration class candidate\n\nIssue: SPR-16756\n",
      "commitDate": "2018/5/2 下午9:20",
      "commitName": "c8b6233bd03d43c8a91ec197e9cf1ea15bba478c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2018/3/30 上午5:50",
      "commitNameOld": "d553ddc5b3a657adebad04d9f3c7d466fbdd7b05",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 33.65,
      "commitsBetweenForRepo": 149,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                BeanDefinition bdCand \u003d holder.getBeanDefinition().getOriginatingBeanDefinition();\n                if (bdCand \u003d\u003d null) {\n                    bdCand \u003d holder.getBeanDefinition();\n                }\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n                    parse(bdCand.getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource !\u003d null) {\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 261,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,45 +1,49 @@\n @Nullable\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                BeanDefinition bdCand \u003d holder.getBeanDefinition().getOriginatingBeanDefinition();\n+                if (bdCand \u003d\u003d null) {\n+                    bdCand \u003d holder.getBeanDefinition();\n+                }\n+                if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n+                    parse(bdCand.getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n     if (importResource !\u003d null) {\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ybodychange",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/7 下午8:19",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/6/1 上午4:51",
      "commitNameOld": "b494c53b40a76a3ce01a54b1bd384b6809f1a147",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n    if (importResource !\u003d null) {\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 260,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,45 +1,45 @@\n @Nullable\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n-    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+    AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+    if (importResource !\u003d null) {\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n-        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n+        if (superclass !\u003d null \u0026\u0026 !superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Yannotationchange",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/5/27 下午2:57",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2017/4/17 下午9:05",
      "commitNameOld": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 39.74,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "actualSource": "@Nullable\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 263,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "@Nullable",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,45 @@\n+@Nullable\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@Nullable"
      }
    },
    "91df0653fe5e22477ec2ed6dbe7e44b835c99038": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2017/4/17 下午9:05",
      "commitName": "91df0653fe5e22477ec2ed6dbe7e44b835c99038",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2017/4/11 下午5:45",
      "commitNameOld": "c4e0d6c2a235fe4896276844d20a60f8510acf09",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.14,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 261,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "",
      "extendedDetails": {}
    },
    "3295a4e6ef43c3e3053f41404ccf7da6ab53f310": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassParser enforces @Bean declaration order through ASM metadata\n\nIssue: SPR-14505\n",
      "commitDate": "2016/12/24 上午3:29",
      "commitName": "3295a4e6ef43c3e3053f41404ccf7da6ab53f310",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/12/9 下午10:01",
      "commitNameOld": "a7ec6dc0afb5ad83371ed073a26a31cb9e1dd4f1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 14.23,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 245,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d retrieveBeanMethodMetadata(sourceClass);\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d96a66ae8fc01cb480132e909b320a6c6addbfde": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassParser uses unified ImportStack with chained import analysis\n\nIssue: SPR-14517\n",
      "commitDate": "2016/7/28 上午6:06",
      "commitName": "d96a66ae8fc01cb480132e909b320a6c6addbfde",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/27 下午10:21",
      "commitNameOld": "316244d2bdcb288ef4e6ff58daef6da0511fe765",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 252,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,50 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                    ImportStack previousStack \u003d this.importStack;\n-                    this.importStack \u003d new ImportStack();\n-                    try {\n-                        parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-                    } finally {\n-                        this.importStack \u003d previousStack;\n-                    }\n+                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "316244d2bdcb288ef4e6ff58daef6da0511fe765": {
      "type": "Ybodychange",
      "commitMessage": "Isolated circular import detection for scanned configuration classes\n\nIssue: SPR-14517\n",
      "commitDate": "2016/7/27 下午10:21",
      "commitName": "316244d2bdcb288ef4e6ff58daef6da0511fe765",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/20 上午1:21",
      "commitNameOld": "aaac199e8bc1e037883f9fa8063828a82142d608",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 7.88,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    ImportStack previousStack \u003d this.importStack;\n                    this.importStack \u003d new ImportStack();\n                    try {\n                        parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                    } finally {\n                        this.importStack \u003d previousStack;\n                    }\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 252,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,50 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                    ImportStack previousStack \u003d this.importStack;\n+                    this.importStack \u003d new ImportStack();\n+                    try {\n+                        parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                    } finally {\n+                        this.importStack \u003d previousStack;\n+                    }\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7": {
      "type": "Ybodychange",
      "commitMessage": "Consistent alias processing behind AnnotatedTypeMetadata abstraction (also for ASM)\n\nIssue: SPR-14427\n",
      "commitDate": "2016/7/15 下午7:59",
      "commitName": "3d3407c78992bbb504ae96a8f3eb17dbca07bcc7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/5 下午11:00",
      "commitNameOld": "00d2606b000f9bdafbd7f4a16b6599fb51b53fa4",
      "commitAuthorOld": "Stephane Nicoll",
      "daysBetweenCommits": 9.87,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"locations\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 252,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n-        String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n+        String[] resources \u003d importResource.getStringArray(\"locations\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03affa02dbb3d629d12228b1622a1d2c8cd37931": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassParser detects @Bean methods in interface hierarchies as well\n\nIssue: SPR-14288\n",
      "commitDate": "2016/5/28 上午4:34",
      "commitName": "03affa02dbb3d629d12228b1622a1d2c8cd37931",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/2/23 上午6:25",
      "commitNameOld": "a3789120c9d5d77a7f3946c9d5d809195de6d243",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 94.92,
      "commitsBetweenForRepo": 408,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    processInterfaces(configClass, sourceClass);\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 252,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,51 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n     if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         for (AnnotationAttributes componentScan : componentScans) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    for (SourceClass ifc : sourceClass.getInterfaces()) {\n-        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n-        for (MethodMetadata methodMetadata : beanMethods) {\n-            if (!methodMetadata.isAbstract()) {\n-                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n-            }\n-        }\n-    }\n+    processInterfaces(configClass, sourceClass);\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "388bd87ef03b3c080f1c351855d01af1df033a94": {
      "type": "Ybodychange",
      "commitMessage": "ComponentScan annotation is repeatable now\n\nIssue: SPR-13151\n",
      "commitDate": "2015/12/30 上午4:40",
      "commitName": "388bd87ef03b3c080f1c351855d01af1df033a94",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/6/15 下午9:46",
      "commitNameOld": "1c01f575c2d3407e5c3c18a58d19ee00f5420249",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 197.29,
      "commitsBetweenForRepo": 933,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        for (AnnotationAttributes componentScan : componentScans) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 246,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,49 +1,51 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n-    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n-    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n-        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n-        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+    Set\u003cAnnotationAttributes\u003e componentScans \u003d AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n+    if (!componentScans.isEmpty() \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+        for (AnnotationAttributes componentScan : componentScans) {\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n+            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     for (SourceClass ifc : sourceClass.getInterfaces()) {\n         beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n         for (MethodMetadata methodMetadata : beanMethods) {\n             if (!methodMetadata.isAbstract()) {\n                 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n             }\n         }\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3b5aeb768b89d960302b471bd4b3e913dd2df27": {
      "type": "Ybodychange",
      "commitMessage": "Introduce alias for \u0027value\u0027 attribute in @ImportResource\n\nIssue: SPR-11393\n",
      "commitDate": "2015/6/4 上午9:26",
      "commitName": "d3b5aeb768b89d960302b471bd4b3e913dd2df27",
      "commitAuthor": "Sam Brannen",
      "commitDateOld": "2015/3/24 上午2:58",
      "commitNameOld": "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 72.27,
      "commitsBetweenForRepo": 427,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 245,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,49 +1,49 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n-        String[] resources \u003d importResource.getStringArray(\"value\");\n+        String[] resources \u003d importResource.getAliasedStringArray(\"locations\", ImportResource.class, sourceClass);\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     for (SourceClass ifc : sourceClass.getInterfaces()) {\n         beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n         for (MethodMetadata methodMetadata : beanMethods) {\n             if (!methodMetadata.isAbstract()) {\n                 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n             }\n         }\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e": {
      "type": "Ybodychange",
      "commitMessage": "Deferred import processing reliably detects late registration attempts\n\nIssue: SPR-12838\n",
      "commitDate": "2015/3/24 上午2:58",
      "commitName": "1a8c6fa5ee9e70ed880cd2e9afefc4fe38283f1e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/3/19 下午11:50",
      "commitNameOld": "192462902ef3d97c0b6684d467c7d2023ecd5be1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 244,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,49 +1,49 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n+    processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     for (SourceClass ifc : sourceClass.getInterfaces()) {\n         beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n         for (MethodMetadata methodMetadata : beanMethods) {\n             if (!methodMetadata.isAbstract()) {\n                 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n             }\n         }\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "192462902ef3d97c0b6684d467c7d2023ecd5be1": {
      "type": "Ybodychange",
      "commitMessage": "Consistent support for Java 8 default methods (in interfaces implemented by user classes)\n\nCovers ReflectionUtils.doWithMethods as well as affected annotation post-processors.\nIncludes an extension of MethodMetadata for the detection of @Bean default methods.\n\nIssue: SPR-12822\nIssue: SPR-10919\n",
      "commitDate": "2015/3/19 下午11:50",
      "commitName": "192462902ef3d97c0b6684d467c7d2023ecd5be1",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/10/30 上午5:08",
      "commitNameOld": "c7a93a80d4866dacafa9bb522062fbf9ef75ddb2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 140.78,
      "commitsBetweenForRepo": 469,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    for (SourceClass ifc : sourceClass.getInterfaces()) {\n        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n        for (MethodMetadata methodMetadata : beanMethods) {\n            if (!methodMetadata.isAbstract()) {\n                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n            }\n        }\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 241,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,41 +1,49 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n+    for (SourceClass ifc : sourceClass.getInterfaces()) {\n+        beanMethods \u003d ifc.getMetadata().getAnnotatedMethods(Bean.class.getName());\n+        for (MethodMetadata methodMetadata : beanMethods) {\n+            if (!methodMetadata.isAbstract()) {\n+                configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n+            }\n+        }\n+    }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2014/8/23 上午7:07",
      "commitName": "078f23d6e65c7c377b7e20681214e2c7fcf5f2b4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/8/22 下午7:54",
      "commitNameOld": "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.47,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 241,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,41 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n         } else {\n             logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n-    if (componentScan !\u003d null) {\n-        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n-            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-                }\n+    if (componentScan !\u003d null \u0026\u0026 !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n+        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+                parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae": {
      "type": "Ybodychange",
      "commitMessage": "Revised ResourcePropertySource in order to avoid ConfigurationClassProcessor\u0027s AnnotationPropertySource subclass\n\nIssue: SPR-12115\n",
      "commitDate": "2014/8/22 下午7:54",
      "commitName": "9dfbc5326b17ab48a0335efa4d82e15e6df0dfae",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/8/22 下午12:21",
      "commitNameOld": "84564a0c7b6c34cec4beede6ee75078a6073abb9",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (this.environment instanceof ConfigurableEnvironment) {\n            processPropertySource(propertySource);\n        } else {\n            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 241,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n-        if (!(this.environment instanceof ConfigurableEnvironment)) {\n-            logger.warn(\"Ignoring @PropertySource annotation on \" + sourceClass.getMetadata().getClassName() + \"Reason: Environment must implement ConfigurableEnvironment\");\n-        } else {\n+        if (this.environment instanceof ConfigurableEnvironment) {\n             processPropertySource(propertySource);\n+        } else {\n+            logger.warn(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() + \"]. Reason: Environment must implement ConfigurableEnvironment\");\n         }\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84564a0c7b6c34cec4beede6ee75078a6073abb9": {
      "type": "Ybodychange",
      "commitMessage": "Rework @PropertySource early parsing logic\n\nRework the @PropertySource parsing logic recently changed in commit\n7c608886 to deal with the same source appearing on a @Configuration\nclass and an @Import class.\n\nProcessing now occurs in a single sweep, with any previously added\nsources being converted to a CompositePropertySource.\n\nIssue: SPR-12115\n",
      "commitDate": "2014/8/22 下午12:21",
      "commitName": "84564a0c7b6c34cec4beede6ee75078a6073abb9",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2014/8/22 上午4:43",
      "commitNameOld": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        if (!(this.environment instanceof ConfigurableEnvironment)) {\n            logger.warn(\"Ignoring @PropertySource annotation on \" + sourceClass.getMetadata().getClassName() + \"Reason: Environment must implement ConfigurableEnvironment\");\n        } else {\n            processPropertySource(propertySource);\n        }\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 240,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,40 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n-        processPropertySource(propertySource);\n+        if (!(this.environment instanceof ConfigurableEnvironment)) {\n+            logger.warn(\"Ignoring @PropertySource annotation on \" + sourceClass.getMetadata().getClassName() + \"Reason: Environment must implement ConfigurableEnvironment\");\n+        } else {\n+            processPropertySource(propertySource);\n+        }\n     }\n-    registerPropertySources();\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6": {
      "type": "Ybodychange",
      "commitMessage": "@PropertySource gets parsed as early as possible\n\nOther PropertySources and in particular @ComponentScan can benefit from previously declared property sources on the same configuration class.\n\nIssue: SPR-12110\nIssue: SPR-12111\n",
      "commitDate": "2014/8/22 上午4:43",
      "commitName": "7c6088861f9e59f4e29c7f9d47a2cf467c4e8cd6",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/8/12 下午11:23",
      "commitNameOld": "71c6eb2bb594f29803b6ec4a50de875def98be86",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 9.22,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    registerPropertySources();\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 238,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
      "diff": "@@ -1,39 +1,40 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n+    registerPropertySources();\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbf58008314bd42dd20c92602c1133287423dc7f": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "ConfigurationClassParser processes late-arriving DeferredImportSelectors as regular import selectors\n\nAlso contains refined exception handling, treating regular class loading and ASM-based loading consistently in terms of exception wrapping, and always mentioning the current configuration class in all exception messages.\n\nIssue: SPR-11997\n",
      "commitDate": "2014/7/16 上午4:04",
      "commitName": "bbf58008314bd42dd20c92602c1133287423dc7f",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "ConfigurationClassParser processes late-arriving DeferredImportSelectors as regular import selectors\n\nAlso contains refined exception handling, treating regular class loading and ASM-based loading consistently in terms of exception wrapping, and always mentioning the current configuration class in all exception messages.\n\nIssue: SPR-11997\n",
          "commitDate": "2014/7/16 上午4:04",
          "commitName": "bbf58008314bd42dd20c92602c1133287423dc7f",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2014/6/6 下午8:01",
          "commitNameOld": "6aa9c40552c8b446ffcbd71bf2edc17b5ca38c77",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 39.34,
          "commitsBetweenForRepo": 230,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 236,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
          "diff": "@@ -1,43 +1,39 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    processImports(configClass, sourceClass, getImports(sourceClass), true);\n+    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            try {\n-                return sourceClass.getSuperClass();\n-            } catch (ClassNotFoundException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "ConfigurationClassParser processes late-arriving DeferredImportSelectors as regular import selectors\n\nAlso contains refined exception handling, treating regular class loading and ASM-based loading consistently in terms of exception wrapping, and always mentioning the current configuration class in all exception messages.\n\nIssue: SPR-11997\n",
          "commitDate": "2014/7/16 上午4:04",
          "commitName": "bbf58008314bd42dd20c92602c1133287423dc7f",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2014/6/6 下午8:01",
          "commitNameOld": "6aa9c40552c8b446ffcbd71bf2edc17b5ca38c77",
          "commitAuthorOld": "Juergen Hoeller",
          "daysBetweenCommits": 39.34,
          "commitsBetweenForRepo": 230,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 236,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n",
          "diff": "@@ -1,43 +1,39 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    processImports(configClass, sourceClass, getImports(sourceClass), true);\n+    processImports(configClass, sourceClass, getImports(sourceClass), true, false);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            try {\n-                return sourceClass.getSuperClass();\n-            } catch (ClassNotFoundException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
            "newValue": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, or {@code null} if none found or previously processed\n"
          }
        }
      ]
    },
    "ce1954da1edd64f1280ead0435c7b3923e33f6da": {
      "type": "Ybodychange",
      "commitMessage": "Configuration class processing explicitly skips java.* classes since we\u0027ll never find @Bean annotations there anyway\n\nIssue: SPR-11718\n(cherry picked from commit c8ea80d)\n",
      "commitDate": "2014/4/28 上午6:33",
      "commitName": "ce1954da1edd64f1280ead0435c7b3923e33f6da",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/4/9 下午11:43",
      "commitNameOld": "0041e245a1f80affba828c79fd8db13b0319fb85",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 18.28,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 220,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n-        if (!this.knownSuperclasses.containsKey(superclass)) {\n+        if (!superclass.startsWith(\"java\") \u0026\u0026 !this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e8dead247c7d421074caf171456e0653d63780f7": {
      "type": "Ybodychange",
      "commitMessage": "@EnableTransactionManagement and co get detected on superclasses as well\n\nIssue: SPR-10864\n",
      "commitDate": "2013/12/2 下午5:59",
      "commitName": "e8dead247c7d421074caf171456e0653d63780f7",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/11/26 上午4:52",
      "commitNameOld": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 6.55,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, sourceClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 220,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    processImports(configClass, getImports(sourceClass), true);\n+    processImports(configClass, sourceClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e95bd9e25086bf1dad37f8d08293c948621faf6b": {
      "type": "Ybodychange",
      "commitMessage": "Add @PropertySources and ignoreResourceNotFound\n\nSupport repeatable @PropertySource annotations in Java 8 and add\n@PropertySources container annotation for Java 6/7. Also add an\nignoreResourceNotFound attribute to @PropertySource allowing missing\nproperty resources to be silently ignored.\n\nThis commit also introduces some generally useful methods to\nAnnotationUtils for working with @Repeatable annotations.\n\nIssue: SPR-8371\n",
      "commitDate": "2013/10/23 上午2:15",
      "commitName": "e95bd9e25086bf1dad37f8d08293c948621faf6b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/10/22 上午4:11",
      "commitNameOld": "e3d3d8cd9569ceb5db3dd00d8104a979c7dfe82d",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 220,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n-    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n-    if (propertySource !\u003d null) {\n+    for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d87838fc6d0923659465ca5b75d8e0ba628afb77": {
      "type": "Ybodychange",
      "commitMessage": "Polishing\n",
      "commitDate": "2013/10/16 上午7:51",
      "commitName": "d87838fc6d0923659465ca5b75d8e0ba628afb77",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/8/28 上午6:00",
      "commitNameOld": "5efe894ee4969a7c3780a2fd4d2ceab695777c50",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 49.08,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 216,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+        if (!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ced5ea2f93a474646e9554354ca09c0c12e967e8": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Ensure @Conditions consider super classes\"\n\nThis reverts commit 620c16f5c7bb543b18f71b2848f90461f8646237.\n",
      "commitDate": "2013/8/28 上午1:39",
      "commitName": "ced5ea2f93a474646e9554354ca09c0c12e967e8",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/8/27 上午8:12",
      "commitNameOld": "620c16f5c7bb543b18f71b2848f90461f8646237",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 219,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,40 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        if (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n+        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            return sourceClass.getSuperClass();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "620c16f5c7bb543b18f71b2848f90461f8646237": {
      "type": "Ybodychange",
      "commitMessage": "Ensure @Conditions consider super classes\n\nFix @Condition evaluation to also consider super classes for both\n@Configuration classes and regular @Components. This change allows\n@Conditional annotations to be inherited and restores the previous\nbehavior of @Profile.\n\nIssue: SPR-10840\n",
      "commitDate": "2013/8/27 上午8:12",
      "commitName": "620c16f5c7bb543b18f71b2848f90461f8646237",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/8/23 下午10:49",
      "commitNameOld": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.39,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            return sourceClass.getSuperClass();\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 220,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,40 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n+        if (!shouldSkip(sourceClass, ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            try {\n-                return sourceClass.getSuperClass();\n-            } catch (ClassNotFoundException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            return sourceClass.getSuperClass();\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65": {
      "type": "Ybodychange",
      "commitMessage": "Introduced @Description annotation for populating BeanDefinition.getDescription()\n\nIssue: SPR-10583\n",
      "commitDate": "2013/8/23 下午10:49",
      "commitName": "c9771012e98afe1679cd1c3ebf5ab6c1a018fd65",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/7/31 上午4:36",
      "commitNameOld": "481aeeec984433f11781a1999328f9c85848d1b3",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 23.76,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 219,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,44 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n-    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n+    AnnotationAttributes propertySource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n+        AnnotationAttributes importResource \u003d AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n             configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e": {
      "type": "Ybodychange",
      "commitMessage": "Resolve ${} placeholders in @ImportResource\n\nUpdate ConfigurationClassParser to resolve any ${} placeholders from\n@ImportResource values.\n\nIssue: SPR-10686\n",
      "commitDate": "2013/7/20 上午4:10",
      "commitName": "1a8f0d6a9e37d12b31a2fe7bc1fbc2c91700a08e",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/6/13 上午2:45",
      "commitNameOld": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 37.06,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n            configClass.addImportedResource(resolvedResource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 222,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,44 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n-            configClass.addImportedResource(resource, readerClass);\n+            String resolvedResource \u003d this.environment.resolveRequiredPlaceholders(resource);\n+            configClass.addImportedResource(resolvedResource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6": {
      "type": "Ybodychange",
      "commitMessage": "Improve support for @Conditional on @Configuration\n\nIntroduce new ConfigurationCondition interface allowing more\nfine-grained control for @Conditional when used with @Configuration\nbeans.\n\nPrimarily added so that the evaluation of conditions that inspect bean\ndefinitions can be deferred until all @Configuration classes have been\nparsed.\n\nIssue: SPR-10534\n",
      "commitDate": "2013/6/13 上午2:45",
      "commitName": "2e2e9b8dd0ecb113c86ec3a5d0cf87d4f6f72fd6",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/6/11 上午12:25",
      "commitNameOld": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 222,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,43 +1,43 @@\n protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n     processMemberClasses(configClass, sourceClass);\n     AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n+        if (!conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n             Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                    parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n     processImports(configClass, getImports(sourceClass), true);\n     if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (sourceClass.getMetadata().hasSuperClass()) {\n         String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             try {\n                 return sourceClass.getSuperClass();\n             } catch (ClassNotFoundException ex) {\n                 throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "e10e16cd6b2a2342a6b7d169878117046b6c5e16": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
      "commitDate": "2013/6/11 上午12:25",
      "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
      "commitAuthor": "Phillip Webb",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
          "commitDate": "2013/6/11 上午12:25",
          "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2013/6/5 上午1:27",
          "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 211,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,56 +1,43 @@\n-protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(configClass, metadata);\n-    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+    processMemberClasses(configClass, sourceClass);\n+    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n-    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n-    collectImports(metadata, imports, visited);\n-    if (!imports.isEmpty()) {\n-        processImport(configClass, imports, true);\n-    }\n-    if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n+    processImports(configClass, getImports(sourceClass), true);\n+    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    if (metadata.hasSuperClass()) {\n-        String superclass \u003d metadata.getSuperClassName();\n+    if (sourceClass.getMetadata().hasSuperClass()) {\n+        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            if (metadata instanceof StandardAnnotationMetadata) {\n-                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n-            } else if (superclass.startsWith(\"java\")) {\n-                try {\n-                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n-                } catch (ClassNotFoundException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            } else {\n-                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n-                return reader.getAnnotationMetadata();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[configClass-ConfigurationClass, metadata-AnnotationMetadata]",
            "newValue": "[configClass-ConfigurationClass, sourceClass-SourceClass]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
          "commitDate": "2013/6/11 上午12:25",
          "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2013/6/5 上午1:27",
          "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 211,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,56 +1,43 @@\n-protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(configClass, metadata);\n-    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+    processMemberClasses(configClass, sourceClass);\n+    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n-    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n-    collectImports(metadata, imports, visited);\n-    if (!imports.isEmpty()) {\n-        processImport(configClass, imports, true);\n-    }\n-    if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n+    processImports(configClass, getImports(sourceClass), true);\n+    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    if (metadata.hasSuperClass()) {\n-        String superclass \u003d metadata.getSuperClassName();\n+    if (sourceClass.getMetadata().hasSuperClass()) {\n+        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            if (metadata instanceof StandardAnnotationMetadata) {\n-                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n-            } else if (superclass.startsWith(\"java\")) {\n-                try {\n-                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n-                } catch (ClassNotFoundException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            } else {\n-                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n-                return reader.getAnnotationMetadata();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "AnnotationMetadata",
            "newValue": "SourceClass"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
          "commitDate": "2013/6/11 上午12:25",
          "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2013/6/5 上午1:27",
          "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 211,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,56 +1,43 @@\n-protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(configClass, metadata);\n-    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+    processMemberClasses(configClass, sourceClass);\n+    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n-    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n-    collectImports(metadata, imports, visited);\n-    if (!imports.isEmpty()) {\n-        processImport(configClass, imports, true);\n-    }\n-    if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n+    processImports(configClass, getImports(sourceClass), true);\n+    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    if (metadata.hasSuperClass()) {\n-        String superclass \u003d metadata.getSuperClassName();\n+    if (sourceClass.getMetadata().hasSuperClass()) {\n+        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            if (metadata instanceof StandardAnnotationMetadata) {\n-                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n-            } else if (superclass.startsWith(\"java\")) {\n-                try {\n-                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n-                } catch (ClassNotFoundException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            } else {\n-                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n-                return reader.getAnnotationMetadata();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[protected, final]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
          "commitDate": "2013/6/11 上午12:25",
          "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2013/6/5 上午1:27",
          "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 211,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,56 +1,43 @@\n-protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(configClass, metadata);\n-    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+    processMemberClasses(configClass, sourceClass);\n+    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n-    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n-    collectImports(metadata, imports, visited);\n-    if (!imports.isEmpty()) {\n-        processImport(configClass, imports, true);\n-    }\n-    if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n+    processImports(configClass, getImports(sourceClass), true);\n+    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    if (metadata.hasSuperClass()) {\n-        String superclass \u003d metadata.getSuperClassName();\n+    if (sourceClass.getMetadata().hasSuperClass()) {\n+        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            if (metadata instanceof StandardAnnotationMetadata) {\n-                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n-            } else if (superclass.startsWith(\"java\")) {\n-                try {\n-                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n-                } catch (ClassNotFoundException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            } else {\n-                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n-                return reader.getAnnotationMetadata();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Support fall-back to ASM parsing @Configuration\n\nUpdate ConfigurationClassParser to fall-back to ASM parsing if standard\nannotation processing fails. This change allows @Conditional annotations\nthat refer to missing classes to work.\n\nThis commit also introduces a new inner SourceClass object that\nencapsulates the conditional logic required when reading the source\nclasses.\n\nIssue: SPR-10646\n",
          "commitDate": "2013/6/11 上午12:25",
          "commitName": "e10e16cd6b2a2342a6b7d169878117046b6c5e16",
          "commitAuthor": "Phillip Webb",
          "commitDateOld": "2013/6/5 上午1:27",
          "commitNameOld": "239ce1466ce118294f5c7b8e842a80815fd813de",
          "commitAuthorOld": "Phillip Webb",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "actualSource": "protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n    processMemberClasses(configClass, sourceClass);\n    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    processImports(configClass, getImports(sourceClass), true);\n    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (sourceClass.getMetadata().hasSuperClass()) {\n        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            try {\n                return sourceClass.getSuperClass();\n            } catch (ClassNotFoundException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 211,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,56 +1,43 @@\n-protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(configClass, metadata);\n-    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n+protected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n+    processMemberClasses(configClass, sourceClass);\n+    AnnotationAttributes propertySource \u003d attributesFor(sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n-    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n+    AnnotationAttributes componentScan \u003d attributesFor(sourceClass.getMetadata(), ComponentScan.class);\n     if (componentScan !\u003d null) {\n         if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n-            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n             for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                 if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 }\n             }\n         }\n     }\n-    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n-    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n-    collectImports(metadata, imports, visited);\n-    if (!imports.isEmpty()) {\n-        processImport(configClass, imports, true);\n-    }\n-    if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n+    processImports(configClass, getImports(sourceClass), true);\n+    if (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) {\n+        AnnotationAttributes importResource \u003d attributesFor(sourceClass.getMetadata(), ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d sourceClass.getMetadata().getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n-    if (metadata.hasSuperClass()) {\n-        String superclass \u003d metadata.getSuperClassName();\n+    if (sourceClass.getMetadata().hasSuperClass()) {\n+        String superclass \u003d sourceClass.getMetadata().getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n-            if (metadata instanceof StandardAnnotationMetadata) {\n-                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n-                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n-            } else if (superclass.startsWith(\"java\")) {\n-                try {\n-                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n-                } catch (ClassNotFoundException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            } else {\n-                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n-                return reader.getAnnotationMetadata();\n+            try {\n+                return sourceClass.getSuperClass();\n+            } catch (ClassNotFoundException ex) {\n+                throw new IllegalStateException(ex);\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\n@return annotation metadata of superclass, {@code null} if none found or previously processed\n",
            "newValue": "Apply processing and build a complete {@link ConfigurationClass} by reading the\nannotations, members and methods from the source class. This method can be called\nmultiple times as relevant sources are discovered.\n\n@param configClass the configuration class being build\n@param sourceClass a source class\n@return the superclass, {@code null} if none found or previously processed\n"
          }
        }
      ]
    },
    "239ce1466ce118294f5c7b8e842a80815fd813de": {
      "type": "Ybodychange",
      "commitMessage": "Update @Conditional processing logic\n\nDefer @Conditional processing on @Configuration classes until the bean\ndefinitions are loaded, rather than when the @Configuration class is\nparsed. This provides better support for @Conditional implementations\nthat inspect bean definitions.\n\nThis commit also fixes some minor problems with original implementation\nand replaces the ConditionalAnnotationHelper class with\nConditionEvaluator.\n\nIssue: SPR-10534\n",
      "commitDate": "2013/6/5 上午1:27",
      "commitName": "239ce1466ce118294f5c7b8e842a80815fd813de",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/6/4 上午3:19",
      "commitNameOld": "4d3383242e5655631e44dee48ca7060add84f957",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                }\n            }\n        }\n    }\n    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 208,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, {@code null} if none found or previously processed\n",
      "diff": "@@ -1,54 +1,56 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     processMemberClasses(configClass, metadata);\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n-        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n-            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n-                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+        if (!ConditionEvaluator.get(configClass.getMetadata(), false).shouldSkip(this.registry, this.environment)) {\n+            Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n+            for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+                if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n+                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                }\n             }\n         }\n     }\n     Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n     Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n     collectImports(metadata, imports, visited);\n     if (!imports.isEmpty()) {\n         processImport(configClass, imports, true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (!this.knownSuperclasses.containsKey(superclass)) {\n             this.knownSuperclasses.put(superclass, configClass);\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3f7007f73a3b8d660e9ff0224f1d87483650d2c2": {
      "type": "Ymultichange(Ybodychange,Ydocchange)",
      "commitMessage": "Properly handle knownSuperclasses in case of an overridden ConfigurationClass\n\nIssue: SPR-10546\n(cherry picked from commit 6e4317e)\n",
      "commitDate": "2013/5/15 下午8:30",
      "commitName": "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Properly handle knownSuperclasses in case of an overridden ConfigurationClass\n\nIssue: SPR-10546\n(cherry picked from commit 6e4317e)\n",
          "commitDate": "2013/5/15 下午8:30",
          "commitName": "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2013/5/14 上午6:04",
          "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
          "commitAuthorOld": "Rob Winch",
          "daysBetweenCommits": 1.6,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 212,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "\n@return annotation metadata of superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,53 +1,54 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     processMemberClasses(configClass, metadata);\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n     Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n     collectImports(metadata, imports, visited);\n     if (!imports.isEmpty()) {\n         processImport(configClass, imports, true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n-        if (this.knownSuperclasses.add(superclass)) {\n+        if (!this.knownSuperclasses.containsKey(superclass)) {\n+            this.knownSuperclasses.put(superclass, configClass);\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "Properly handle knownSuperclasses in case of an overridden ConfigurationClass\n\nIssue: SPR-10546\n(cherry picked from commit 6e4317e)\n",
          "commitDate": "2013/5/15 下午8:30",
          "commitName": "3f7007f73a3b8d660e9ff0224f1d87483650d2c2",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2013/5/14 上午6:04",
          "commitNameOld": "94685481162a93666fc2f39b66223833a6bcb418",
          "commitAuthorOld": "Rob Winch",
          "daysBetweenCommits": 1.6,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (!this.knownSuperclasses.containsKey(superclass)) {\n            this.knownSuperclasses.put(superclass, configClass);\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
          "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
          "functionStartLine": 212,
          "functionName": "doProcessConfigurationClass",
          "functionAnnotation": "",
          "functionDoc": "\n@return annotation metadata of superclass, {@code null} if none found or previously processed\n",
          "diff": "@@ -1,53 +1,54 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     processMemberClasses(configClass, metadata);\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n     Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n     collectImports(metadata, imports, visited);\n     if (!imports.isEmpty()) {\n         processImport(configClass, imports, true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n-        if (this.knownSuperclasses.add(superclass)) {\n+        if (!this.knownSuperclasses.containsKey(superclass)) {\n+            this.knownSuperclasses.put(superclass, configClass);\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
            "newValue": "\n@return annotation metadata of superclass, {@code null} if none found or previously processed\n"
          }
        }
      ]
    },
    "b257253a2b6890ef532f27a662c441fc4fd21f3b": {
      "type": "Ybodychange",
      "commitMessage": "Support for @Conditional configuration\n\nIntroduce new @Conditional annotation that can be used to filter\nwhich @Configuration classes or methods are loaded. @Conditional\ncan be used directly or as a meta-annotation. Condition implementations\nare provided via the \u0027Condition\u0027 interface and are free to filter based\non any criteria available at the time that they run. The\nConditionalContext provides access to the BeanDefinitionRegistry,\nEnvironment and ConfigurableListableBeanFactory along with a\nResourceLoader and ClassLoader.\n\nThe existing @Profile annotation has been refactored as a @Conditional\nwith the added benefit that it can now be used as a method level\nannotation.\n",
      "commitDate": "2013/5/9 上午10:41",
      "commitName": "b257253a2b6890ef532f27a662c441fc4fd21f3b",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/5/7 上午6:43",
      "commitNameOld": "db0d780d4339953276447e034a6143abc3d83db9",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(configClass, metadata);\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 175,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,53 +1,53 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    processMemberClasses(metadata);\n+    processMemberClasses(configClass, metadata);\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n     Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n     collectImports(metadata, imports, visited);\n     if (!imports.isEmpty()) {\n         processImport(configClass, imports, true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3a406876834b91a4cf3b1e840855caeb0446d28": {
      "type": "Ybodychange",
      "commitMessage": "Minimized ASM usage\n\nIn particular, avoid accidental usage of ASM for core JDK types - which will fail in case of a new bytecode version in the JDK, even if the application itself has been compiled with an earlier bytecode target.\n\nIssue: SPR-10292\n",
      "commitDate": "2013/4/23 下午7:49",
      "commitName": "d3a406876834b91a4cf3b1e840855caeb0446d28",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2013/1/31 下午11:51",
      "commitNameOld": "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 81.83,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    processMemberClasses(metadata);\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        processPropertySource(propertySource);\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n    collectImports(metadata, imports, visited);\n    if (!imports.isEmpty()) {\n        processImport(configClass, imports, true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 172,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,81 +1,53 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    for (String memberClassName : metadata.getMemberClassNames()) {\n-        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n-        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n-        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n-            processConfigurationClass(new ConfigurationClass(reader, true));\n-        }\n-    }\n+    processMemberClasses(metadata);\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n-        String name \u003d propertySource.getString(\"name\");\n-        String[] locations \u003d propertySource.getStringArray(\"value\");\n-        int nLocations \u003d locations.length;\n-        if (nLocations \u003d\u003d 0) {\n-            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n-        }\n-        for (int i \u003d 0; i \u003c nLocations; i++) {\n-            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n-        }\n-        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n-        if (!StringUtils.hasText(name)) {\n-            for (String location : locations) {\n-                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n-            }\n-        } else {\n-            if (nLocations \u003d\u003d 1) {\n-                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n-            } else {\n-                CompositePropertySource ps \u003d new CompositePropertySource(name);\n-                for (String location : locations) {\n-                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n-                }\n-                this.propertySources.push(ps);\n-            }\n-        }\n+        processPropertySource(propertySource);\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n-    if (!CollectionUtils.isEmpty(imports)) {\n-        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n+    Set\u003cObject\u003e imports \u003d new LinkedHashSet\u003cObject\u003e();\n+    Set\u003cObject\u003e visited \u003d new LinkedHashSet\u003cObject\u003e();\n+    collectImports(metadata, imports, visited);\n+    if (!imports.isEmpty()) {\n+        processImport(configClass, imports, true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d77f1cf3b3f060ead70d49079bc87d75e0b105c": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassPostProcessor consistently uses ClassLoader, not loading core JDK annotations via ASM\n\nIssue: SPR-10249\n",
      "commitDate": "2013/1/31 下午11:51",
      "commitName": "6d77f1cf3b3f060ead70d49079bc87d75e0b105c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/12/6 上午2:12",
      "commitNameOld": "a92f7dd474406a02844ec635fde6c22eb8ef8456",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 56.9,
      "commitsBetweenForRepo": 297,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n    if (!CollectionUtils.isEmpty(imports)) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 170,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,81 +1,81 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n-    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n+    if (!CollectionUtils.isEmpty(imports)) {\n         processImport(configClass, imports.toArray(new String[imports.size()]), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else if (superclass.startsWith(\"java\")) {\n                 try {\n                     return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                 } catch (ClassNotFoundException ex) {\n                     throw new IllegalStateException(ex);\n                 }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a92f7dd474406a02844ec635fde6c22eb8ef8456": {
      "type": "Ybodychange",
      "commitMessage": "ConfigurationClassPostProcessor consistently uses ClassLoader, not loading core JDK classes via ASM\n\nIssue: SPR-10058\n",
      "commitDate": "2012/12/6 上午2:12",
      "commitName": "a92f7dd474406a02844ec635fde6c22eb8ef8456",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/11/13 上午1:26",
      "commitNameOld": "146a66fe0b7a0bb25b67ce5e2d1ca8a33039ec59",
      "commitAuthorOld": "Oliver Gierke",
      "daysBetweenCommits": 23.03,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else if (superclass.startsWith(\"java\")) {\n                try {\n                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n                } catch (ClassNotFoundException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 169,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,75 +1,81 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n     if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n         processImport(configClass, imports.toArray(new String[imports.size()]), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n+            } else if (superclass.startsWith(\"java\")) {\n+                try {\n+                    return new StandardAnnotationMetadata(this.resourceLoader.getClassLoader().loadClass(superclass), true);\n+                } catch (ClassNotFoundException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4cdf46f83c775c5101bc664c819fd5c0bb0682f7": {
      "type": "Ybodychange",
      "commitMessage": "Polish @Imports search code\n\nIssue: SPR-9925\n",
      "commitDate": "2012/11/1 上午12:30",
      "commitName": "4cdf46f83c775c5101bc664c819fd5c0bb0682f7",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2012/10/31 下午8:40",
      "commitNameOld": "3416e058a01d80d22c52c8c6fb720454be4c4290",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 163,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,72 +1,75 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    processImport(configClass, getImports(metadata.getClassName()), true);\n+    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n+    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n+        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n+    }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3416e058a01d80d22c52c8c6fb720454be4c4290": {
      "type": "Ybodychange",
      "commitMessage": "Ensure @Imports are processed in correct order\n\nIssue: SPR-9925\n",
      "commitDate": "2012/10/31 下午8:40",
      "commitName": "3416e058a01d80d22c52c8c6fb720454be4c4290",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2012/10/31 下午4:42",
      "commitNameOld": "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    processImport(configClass, getImports(metadata.getClassName()), true);\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 166,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,75 +1,72 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n-    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n-        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n-    }\n+    processImport(configClass, getImports(metadata.getClassName()), true);\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6d8b37d8bbce8c6e6cb4890291469c80742132f7": {
      "type": "Ybodychange",
      "commitMessage": "Prevent duplicate @Import processing\n\nRefactor ConfigurationClassParser to recursively find values from\nall @Import annotations, combining them into a single unique set.\n\nThis change prevents ImportBeanDefinitionRegistrars from being\ninvoked twice.\n\nIssue: SPR-9925\n",
      "commitDate": "2012/10/31 下午4:42",
      "commitName": "6d8b37d8bbce8c6e6cb4890291469c80742132f7",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2012/9/11 下午10:50",
      "commitNameOld": "73832f8c6e51eb305b88dfc11815801d18b4d567",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 49.74,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 163,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,75 +1,75 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    List\u003cAnnotationAttributes\u003e imports \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n-    for (AnnotationAttributes importAnno : imports) {\n-        processImport(configClass, importAnno.getStringArray(\"value\"), true);\n+    Set\u003cString\u003e imports \u003d getImports(metadata.getClassName(), null, new HashSet\u003cString\u003e());\n+    if (imports !\u003d null \u0026\u0026 !imports.isEmpty()) {\n+        processImport(configClass, imports.toArray(new String[imports.size()]), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "73832f8c6e51eb305b88dfc11815801d18b4d567": {
      "type": "Ybodychange",
      "commitMessage": "Support inferred base package for @ComponentScan\n\nPrior to this change, @ComponentScan required the declaration of\nexactly one of the #value, #basePackage or #basePackageClasses\nattributes in order to determine which package(s) to scan.\n\nThis commit introduces support for base package inference, relaxing the\nabove requirement and falling back to scanning the package in which the\n@ComponentScan-annotated class is declared.\n\nIssue: SPR-9586\n",
      "commitDate": "2012/9/11 下午10:50",
      "commitName": "73832f8c6e51eb305b88dfc11815801d18b4d567",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2012/9/11 上午5:16",
      "commitNameOld": "0a42c80c1151380f7f492ec75de5648cfe62d250",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List\u003cAnnotationAttributes\u003e imports \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (AnnotationAttributes importAnno : imports) {\n        processImport(configClass, importAnno.getStringArray(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 164,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,75 +1,75 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n             locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n-        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan);\n+        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan, metadata.getClassName());\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     List\u003cAnnotationAttributes\u003e imports \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (AnnotationAttributes importAnno : imports) {\n         processImport(configClass, importAnno.getStringArray(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48": {
      "type": "Ybodychange",
      "commitMessage": "Fix regression in @PropertySource placeholder resolution\n\nChanges in commit 41ade68b50b39485b3cf02b9c6fb8eb74962146b introduced\na regression causing all but the first location in the\n@PropertySource#value array to be ignored during ${...} placeholder\nresolution. This change ensures that all locations are processed and\nreplaced as expected.\n\nIssue: SPR-9133, SPR-9127\n",
      "commitDate": "2012/2/20 下午9:21",
      "commitName": "4df2a14b13ac41d71f8034fa68e1b7e54e3f7a48",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/2/20 下午9:19",
      "commitNameOld": "37d547c506f9fab4f478c1e4bc0f1b8e553bd950",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, true));\n        }\n    }\n    AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n    if (propertySource !\u003d null) {\n        String name \u003d propertySource.getString(\"name\");\n        String[] locations \u003d propertySource.getStringArray(\"value\");\n        int nLocations \u003d locations.length;\n        if (nLocations \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n        }\n        for (int i \u003d 0; i \u003c nLocations; i++) {\n            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n        }\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        if (!StringUtils.hasText(name)) {\n            for (String location : locations) {\n                this.propertySources.push(new ResourcePropertySource(location, classLoader));\n            }\n        } else {\n            if (nLocations \u003d\u003d 1) {\n                this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n            } else {\n                CompositePropertySource ps \u003d new CompositePropertySource(name);\n                for (String location : locations) {\n                    ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                }\n                this.propertySources.push(ps);\n            }\n        }\n    }\n    AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n    if (componentScan !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List\u003cAnnotationAttributes\u003e imports \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (AnnotationAttributes importAnno : imports) {\n        processImport(configClass, importAnno.getStringArray(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n        String[] resources \u003d importResource.getStringArray(\"value\");\n        Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n    if (metadata.hasSuperClass()) {\n        String superclass \u003d metadata.getSuperClassName();\n        if (this.knownSuperclasses.add(superclass)) {\n            if (metadata instanceof StandardAnnotationMetadata) {\n                Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n            } else {\n                MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                return reader.getAnnotationMetadata();\n            }\n        }\n    }\n    return null;\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 165,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "\n@return annotation metadata of superclass, null if none found or previously processed\n",
      "diff": "@@ -1,75 +1,75 @@\n protected AnnotationMetadata doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, true));\n         }\n     }\n     AnnotationAttributes propertySource \u003d attributesFor(metadata, org.springframework.context.annotation.PropertySource.class);\n     if (propertySource !\u003d null) {\n         String name \u003d propertySource.getString(\"name\");\n         String[] locations \u003d propertySource.getStringArray(\"value\");\n         int nLocations \u003d locations.length;\n         if (nLocations \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"At least one @PropertySource(value) location is required\");\n         }\n         for (int i \u003d 0; i \u003c nLocations; i++) {\n-            locations[0] \u003d this.environment.resolveRequiredPlaceholders(locations[0]);\n+            locations[i] \u003d this.environment.resolveRequiredPlaceholders(locations[i]);\n         }\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         if (!StringUtils.hasText(name)) {\n             for (String location : locations) {\n                 this.propertySources.push(new ResourcePropertySource(location, classLoader));\n             }\n         } else {\n             if (nLocations \u003d\u003d 1) {\n                 this.propertySources.push(new ResourcePropertySource(name, locations[0], classLoader));\n             } else {\n                 CompositePropertySource ps \u003d new CompositePropertySource(name);\n                 for (String location : locations) {\n                     ps.addPropertySource(new ResourcePropertySource(location, classLoader));\n                 }\n                 this.propertySources.push(ps);\n             }\n         }\n     }\n     AnnotationAttributes componentScan \u003d attributesFor(metadata, ComponentScan.class);\n     if (componentScan !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScan);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), this.metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     List\u003cAnnotationAttributes\u003e imports \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (AnnotationAttributes importAnno : imports) {\n         processImport(configClass, importAnno.getStringArray(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         AnnotationAttributes importResource \u003d attributesFor(metadata, ImportResource.class);\n         String[] resources \u003d importResource.getStringArray(\"value\");\n         Class\u003c? extends BeanDefinitionReader\u003e readerClass \u003d importResource.getClass(\"reader\");\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n     if (metadata.hasSuperClass()) {\n         String superclass \u003d metadata.getSuperClassName();\n         if (this.knownSuperclasses.add(superclass)) {\n             if (metadata instanceof StandardAnnotationMetadata) {\n                 Class\u003c?\u003e clazz \u003d ((StandardAnnotationMetadata) metadata).getIntrospectedClass();\n                 return new StandardAnnotationMetadata(clazz.getSuperclass(), true);\n             } else {\n                 MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(superclass);\n                 return reader.getAnnotationMetadata();\n             }\n         }\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location \u003d this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 163,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
        "newPath": "spring-context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java"
      }
    },
    "d6d169ac5614ca10aa7d5bade5a695f599823d8a": {
      "type": "Ybodychange",
      "commitMessage": "resolved package dependency tangles\n",
      "commitDate": "2011/11/29 上午9:16",
      "commitName": "d6d169ac5614ca10aa7d5bade5a695f599823d8a",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/11/29 上午5:35",
      "commitNameOld": "6991cd9cdf610f94ace3cd8072634106830b439f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location \u003d this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 163,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,47 +1,47 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n-        if (isConfigurationCandidate(memberClassMetadata)) {\n+        if (ConfigurationClassUtils.isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, null));\n         }\n     }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n         String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         for (String location : locations) {\n             location \u003d this.environment.resolveRequiredPlaceholders(location);\n             ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n             this.propertySources.push(ps);\n         }\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n-    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n+    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6991cd9cdf610f94ace3cd8072634106830b439f": {
      "type": "Ybodychange",
      "commitMessage": "Allow @Configuration classes to self-@ComponentScan\n\nPrior to this change, a @Configuration classes that @ComponentScan\nthemselves would result in a ConflictingBeanDefinitionException.\n\nFor example:\n\n    package com.foo.config;\n\n    @Configuration\n    @ComponentScan(\"com.foo\");\n    public class AppConfig {\n        // ...\n    }\n\nThis resulted in a ConflictingBeanDefinitionException that users have\ntypically worked around in the following fashion:\n\n    package com.foo.config;\n\n    @Configuration\n    @ComponentScan(basePackages\u003d\"com.foo\",\n        excludeFilters\u003d@Filter(value\u003dANNOTATION_TYPE, type\u003dConfiguration.class);\n    public class AppConfig {\n        // ...\n    }\n\nThis is obviously more verbose and cumbersome than would be desirable,\nand furthermore potentially too constraining as it prohibits the ability\nto include other legitimate @Configuration classes via scanning.\n\nThe exception was being thrown because of a logic problem in\nClassPathBeanDefinitionScanner.  The bean definition for AppConfig gets\nregistered once by the user (e.g. when constructing an\nAnnotationConfigApplicationContext), then again when performing the\ncomponent scan for \u0027com.foo\u0027. Prior to this change,\nClassPathBeanDefinitionScanner\u0027s #isCompatible returned false if the new\nbean definition was anything other than an AnnotatedBeanDefinition.  The\nintention of this check is really to see whether the new bean definition\nis a *scanned* bean definition, i.e. the result of a component-scanning\noperation.  If so, then it becomes safe to assume that the original bean\ndefinition is the one that should be kept, as it is the one explicitly\nregistered by the user.\n\nTherefore, the fix is as simple as narrowing the instanceof check from\nAnnotatedBeanDefinition to its ScannedGenericBeanDefinition subtype.\n\nNote that this commit partially reverts changes introduced in SPR-8307\nthat explicitly caught ConflictingBeanDefinitionExceptions when\nprocessing recursive @ComponentScan definitions, and rethrew as a\n\"CircularComponentScanException.  With the changes in this commit,\nsuch CBDEs will no longer occur, obviating the need for this check and\nfor this custom exception type altogether.\n\nIssue: SPR-8808, SPR-8307\n",
      "commitDate": "2011/11/29 上午5:35",
      "commitName": "6991cd9cdf610f94ace3cd8072634106830b439f",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/11/16 下午12:20",
      "commitNameOld": "40798bd48f63a8f0d9c6529ca6aaa7203b95cbc3",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 12.72,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location \u003d this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 164,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,51 +1,47 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, null));\n         }\n     }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n         String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         for (String location : locations) {\n             location \u003d this.environment.resolveRequiredPlaceholders(location);\n             ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n             this.propertySources.push(ps);\n         }\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n-                try {\n-                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n-                } catch (ConflictingBeanDefinitionException ex) {\n-                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n-                }\n+                this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n             }\n         }\n     }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c": {
      "type": "Ybodychange",
      "commitMessage": "Refactor AnnotationUtils#findAllAnnotationAttributes\n\nRemove all convenience variants of #findAllAnnotationAttributes and\nrefactor the remaining method to accept a MetadataReaderFactory\ninstead of creating its own SimpleMetadataReaderFactory internally.\nThis allows clients to use non-default class loaders as well as\ncustomize the particular MetadataReaderFactory to be used (e.g.\n\u0027simple\u0027 vs \u0027caching\u0027, etc).\n\nIssue: SPR-8752\n",
      "commitDate": "2011/10/10 上午4:32",
      "commitName": "6837111bda5e4df9bdfa617c78c1ea32ced7ab5c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/7/14 上午7:28",
      "commitNameOld": "c5463a2e52b432c0347da895d7e711079a4af969",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 87.88,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location \u003d this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 164,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,51 +1,51 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, null));\n         }\n     }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n         String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         for (String location : locations) {\n             location \u003d this.environment.resolveRequiredPlaceholders(location);\n             ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n             this.propertySources.push(ps);\n         }\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 try {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 } catch (ConflictingBeanDefinitionException ex) {\n                     throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                 }\n             }\n         }\n     }\n-    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n+    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true, metadataReaderFactory);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "234bca64624d0fadd0333e1ec3fc2c680308f081": {
      "type": "Ybodychange",
      "commitMessage": "Resolve ${...} placeholders in @PropertySource\n\nIssue: SPR-8442\n",
      "commitDate": "2011/6/13 下午12:23",
      "commitName": "234bca64624d0fadd0333e1ec3fc2c680308f081",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/25 下午6:52",
      "commitNameOld": "2ceeff370aff402bd669f9125d93e99d09e8ce71",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 18.73,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            location \u003d this.environment.resolveRequiredPlaceholders(location);\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 161,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,50 +1,51 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, null));\n         }\n     }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n         String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         for (String location : locations) {\n+            location \u003d this.environment.resolveRequiredPlaceholders(location);\n             ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n             this.propertySources.push(ps);\n         }\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 try {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 } catch (ConflictingBeanDefinitionException ex) {\n                     throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                 }\n             }\n         }\n     }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ceeff370aff402bd669f9125d93e99d09e8ce71": {
      "type": "Ybodychange",
      "commitMessage": "Allow multiple locations via @PropertySource#value\n\nIssue: SPR-8314\n",
      "commitDate": "2011/5/25 下午6:52",
      "commitName": "2ceeff370aff402bd669f9125d93e99d09e8ce71",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/21 上午9:20",
      "commitNameOld": "95b1dbadb0014e791b93d73254903a683bd49433",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 4.4,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        for (String location : locations) {\n            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n            this.propertySources.push(ps);\n        }\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 161,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,48 +1,50 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     for (String memberClassName : metadata.getMemberClassNames()) {\n         MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n         AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n         if (isConfigurationCandidate(memberClassMetadata)) {\n             processConfigurationClass(new ConfigurationClass(reader, null));\n         }\n     }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n-        String location \u003d (String) propertySourceAttributes.get(\"value\");\n+        String[] locations \u003d (String[]) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n-        ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n-        this.propertySources.push(ps);\n+        for (String location : locations) {\n+            ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n+            this.propertySources.push(ps);\n+        }\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 try {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 } catch (ConflictingBeanDefinitionException ex) {\n                     throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                 }\n             }\n         }\n     }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "95b1dbadb0014e791b93d73254903a683bd49433": {
      "type": "Ybodychange",
      "commitMessage": "Register nested @Configuration classes automatically\n\nThe following is now possible:\n\n@Configuration\npublic class AppConfig {\n    @Inject DataSource dataSource;\n\n    @Bean\n    public MyBean myBean() {\n        return new MyBean(dataSource);\n    }\n\n    @Configuration\n    static class DatabaseConfig {\n        @Bean\n        DataSource dataSource() {\n            return new EmbeddedDatabaseBuilder().build();\n        }\n    }\n}\n\npublic static void main(String... args) {\n    AnnotationConfigApplicationContext ctx \u003d\n        new AnnotationConfigApplicationContext(AppConfig.class);\n    ctx.getBean(MyBean.class);     // works\n    ctx.getBean(DataSource.class); // works\n}\n\nNotice that the @Import annotation was not used and that only AppConfig\nwas registered against the context. By virtue of the fact that\nDatabaseConfig is a member class of AppConfig, it is automatically\nregistered when AppConfig is registered. This avoids an awkward and\nredundant @Import annotation when the relationship is already implicitly\nclear.\n\nSee @Configuration Javadoc for details.\n\nIssue: SPR-8186\n",
      "commitDate": "2011/5/21 上午9:20",
      "commitName": "95b1dbadb0014e791b93d73254903a683bd49433",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/18 下午4:53",
      "commitNameOld": "4520ea8690fa8769a2d45658883eac51ea2453ed",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    for (String memberClassName : metadata.getMemberClassNames()) {\n        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n        if (isConfigurationCandidate(memberClassMetadata)) {\n            processConfigurationClass(new ConfigurationClass(reader, null));\n        }\n    }\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String location \u003d (String) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n        this.propertySources.push(ps);\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 161,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,41 +1,48 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+    for (String memberClassName : metadata.getMemberClassNames()) {\n+        MetadataReader reader \u003d this.metadataReaderFactory.getMetadataReader(memberClassName);\n+        AnnotationMetadata memberClassMetadata \u003d reader.getAnnotationMetadata();\n+        if (isConfigurationCandidate(memberClassMetadata)) {\n+            processConfigurationClass(new ConfigurationClass(reader, null));\n+        }\n+    }\n     Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n     if (propertySourceAttributes !\u003d null) {\n         String name \u003d (String) propertySourceAttributes.get(\"name\");\n         String location \u003d (String) propertySourceAttributes.get(\"value\");\n         ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n         ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n         this.propertySources.push(ps);\n     }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 try {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 } catch (ConflictingBeanDefinitionException ex) {\n                     throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                 }\n             }\n         }\n     }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c8bc54e0ccad49f0785856f911349283619eb8ba": {
      "type": "Ybodychange",
      "commitMessage": "Introduce @PropertySource\n\nAllows a convenient mechanism for contributing a PropertySource to the\nenclosing Spring Environment. See @PropertySource Javadoc for\ncomplete details and PropertySourceAnnotationTests for examples.\n\nIssue: SPR-8314\n",
      "commitDate": "2011/5/11 下午9:28",
      "commitName": "c8bc54e0ccad49f0785856f911349283619eb8ba",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/8 下午9:49",
      "commitNameOld": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 2.99,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n    if (propertySourceAttributes !\u003d null) {\n        String name \u003d (String) propertySourceAttributes.get(\"name\");\n        String location \u003d (String) propertySourceAttributes.get(\"value\");\n        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n        ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n        this.propertySources.push(ps);\n    }\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 165,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,33 +1,41 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+    Map\u003cString, Object\u003e propertySourceAttributes \u003d metadata.getAnnotationAttributes(org.springframework.context.annotation.PropertySource.class.getName());\n+    if (propertySourceAttributes !\u003d null) {\n+        String name \u003d (String) propertySourceAttributes.get(\"name\");\n+        String location \u003d (String) propertySourceAttributes.get(\"value\");\n+        ClassLoader classLoader \u003d this.resourceLoader.getClassLoader();\n+        ResourcePropertySource ps \u003d StringUtils.hasText(name) ? new ResourcePropertySource(name, location, classLoader) : new ResourcePropertySource(location, classLoader);\n+        this.propertySources.push(ps);\n+    }\n     Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n     if (componentScanAttributes !\u003d null) {\n         Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n         for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n             if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                 try {\n                     this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                 } catch (ConflictingBeanDefinitionException ex) {\n                     throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                 }\n             }\n         }\n     }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d0c31ad84cffd7af718a45d679483a1c51f9e552": {
      "type": "Ybodychange",
      "commitMessage": "Allow recursive use of @ComponentScan\n\nPrior to this change, @ComponentScan annotations were only processed at\nthe first level of depth.  Now, the set of bean definitions resulting\nfrom each declaration of @ComponentScan is checked for configuration\nclasses that declare @ComponentScan, and recursion is performed as\nnecessary.\n\nCycles between @ComponentScan declarations are detected as well. See\nCircularComponentScanException.\n\nIssue: SPR-8307\n",
      "commitDate": "2011/5/8 下午9:49",
      "commitName": "d0c31ad84cffd7af718a45d679483a1c51f9e552",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/7 上午3:06",
      "commitNameOld": "9a271ce6c92695b9421aa603c9aa56e805c7920c",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n    if (componentScanAttributes !\u003d null) {\n        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n                try {\n                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n                } catch (ConflictingBeanDefinitionException ex) {\n                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n                }\n            }\n        }\n    }\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 154,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,33 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+    Map\u003cString, Object\u003e componentScanAttributes \u003d metadata.getAnnotationAttributes(ComponentScan.class.getName());\n+    if (componentScanAttributes !\u003d null) {\n+        Set\u003cBeanDefinitionHolder\u003e scannedBeanDefinitions \u003d this.componentScanParser.parse(componentScanAttributes);\n+        for (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n+            if (ConfigurationClassUtils.checkConfigurationClassCandidate(holder.getBeanDefinition(), metadataReaderFactory)) {\n+                try {\n+                    this.parse(holder.getBeanDefinition().getBeanClassName(), holder.getBeanName());\n+                } catch (ConflictingBeanDefinitionException ex) {\n+                    throw new CircularComponentScanException(\"A conflicting bean definition was detected while processing @ComponentScan annotations. \" + \"This usually indicates a circle between scanned packages.\", ex);\n+                }\n+            }\n+        }\n+    }\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n         processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a271ce6c92695b9421aa603c9aa56e805c7920c": {
      "type": "Ybodychange",
      "commitMessage": "Introduce ImportSelector interface\n\nAllows @Enable* a layer of indirection for deciding which @Configuration\nclass(es) to @Import.\n\nThe @Import annotation may now accept @Configuration class literals\nand/or ImportSelector class literals.\n",
      "commitDate": "2011/5/7 上午3:06",
      "commitName": "9a271ce6c92695b9421aa603c9aa56e805c7920c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/7 上午3:05",
      "commitNameOld": "cdb01cbd3795f273b751d0f0a45caa22d07c62da",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 143,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,20 +1,20 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n     for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n-        processImport(configClass, (String[]) importAttribs.get(\"value\"));\n+        processImport(configClass, (String[]) importAttribs.get(\"value\"), true);\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "89005a5b7034cc1c2f702eac4bd36836b99f3765": {
      "type": "Ybodychange",
      "commitMessage": "Process all meta and local @Import declarations\n\nIncludes the introduction of AnnotationUtils#findAllAnnotationAttributes\nto support iterating through all annotations declared on a given type\nand interrogating each for the presence of a meta-annotation. See tests\nfor details.\n",
      "commitDate": "2011/5/7 上午3:05",
      "commitName": "89005a5b7034cc1c2f702eac4bd36836b99f3765",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/5/7 上午3:01",
      "commitNameOld": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n        processImport(configClass, (String[]) importAttribs.get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 140,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,20 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    if (metadata.isAnnotated(Import.class.getName())) {\n-        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n+    List\u003cMap\u003cString, Object\u003e\u003e allImportAttribs \u003d AnnotationUtils.findAllAnnotationAttributes(Import.class, metadata.getClassName(), true);\n+    for (Map\u003cString, Object\u003e importAttribs : allImportAttribs) {\n+        processImport(configClass, (String[]) importAttribs.get(\"value\"));\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a790c143feeabf571e98f8ee0700a4586cbb67c": {
      "type": "Ybodychange",
      "commitMessage": "Rename ConfigurationClassMethod \u003d\u003e BeanMethod\n",
      "commitDate": "2011/5/7 上午3:01",
      "commitName": "0a790c143feeabf571e98f8ee0700a4586cbb67c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2011/3/15 下午8:57",
      "commitNameOld": "150838bfc13a136ef0baf943e378a8ebb5f3549f",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 52.25,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 137,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,19 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n-    for (MethodMetadata beanMethod : beanMethods) {\n-        configClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n+    for (MethodMetadata methodMetadata : beanMethods) {\n+        configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d78eda8aebda0704e29fdccf619e9931b5446efc": {
      "type": "Ybodychange",
      "commitMessage": "polishing\n",
      "commitDate": "2010/10/11 上午2:31",
      "commitName": "d78eda8aebda0704e29fdccf619e9931b5446efc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/1/30 上午7:31",
      "commitNameOld": "fbd797e50b2f1c5b0dfef944ee218d826f1a0694",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 253.79,
      "commitsBetweenForRepo": 804,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata beanMethod : beanMethods) {\n        configClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 126,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,19 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n         Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n-    for (MethodMetadata methodMetadata : beanMethods) {\n-        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n+    for (MethodMetadata beanMethod : beanMethods) {\n+        configClass.addMethod(new ConfigurationClassMethod(beanMethod, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9": {
      "type": "Ybodychange",
      "commitMessage": "Resolved SPR-6618. Restrictions were too tight on overloaded bean methods and were preventing it altogether.  Overloading is now allowed, as long as there is no ambiguity at runtime which bean method should be invoked.\n",
      "commitDate": "2009/12/31 上午3:42",
      "commitName": "d1b3f57320d5567ff8f6420c9bcf07521ea5e2b9",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/11/12 下午3:29",
      "commitNameOld": "9f07b151853f21bc363340fd3056ec14118a1e89",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 48.51,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : beanMethods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 128,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,19 +1,19 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n         String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n-        Class readerClass \u003d (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+        Class\u003c?\u003e readerClass \u003d (Class\u003c?\u003e) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n         if (readerClass \u003d\u003d null) {\n             throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n         }\n         for (String resource : resources) {\n             configClass.addImportedResource(resource, readerClass);\n         }\n     }\n-    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n-    for (MethodMetadata methodMetadata : methods) {\n+    Set\u003cMethodMetadata\u003e beanMethods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    for (MethodMetadata methodMetadata : beanMethods) {\n         configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bbd7fb3969b7fd93c814380209d8f28e2a9c6714": {
      "type": "Ybodychange",
      "commitMessage": "AnnotationMetadata returns Class values by default (again), allowing for explicit retrieval of String class names where preferred (SPR-5827)\n",
      "commitDate": "2009/11/12 上午3:11",
      "commitName": "bbd7fb3969b7fd93c814380209d8f28e2a9c6714",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/11/11 上午8:48",
      "commitNameOld": "ee553f7804c9cc2ac89b963bcff58974503c20fe",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n        Class readerClass \u003d (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        if (readerClass \u003d\u003d null) {\n            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n        }\n        for (String resource : resources) {\n            configClass.addImportedResource(resource, readerClass);\n        }\n    }\n    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 128,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,19 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n-        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n+        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName(), true).get(\"value\"));\n     }\n     if (metadata.isAnnotated(ImportResource.class.getName())) {\n-        String readerClassName \u003d (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n-        for (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n-            configClass.addImportedResource(importedResource, readerClassName);\n+        String[] resources \u003d (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\");\n+        Class readerClass \u003d (Class) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+        if (readerClass \u003d\u003d null) {\n+            throw new IllegalStateException(\"No reader class associated with imported resources: \" + StringUtils.arrayToCommaDelimitedString(resources));\n+        }\n+        for (String resource : resources) {\n+            configClass.addImportedResource(resource, readerClass);\n         }\n     }\n     Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : methods) {\n         configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ee553f7804c9cc2ac89b963bcff58974503c20fe": {
      "type": "Ybodychange",
      "commitMessage": "SPR-6328: Rename @ImportXml -\u003e @ImportResource and allow for usage of non-XML BeanDefinitionReader types\n\n",
      "commitDate": "2009/11/11 上午8:48",
      "commitName": "ee553f7804c9cc2ac89b963bcff58974503c20fe",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/11/7 上午8:32",
      "commitNameOld": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportResource.class.getName())) {\n        String readerClassName \u003d (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n        for (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n            configClass.addImportedResource(importedResource, readerClassName);\n        }\n    }\n    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 129,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,14 +1,15 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n     }\n-    if (metadata.isAnnotated(ImportXml.class.getName())) {\n-        for (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n-            configClass.addXmlImport(xmlImport);\n+    if (metadata.isAnnotated(ImportResource.class.getName())) {\n+        String readerClassName \u003d (String) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"reader\");\n+        for (String importedResource : (String[]) metadata.getAnnotationAttributes(ImportResource.class.getName()).get(\"value\")) {\n+            configClass.addImportedResource(importedResource, readerClassName);\n         }\n     }\n     Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : methods) {\n         configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0a4463fb71e6901a943a5bafc9d1957da2229333": {
      "type": "Ybodychange",
      "commitMessage": "SPR-6158: Initial implementation and tests for @ImportXml\n\n",
      "commitDate": "2009/11/7 上午8:32",
      "commitName": "0a4463fb71e6901a943a5bafc9d1957da2229333",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2009/7/22 下午11:23",
      "commitNameOld": "f519406c37b23eef816704baeb3a496f7430bb89",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 107.38,
      "commitsBetweenForRepo": 678,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    if (metadata.isAnnotated(ImportXml.class.getName())) {\n        for (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n            configClass.addXmlImport(xmlImport);\n        }\n    }\n    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 127,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,14 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n     if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n     }\n+    if (metadata.isAnnotated(ImportXml.class.getName())) {\n+        for (String xmlImport : (String[]) metadata.getAnnotationAttributes(ImportXml.class.getName()).get(\"value\")) {\n+            configClass.addXmlImport(xmlImport);\n+        }\n+    }\n     Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : methods) {\n         configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f519406c37b23eef816704baeb3a496f7430bb89": {
      "type": "Ybodychange",
      "commitMessage": "@Primary/@Lazy/@DependsOn supported as meta-annotations; @Bean supported as meta-annotation on factory methods as well\n",
      "commitDate": "2009/7/22 下午11:23",
      "commitName": "f519406c37b23eef816704baeb3a496f7430bb89",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/6/6 下午3:59",
      "commitNameOld": "8c65ed9e0bf84cdaa4a12843d52e929a8146fb31",
      "commitAuthorOld": "Christian Dupuis",
      "daysBetweenCommits": 46.31,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.isAnnotated(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 123,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n-    if (metadata.hasAnnotation(Import.class.getName())) {\n+    if (metadata.isAnnotated(Import.class.getName())) {\n         processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n     }\n     Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n     for (MethodMetadata methodMetadata : methods) {\n         configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b5d21108da24f8344be3bc708c7afdfca9a1d089": {
      "type": "Yintroduced",
      "commitMessage": "@Configuration parsing fully relies on Spring\u0027s MetadataReader abstraction now\n",
      "commitDate": "2009/4/24 下午7:16",
      "commitName": "b5d21108da24f8344be3bc708c7afdfca9a1d089",
      "commitAuthor": "Juergen Hoeller",
      "diff": "@@ -0,0 +1,9 @@\n+protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n+    if (metadata.hasAnnotation(Import.class.getName())) {\n+        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n+    }\n+    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n+    for (MethodMetadata methodMetadata : methods) {\n+        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected void doProcessConfigurationClass(ConfigurationClass configClass, AnnotationMetadata metadata) throws IOException {\n    if (metadata.hasAnnotation(Import.class.getName())) {\n        processImport(configClass, (String[]) metadata.getAnnotationAttributes(Import.class.getName()).get(\"value\"));\n    }\n    Set\u003cMethodMetadata\u003e methods \u003d metadata.getAnnotatedMethods(Bean.class.getName());\n    for (MethodMetadata methodMetadata : methods) {\n        configClass.addMethod(new ConfigurationClassMethod(methodMetadata, configClass));\n    }\n}",
      "path": "org.springframework.context/src/main/java/org/springframework/context/annotation/ConfigurationClassParser.java",
      "functionStartLine": 118,
      "functionName": "doProcessConfigurationClass",
      "functionAnnotation": "",
      "functionDoc": ""
    }
  }
}