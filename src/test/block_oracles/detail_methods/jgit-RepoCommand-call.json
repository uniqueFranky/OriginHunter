{
  "origin": "codeshovel",
  "repositoryName": "jgit",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/jgit/.git",
  "startCommitName": "bd1a82502680b5de5bf86f6c4470185fd1602386",
  "sourceFileName": "RepoCommand.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
  "functionAnnotation": "@Override",
  "functionDoc": "@inheritDoc}\n",
  "functionStartLine": 487,
  "functionEndLine": 700,
  "numCommitsSeen": 68,
  "timeTaken": 3375,
  "changeHistory": [
    "6658f367682932c0a77061a5aa37c06e480a0c62",
    "3214171decf596f003c154685638b01faba31ff3",
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
    "5e2e111280898e47959996a1a1e016e9fcb21179",
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
    "fe5437e96b91222e30d9105e7bab490fd68c2d52",
    "f32d65759c9afdcbec28eb3051ed9138b8e03271",
    "27b05c7d719754427a97c141b44bec7de3acb8db",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
    "a9b87de97090b4f7d25ace0525edc1268cfa737f",
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
    "744c370c1be8044d1ccaaf84cd164324961fea1a",
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
    "0e73d395061d1bfee365acaa2f79c392175d13bf",
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
    "acd7ed52692bb7155333efea6dead712b7156ab9",
    "0b15b48f741f87277e0d1c7d29637430b880dbde",
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
    "dc4c673902a0847b270faf1771595d7c189a1943",
    "a44a687fedbf1559277b8e6706819aa9be7bce39",
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24"
  ],
  "changeHistoryShort": {
    "6658f367682932c0a77061a5aa37c06e480a0c62": "Ybodychange",
    "3214171decf596f003c154685638b01faba31ff3": "Ybodychange",
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba": "Ybodychange",
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef": "Ybodychange",
    "5e2e111280898e47959996a1a1e016e9fcb21179": "Ydocchange",
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2": "Ybodychange",
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8": "Ybodychange",
    "fe5437e96b91222e30d9105e7bab490fd68c2d52": "Ybodychange",
    "f32d65759c9afdcbec28eb3051ed9138b8e03271": "Ybodychange",
    "27b05c7d719754427a97c141b44bec7de3acb8db": "Ybodychange",
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": "Ybodychange",
    "a9b87de97090b4f7d25ace0525edc1268cfa737f": "Ybodychange",
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866": "Ybodychange",
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94": "Ybodychange",
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062": "Ybodychange",
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2": "Ybodychange",
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf": "Ybodychange",
    "744c370c1be8044d1ccaaf84cd164324961fea1a": "Ybodychange",
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c": "Ybodychange",
    "0e73d395061d1bfee365acaa2f79c392175d13bf": "Ybodychange",
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386": "Ybodychange",
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621": "Ybodychange",
    "acd7ed52692bb7155333efea6dead712b7156ab9": "Ybodychange",
    "0b15b48f741f87277e0d1c7d29637430b880dbde": "Ybodychange",
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2": "Ybodychange",
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5": "Ybodychange",
    "dc4c673902a0847b270faf1771595d7c189a1943": "Ymultichange(Yreturntypechange,Ybodychange)",
    "a44a687fedbf1559277b8e6706819aa9be7bce39": "Ybodychange",
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6658f367682932c0a77061a5aa37c06e480a0c62": {
      "type": "Ybodychange",
      "commitMessage": "Use project names instead of paths for the submodule name\n\nTwo submodules at the same path on different branches need not represent\nthe same repository, and two submodules at different paths can represent\nthe same one.\n\nThe C Git implementation uses the submodule name to internally manage\nthe submodule repositories under .git/modules. When a submodule\nrepresents different repositories in different branches, it makes a\nconflict inside .git/modules.\n\nThe current RepoCommand implementation uses submodule paths as the\nsubmodule names. When the manifest file mounts different repositories to\nthe same path in different branches, this makes a situation described\nabove. To solve this issue, we can use the project name instead of\nthe path as the submodule name.\n\nOn the other hand, since repo v1.12.8~3^2 (repo: Support multiple\nbranches for the same project., 2013-10-11), a manifest file can mount\nthe same project to different paths. If we naively use the project\nname as the submodule name, it makes a conflict in .git/modules, too.\n\nThis patch uses the project name as the submodule name basically, but\nwhen the same project is mounted to different paths, it uses the project\nname and path as the submodule name.\n\nChange-Id: I09dc7d62ba59016fe28852d3139a56ef7ef49b8f\nSigned-off-by: Masaya Suzuki \u003cmasayasuzuki@google.com\u003e\nReported-by: JP Sugarbroad \u003cjpsugar@google.com\u003e\n",
      "commitDate": "2018/7/28 上午6:07",
      "commitName": "6658f367682932c0a77061a5aa37c06e480a0c62",
      "commitAuthor": "Masaya Suzuki",
      "commitDateOld": "2018/7/20 下午3:48",
      "commitNameOld": "fb9031c9566308794f888695cafd108f19d835be",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 7.6,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri \u003d\u003d null) {\n        baseUri \u003d \"\";\n    }\n    if (inputStream \u003d\u003d null) {\n        if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream \u003d new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List\u003cRepoProject\u003e filteredProjects;\n    try {\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects \u003d parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n        List\u003cRepoProject\u003e renamedProjects \u003d renameProjects(filteredProjects);\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : renamedProjects) {\n                String name \u003d proj.getName();\n                String path \u003d proj.getPath();\n                String url \u003d proj.getUrl();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(url, proj.getRevision());\n                    if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(url);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(url);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", name, \"path\", path);\n                cfg.setString(\"submodule\", name, \"url\", submodUrl.toString());\n                if (objectId !\u003d null) {\n                    DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src \u003d callback.readFile(url, proj.getRevision(), copyfile.src);\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link \u003d proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            if (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n                return rw.parseCommit(headId);\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git \u003d new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getName(), proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,164 +1,162 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (baseUri \u003d\u003d null) {\n         baseUri \u003d \"\";\n     }\n     if (inputStream \u003d\u003d null) {\n         if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         try {\n             inputStream \u003d new FileInputStream(manifestPath);\n         } catch (IOException e) {\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         }\n     }\n     List\u003cRepoProject\u003e filteredProjects;\n     try {\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         parser.read(inputStream);\n         filteredProjects \u003d parser.getFilteredProjects();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     } finally {\n         try {\n             inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n-        bareProjects \u003d new ArrayList\u003c\u003e();\n         if (author \u003d\u003d null)\n             author \u003d new PersonIdent(repo);\n         if (callback \u003d\u003d null)\n             callback \u003d new DefaultRemoteReader();\n-        for (RepoProject proj : filteredProjects) {\n-            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n-        }\n+        List\u003cRepoProject\u003e renamedProjects \u003d renameProjects(filteredProjects);\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n-            for (RepoProject proj : bareProjects) {\n+            for (RepoProject proj : renamedProjects) {\n+                String name \u003d proj.getName();\n                 String path \u003d proj.getPath();\n-                String nameUri \u003d proj.getName();\n+                String url \u003d proj.getUrl();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n-                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n+                    objectId \u003d callback.sha1(url, proj.getRevision());\n                     if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n-                        throw new RemoteUnavailableException(nameUri);\n+                        throw new RemoteUnavailableException(url);\n                     }\n                     if (recordRemoteBranch) {\n-                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n+                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n-                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n+                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n-                URI submodUrl \u003d URI.create(nameUri);\n+                URI submodUrl \u003d URI.create(url);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n-                cfg.setString(\"submodule\", path, \"path\", path);\n-                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n+                cfg.setString(\"submodule\", name, \"path\", path);\n+                cfg.setString(\"submodule\", name, \"url\", submodUrl.toString());\n                 if (objectId !\u003d null) {\n                     DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.GITLINK);\n                     builder.add(dcEntry);\n                     for (CopyFile copyfile : proj.getCopyFiles()) {\n-                        byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n+                        byte[] src \u003d callback.readFile(url, proj.getRevision(), copyfile.src);\n                         objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                         dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                         dcEntry.setObjectId(objectId);\n                         dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                         builder.add(dcEntry);\n                     }\n                     for (LinkFile linkfile : proj.getLinkFiles()) {\n                         String link;\n                         if (linkfile.dest.contains(\"/\")) {\n                             link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                         } else {\n                             link \u003d proj.getPath() + \"/\" + linkfile.src;\n                         }\n                         objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                         dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                         dcEntry.setObjectId(objectId);\n                         dcEntry.setFileMode(FileMode.SYMLINK);\n                         builder.add(dcEntry);\n                     }\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             if (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n                 return rw.parseCommit(headId);\n             }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         try (Git git \u003d new Git(repo)) {\n             for (RepoProject proj : filteredProjects) {\n-                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n+                addSubmodule(proj.getName(), proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n             }\n             return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3214171decf596f003c154685638b01faba31ff3": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: don\u0027t record new commit if tree did not change\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: Ib6509e816684256d723558d5e8f3c37de58a2ff8\n",
      "commitDate": "2018/2/19 下午7:24",
      "commitName": "3214171decf596f003c154685638b01faba31ff3",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2018/2/19 下午7:24",
      "commitNameOld": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri \u003d\u003d null) {\n        baseUri \u003d \"\";\n    }\n    if (inputStream \u003d\u003d null) {\n        if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream \u003d new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List\u003cRepoProject\u003e filteredProjects;\n    try {\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects \u003d parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003c\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                if (objectId !\u003d null) {\n                    DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link \u003d proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            if (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n                return rw.parseCommit(headId);\n            }\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git \u003d new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,161 +1,164 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (baseUri \u003d\u003d null) {\n         baseUri \u003d \"\";\n     }\n     if (inputStream \u003d\u003d null) {\n         if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         try {\n             inputStream \u003d new FileInputStream(manifestPath);\n         } catch (IOException e) {\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         }\n     }\n     List\u003cRepoProject\u003e filteredProjects;\n     try {\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         parser.read(inputStream);\n         filteredProjects \u003d parser.getFilteredProjects();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     } finally {\n         try {\n             inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         bareProjects \u003d new ArrayList\u003c\u003e();\n         if (author \u003d\u003d null)\n             author \u003d new PersonIdent(repo);\n         if (callback \u003d\u003d null)\n             callback \u003d new DefaultRemoteReader();\n         for (RepoProject proj : filteredProjects) {\n             addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n         }\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 URI submodUrl \u003d URI.create(nameUri);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                 if (objectId !\u003d null) {\n                     DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.GITLINK);\n                     builder.add(dcEntry);\n                     for (CopyFile copyfile : proj.getCopyFiles()) {\n                         byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                         objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                         dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                         dcEntry.setObjectId(objectId);\n                         dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                         builder.add(dcEntry);\n                     }\n                     for (LinkFile linkfile : proj.getLinkFiles()) {\n                         String link;\n                         if (linkfile.dest.contains(\"/\")) {\n                             link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                         } else {\n                             link \u003d proj.getPath() + \"/\" + linkfile.src;\n                         }\n                         objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                         dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                         dcEntry.setObjectId(objectId);\n                         dcEntry.setFileMode(FileMode.SYMLINK);\n                         builder.add(dcEntry);\n                     }\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n+            if (headId !\u003d null \u0026\u0026 rw.parseCommit(headId).getTree().getId().equals(treeId)) {\n+                return rw.parseCommit(headId);\n+            }\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         try (Git git \u003d new Git(repo)) {\n             for (RepoProject proj : filteredProjects) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n             }\n             return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "446a7096ef01c0e3bb56736403d91b125b2ee6ba": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: persist unreadable submodules in .gitmodules\n\nIn cases where a manifest file mixes different remotes, a Gerrit\nserver process may not have access to all remotes, and won\u0027t be able\nto produce a full submodule tree.\n\nPreserving this information in .gitmodules will let downstream clients\nreconstruct the full tree.\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I52f5d3f288e771dca0af2b4dd3f3fa0f940dcf15\n",
      "commitDate": "2018/2/19 下午7:24",
      "commitName": "446a7096ef01c0e3bb56736403d91b125b2ee6ba",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2018/2/15 下午3:59",
      "commitNameOld": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 4.14,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri \u003d\u003d null) {\n        baseUri \u003d \"\";\n    }\n    if (inputStream \u003d\u003d null) {\n        if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream \u003d new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List\u003cRepoProject\u003e filteredProjects;\n    try {\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects \u003d parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003c\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                if (objectId !\u003d null) {\n                    DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.GITLINK);\n                    builder.add(dcEntry);\n                    for (CopyFile copyfile : proj.getCopyFiles()) {\n                        byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                        dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                        builder.add(dcEntry);\n                    }\n                    for (LinkFile linkfile : proj.getLinkFiles()) {\n                        String link;\n                        if (linkfile.dest.contains(\"/\")) {\n                            link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                        } else {\n                            link \u003d proj.getPath() + \"/\" + linkfile.src;\n                        }\n                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                        dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                        dcEntry.setObjectId(objectId);\n                        dcEntry.setFileMode(FileMode.SYMLINK);\n                        builder.add(dcEntry);\n                    }\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git \u003d new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,162 +1,161 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (baseUri \u003d\u003d null) {\n         baseUri \u003d \"\";\n     }\n     if (inputStream \u003d\u003d null) {\n         if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         try {\n             inputStream \u003d new FileInputStream(manifestPath);\n         } catch (IOException e) {\n             throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         }\n     }\n     List\u003cRepoProject\u003e filteredProjects;\n     try {\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         parser.read(inputStream);\n         filteredProjects \u003d parser.getFilteredProjects();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     } finally {\n         try {\n             inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         bareProjects \u003d new ArrayList\u003c\u003e();\n         if (author \u003d\u003d null)\n             author \u003d new PersonIdent(repo);\n         if (callback \u003d\u003d null)\n             callback \u003d new DefaultRemoteReader();\n         for (RepoProject proj : filteredProjects) {\n             addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n         }\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n-                    if (objectId \u003d\u003d null) {\n-                        if (ignoreRemoteFailures) {\n-                            continue;\n-                        }\n+                    if (objectId \u003d\u003d null \u0026\u0026 !ignoreRemoteFailures) {\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 URI submodUrl \u003d URI.create(nameUri);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n-                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n-                dcEntry.setObjectId(objectId);\n-                dcEntry.setFileMode(FileMode.GITLINK);\n-                builder.add(dcEntry);\n-                for (CopyFile copyfile : proj.getCopyFiles()) {\n-                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n-                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n-                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n+                if (objectId !\u003d null) {\n+                    DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                     dcEntry.setObjectId(objectId);\n-                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n+                    dcEntry.setFileMode(FileMode.GITLINK);\n                     builder.add(dcEntry);\n-                }\n-                for (LinkFile linkfile : proj.getLinkFiles()) {\n-                    String link;\n-                    if (linkfile.dest.contains(\"/\")) {\n-                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n-                    } else {\n-                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n+                    for (CopyFile copyfile : proj.getCopyFiles()) {\n+                        byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n+                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n+                        dcEntry \u003d new DirCacheEntry(copyfile.dest);\n+                        dcEntry.setObjectId(objectId);\n+                        dcEntry.setFileMode(FileMode.REGULAR_FILE);\n+                        builder.add(dcEntry);\n                     }\n-                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n-                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n-                    dcEntry.setObjectId(objectId);\n-                    dcEntry.setFileMode(FileMode.SYMLINK);\n-                    builder.add(dcEntry);\n+                    for (LinkFile linkfile : proj.getLinkFiles()) {\n+                        String link;\n+                        if (linkfile.dest.contains(\"/\")) {\n+                            link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n+                        } else {\n+                            link \u003d proj.getPath() + \"/\" + linkfile.src;\n+                        }\n+                        objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n+                        dcEntry \u003d new DirCacheEntry(linkfile.dest);\n+                        dcEntry.setObjectId(objectId);\n+                        dcEntry.setFileMode(FileMode.SYMLINK);\n+                        builder.add(dcEntry);\n+                    }\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         try (Git git \u003d new Git(repo)) {\n             for (RepoProject proj : filteredProjects) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n             }\n             return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9bebb1eae78401e1d3289dc3d84006c10d10c0ef": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Don\u0027t leave Git open\n\nWhen the command is run on a non-bare repository, an instance of\nGit is created to execute the commit, and is left open when the\ncommand has finished.\n\nRefactor to not use a class scope Git instance, and make sure it\ngets closed before returning.\n\nChange-Id: Ic623ae0fd8b9e264b5dfd434da0de6bb4f910984\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2018/2/15 下午3:59",
      "commitName": "9bebb1eae78401e1d3289dc3d84006c10d10c0ef",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/12/18 下午8:19",
      "commitNameOld": "5e2e111280898e47959996a1a1e016e9fcb21179",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 58.82,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (baseUri \u003d\u003d null) {\n        baseUri \u003d \"\";\n    }\n    if (inputStream \u003d\u003d null) {\n        if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        try {\n            inputStream \u003d new FileInputStream(manifestPath);\n        } catch (IOException e) {\n            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n        }\n    }\n    List\u003cRepoProject\u003e filteredProjects;\n    try {\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        parser.read(inputStream);\n        filteredProjects \u003d parser.getFilteredProjects();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    } finally {\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003c\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n        for (RepoProject proj : filteredProjects) {\n            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n        }\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        try (Git git \u003d new Git(repo)) {\n            for (RepoProject proj : filteredProjects) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n            }\n            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 487,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "@@ -1,159 +1,162 @@\n @Override\n public RevCommit call() throws GitAPIException {\n-    try {\n-        checkCallable();\n-        if (baseUri \u003d\u003d null) {\n-            baseUri \u003d \"\";\n-        }\n-        if (inputStream \u003d\u003d null) {\n-            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n-                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n-            try {\n-                inputStream \u003d new FileInputStream(manifestPath);\n-            } catch (IOException e) {\n-                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n-            }\n-        }\n-        if (repo.isBare()) {\n-            bareProjects \u003d new ArrayList\u003c\u003e();\n-            if (author \u003d\u003d null)\n-                author \u003d new PersonIdent(repo);\n-            if (callback \u003d\u003d null)\n-                callback \u003d new DefaultRemoteReader();\n-        } else\n-            git \u003d new Git(repo);\n-        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n+    checkCallable();\n+    if (baseUri \u003d\u003d null) {\n+        baseUri \u003d \"\";\n+    }\n+    if (inputStream \u003d\u003d null) {\n+        if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n+            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         try {\n-            parser.read(inputStream);\n-            for (RepoProject proj : parser.getFilteredProjects()) {\n-                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n-            }\n-        } catch (GitAPIException | IOException e) {\n-            throw new ManifestErrorException(e);\n+            inputStream \u003d new FileInputStream(manifestPath);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n         }\n+    }\n+    List\u003cRepoProject\u003e filteredProjects;\n+    try {\n+        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n+        parser.read(inputStream);\n+        filteredProjects \u003d parser.getFilteredProjects();\n+    } catch (IOException e) {\n+        throw new ManifestErrorException(e);\n     } finally {\n         try {\n-            if (inputStream !\u003d null)\n-                inputStream.close();\n+            inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n+        bareProjects \u003d new ArrayList\u003c\u003e();\n+        if (author \u003d\u003d null)\n+            author \u003d new PersonIdent(repo);\n+        if (callback \u003d\u003d null)\n+            callback \u003d new DefaultRemoteReader();\n+        for (RepoProject proj : filteredProjects) {\n+            addSubmoduleBare(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n+        }\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 URI submodUrl \u003d URI.create(nameUri);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n                 for (LinkFile linkfile : proj.getLinkFiles()) {\n                     String link;\n                     if (linkfile.dest.contains(\"/\")) {\n                         link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                     } else {\n                         link \u003d proj.getPath() + \"/\" + linkfile.src;\n                     }\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                     dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.SYMLINK);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n-        } catch (IOException e) {\n+        } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n-        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n+        try (Git git \u003d new Git(repo)) {\n+            for (RepoProject proj : filteredProjects) {\n+                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), git);\n+            }\n+            return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n+        } catch (GitAPIException | IOException e) {\n+            throw new ManifestErrorException(e);\n+        }\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e2e111280898e47959996a1a1e016e9fcb21179": {
      "type": "Ydocchange",
      "commitMessage": "Fix javadoc in org.eclipse.jgit gitrepo package\n\nChange-Id: I2604c7bca87f005004d6d6c80fa9a39a7a1e3807\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2017/12/18 下午8:19",
      "commitName": "5e2e111280898e47959996a1a1e016e9fcb21179",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2017/11/29 上午12:17",
      "commitNameOld": "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 19.83,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri \u003d\u003d null) {\n            baseUri \u003d \"\";\n        }\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 488,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "@inheritDoc}\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "",
        "newValue": "@inheritDoc}\n"
      }
    },
    "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Skip RemoteReader when encountering a full SHA-1\n\nThere is no point in calling back to the RemoteReader to resolve a\n40-digit hex SHA-1 to itself.  We already skip that call when not\nignoring remote failures; skip it when ignoring remote failures, too.\n\nThis should simplify RemoteReader implementations.\n\nReported-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I7566968ed1f39b1ad73574fa903faf3ee308eb87\n",
      "commitDate": "2017/11/29 上午12:17",
      "commitName": "04b8168beb5fb9c7d4e9768cc99a82d0e6176dc2",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2017/8/30 上午9:07",
      "commitNameOld": "e9fb111182b55cc82c530d82f13176c7a85cd958",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 90.63,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri \u003d\u003d null) {\n            baseUri \u003d \"\";\n        }\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 474,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,159 +1,159 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (baseUri \u003d\u003d null) {\n             baseUri \u003d \"\";\n         }\n         if (inputStream \u003d\u003d null) {\n             if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(manifestPath);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n-                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n+                if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 URI submodUrl \u003d URI.create(nameUri);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n                 for (LinkFile linkfile : proj.getLinkFiles()) {\n                     String link;\n                     if (linkfile.dest.contains(\"/\")) {\n                         link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                     } else {\n                         link \u003d proj.getPath() + \"/\" + linkfile.src;\n                     }\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                     dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.SYMLINK);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Add linkfile support.\n\nAndroid wants them to work, and we\u0027re only interested in them for bare\nrepos, so add them just for that.\n\nMake sure to use symlinks instead of just using the copyfile\nimplementation. Some scripts look up where they\u0027re actually located in\norder to find related files, so they need the link back to their\nproject.\n\nChange-Id: I929b69b2505f03036f69e25a55daf93842871f30\nSigned-off-by: Dan Willemsen \u003cdwillemsen@google.com\u003e\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\nSigned-off-by: Jeff Gaston \u003cjeffrygaston@google.com\u003e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/4/18 下午4:33",
      "commitName": "b6fc8e2f3cb1af6f7cbc624acfac01bec002baf8",
      "commitAuthor": "Dan Willemsen",
      "commitDateOld": "2017/4/15 上午1:49",
      "commitNameOld": "3af4afdfbfed7ed97424b91d08bf55c3b23c0b9b",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 3.61,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri \u003d\u003d null) {\n            baseUri \u003d \"\";\n        }\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n                for (LinkFile linkfile : proj.getLinkFiles()) {\n                    String link;\n                    if (linkfile.dest.contains(\"/\")) {\n                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n                    } else {\n                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n                    }\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.SYMLINK);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 475,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,146 +1,159 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (baseUri \u003d\u003d null) {\n             baseUri \u003d \"\";\n         }\n         if (inputStream \u003d\u003d null) {\n             if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(manifestPath);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n-                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n+                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getLinkFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 URI submodUrl \u003d URI.create(nameUri);\n                 if (targetUri !\u003d null) {\n                     submodUrl \u003d relativize(targetUri, submodUrl);\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n+                for (LinkFile linkfile : proj.getLinkFiles()) {\n+                    String link;\n+                    if (linkfile.dest.contains(\"/\")) {\n+                        link \u003d FileUtils.relativizeGitPath(linkfile.dest.substring(0, linkfile.dest.lastIndexOf(\u0027/\u0027)), proj.getPath() + \"/\" + linkfile.src);\n+                    } else {\n+                        link \u003d proj.getPath() + \"/\" + linkfile.src;\n+                    }\n+                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, link.getBytes(Constants.CHARACTER_ENCODING));\n+                    dcEntry \u003d new DirCacheEntry(linkfile.dest);\n+                    dcEntry.setObjectId(objectId);\n+                    dcEntry.setFileMode(FileMode.SYMLINK);\n+                    builder.add(dcEntry);\n+                }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fe5437e96b91222e30d9105e7bab490fd68c2d52": {
      "type": "Ybodychange",
      "commitMessage": "Fix RepoCommand to allow for relative URLs\n\nThis is necessary for deploying submodules on android.googlesource.com.\n\n* Allow an empty base URL. This is useful if the \u0027fetch\u0027 field is \".\"\n  and all names are relative to some host root.\n\n* The URLs in the resulting superproject are relative to the\n  superproject\u0027s URL. Add RepoCommand#setDestinationURI to\n  set this. If unset, the existing behavior is maintained.\n\n* Add two tests for the Android and Gerrit case, checking the URL\n  format in .gitmodules; the tests use a custom RemoteReader which is\n  representative of the use of this class in Gerrit\u0027s Supermanifest\n  plugin.\n\nChange-Id: Ia75530226120d75aa0017c5410fd65d0563e91b\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/4/13 上午9:53",
      "commitName": "fe5437e96b91222e30d9105e7bab490fd68c2d52",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017/3/29 下午10:54",
      "commitNameOld": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 14.46,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (baseUri \u003d\u003d null) {\n            baseUri \u003d \"\";\n        }\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                URI submodUrl \u003d URI.create(nameUri);\n                if (targetUri !\u003d null) {\n                    submodUrl \u003d relativize(targetUri, submodUrl);\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 471,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,142 +1,146 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n-        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n-            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+        if (baseUri \u003d\u003d null) {\n+            baseUri \u003d \"\";\n         }\n         if (inputStream \u003d\u003d null) {\n             if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(manifestPath);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n-        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n+        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, baseUri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n+                URI submodUrl \u003d URI.create(nameUri);\n+                if (targetUri !\u003d null) {\n+                    submodUrl \u003d relativize(targetUri, submodUrl);\n+                }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n-                cfg.setString(\"submodule\", path, \"url\", nameUri);\n+                cfg.setString(\"submodule\", path, \"url\", submodUrl.toString());\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f32d65759c9afdcbec28eb3051ed9138b8e03271": {
      "type": "Ybodychange",
      "commitMessage": "Document the intended use of RepoCommand#setURI()\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I4a59dd8278b7b0026094692127b7f55e89c10bae\n",
      "commitDate": "2017/3/29 下午10:54",
      "commitName": "f32d65759c9afdcbec28eb3051ed9138b8e03271",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017/3/28 上午5:36",
      "commitNameOld": "27b05c7d719754427a97c141b44bec7de3acb8db",
      "commitAuthorOld": "Han-Wen Nienhuys",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        }\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 452,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,141 +1,142 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n-        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0) {\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+        }\n         if (inputStream \u003d\u003d null) {\n             if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(manifestPath);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 cfg.setString(\"submodule\", path, \"path\", path);\n                 cfg.setString(\"submodule\", path, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "27b05c7d719754427a97c141b44bec7de3acb8db": {
      "type": "Ybodychange",
      "commitMessage": "Consistently use \u0027path\u0027 for the path to a subrepo in RepoCommand\n\nSigned-off-by: Han-Wen Nienhuys \u003chanwen@google.com\u003e\nChange-Id: I79ea7eb7b4d319e0100e3121aca5ef82eb8ad92a\n",
      "commitDate": "2017/3/28 上午5:36",
      "commitName": "27b05c7d719754427a97c141b44bec7de3acb8db",
      "commitAuthor": "Han-Wen Nienhuys",
      "commitDateOld": "2017/2/21 上午5:47",
      "commitNameOld": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 34.99,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(manifestPath);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String path \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(path);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", path, \"path\", path);\n                cfg.setString(\"submodule\", path, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 448,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,141 +1,141 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n-            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+            if (manifestPath \u003d\u003d null || manifestPath.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n-                inputStream \u003d new FileInputStream(path);\n+                inputStream \u003d new FileInputStream(manifestPath);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n-        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n+        ManifestParser parser \u003d new ManifestParser(includedReader, manifestPath, branch, uri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n-                String name \u003d proj.getPath();\n+                String path \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n-                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n+                        cfg.setString(\"submodule\", path, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n-                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n+                        cfg.setBoolean(\"submodule\", path, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n-                    rec.append(name);\n+                    rec.append(path);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n-                cfg.setString(\"submodule\", name, \"path\", name);\n-                cfg.setString(\"submodule\", name, \"url\", nameUri);\n-                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+                cfg.setString(\"submodule\", path, \"path\", path);\n+                cfg.setString(\"submodule\", path, \"url\", nameUri);\n+                DirCacheEntry dcEntry \u003d new DirCacheEntry(path);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce": {
      "type": "Ybodychange",
      "commitMessage": "Enable and fix warnings about redundant specification of type arguments\n\nSince the introduction of generic type parameter inference in Java 7,\nit\u0027s not necessary to explicitly specify the type of generic parameters.\n\nEnable the warning in Eclipse, and fix all occurrences.\n\nChange-Id: I9158caf1beca5e4980b6240ac401f3868520aad0\nSigned-off-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\n",
      "commitDate": "2017/2/21 上午5:47",
      "commitName": "3b4448637fbb9d74e0c9d44048ba76bb7c1214ce",
      "commitAuthor": "David Pursehouse",
      "commitDateOld": "2017/2/20 上午8:05",
      "commitNameOld": "7ac182f4e427e0d5a986b8ca67a56fc22828b1a0",
      "commitAuthorOld": "David Pursehouse",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003c\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 448,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,141 +1,141 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n-            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n+            bareProjects \u003d new ArrayList\u003c\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(name);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a9b87de97090b4f7d25ace0525edc1268cfa737f": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Avoid group lists shadowing groups strings\n\nReported-by: David Pursehouse \u003cdavid.pursehouse@gmail.com\u003e\nChange-Id: I9e9b021d335bda4d58b6bcc30f59b81ac5b37724\nSigned-off-by: Jonathan Nieder \u003cjrn@google.com\u003e\n",
      "commitDate": "2016/8/9 上午9:51",
      "commitName": "a9b87de97090b4f7d25ace0525edc1268cfa737f",
      "commitAuthor": "Jonathan Nieder",
      "commitDateOld": "2016/6/1 下午4:17",
      "commitNameOld": "525baa1213097aa8635d846ce024635b1f33931a",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 68.73,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 453,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,141 +1,141 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n-        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n+        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groupsParam, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                     }\n                     if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                         cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                     }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(name);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: record manifest shallow recommendation in .gitmodules\n\nGit core learned about the submodule.\u003cname\u003e.shallow option in\n.gitmodules files, which is a recommendation to clone a submodule\nshallow. A repo manifest may record a clone depth recommendation as\nan optional field, which contains more information than a binary\nshallow/nonshallow recommendation, so any attempted conversion may be\nlossy. In practice the clone depth recommendation is either \u00271\u0027 or doesn\u0027t\nexist, which is the binary behavior we have in Git core.\n\nChange-Id: I51aa9cb6d1d9660dae6ab6d21ad7bae9bc5325e6\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2016/6/1 上午6:19",
      "commitName": "6ae4ed0f7da996bde2ba5cdc26daff979c9f6866",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2016/6/1 上午6:18",
      "commitNameOld": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
      "commitAuthorOld": "Stefan Beller",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 454,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,138 +1,141 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n-                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups());\n+                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups(), proj.getRecommendShallow());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                     }\n+                    if (recordShallowSubmodules \u0026\u0026 proj.getRecommendShallow() !\u003d null) {\n+                        cfg.setBoolean(\"submodule\", name, \"shallow\", true);\n+                    }\n                 }\n                 if (recordSubmoduleLabels) {\n                     StringBuilder rec \u003d new StringBuilder();\n                     rec.append(\"/\");\n                     rec.append(name);\n                     for (String group : proj.getGroups()) {\n                         rec.append(\" \");\n                         rec.append(group);\n                     }\n                     rec.append(\"\\n\");\n                     attributes.append(rec.toString());\n                 }\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             if (recordSubmoduleLabels) {\n                 final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                 ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                 dcEntryAttr.setObjectId(attrId);\n                 dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                 builder.add(dcEntryAttr);\n             }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ddd0fe257bc78dc9646407e7121769d0c03e0d94": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: record manifest groups as submodule labels\n\nGit core learned about attributes in pathspecs:\n\n    pathspec: allow querying for attributes\n\n    The pathspec mechanism is extended via the new\n    \":(attr:eol\u003dinput)pattern/to/match\" syntax to filter paths so that it\n    requires paths to not just match the given pattern but also have the\n    specified attrs attached for them to be chosen.\n\n(177161a5f7, 2016-05-20)\n\nWe intend to use these pathspec attribute patterns for submodule\ngrouping, similar to the grouping in repo. So the RepoCommand which\ntranslates repo manifest files into submodules should propagate this\ninformation along. This requires writing information to the\n.gitattributes file instead of the .gitmodules file. For now we just\noverwrite any existing .gitattributes file and do not care about prior\nattributes set. If this becomes an issue we need to figure out how to\ncorrectly amend the grouping information to an existing .gitattributes\nfile.\n\nChange-Id: I0f55b45786b6b8fc3d5be62d7f6aab9ac00ed60e\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2016/6/1 上午6:18",
      "commitName": "ddd0fe257bc78dc9646407e7121769d0c03e0d94",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2016/3/12 上午6:37",
      "commitNameOld": "7507d9e2a967e9c978e1fab3ca22deec1b5632c5",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 80.99,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            StringBuilder attributes \u003d new StringBuilder();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                }\n                if (recordSubmoduleLabels) {\n                    StringBuilder rec \u003d new StringBuilder();\n                    rec.append(\"/\");\n                    rec.append(name);\n                    for (String group : proj.getGroups()) {\n                        rec.append(\" \");\n                        rec.append(group);\n                    }\n                    rec.append(\"\\n\");\n                    attributes.append(rec.toString());\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            if (recordSubmoduleLabels) {\n                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n                dcEntryAttr.setObjectId(attrId);\n                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n                builder.add(dcEntryAttr);\n            }\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 438,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,119 +1,138 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n-                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n+                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles(), proj.getGroups());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n+            StringBuilder attributes \u003d new StringBuilder();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                     if (objectId \u003d\u003d null) {\n                         if (ignoreRemoteFailures) {\n                             continue;\n                         }\n                         throw new RemoteUnavailableException(nameUri);\n                     }\n                     if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                     }\n                 }\n+                if (recordSubmoduleLabels) {\n+                    StringBuilder rec \u003d new StringBuilder();\n+                    rec.append(\"/\");\n+                    rec.append(name);\n+                    for (String group : proj.getGroups()) {\n+                        rec.append(\" \");\n+                        rec.append(group);\n+                    }\n+                    rec.append(\"\\n\");\n+                    attributes.append(rec.toString());\n+                }\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n+            if (recordSubmoduleLabels) {\n+                final DirCacheEntry dcEntryAttr \u003d new DirCacheEntry(Constants.DOT_GIT_ATTRIBUTES);\n+                ObjectId attrId \u003d inserter.insert(Constants.OBJ_BLOB, attributes.toString().getBytes(Constants.CHARACTER_ENCODING));\n+                dcEntryAttr.setObjectId(attrId);\n+                dcEntryAttr.setFileMode(FileMode.REGULAR_FILE);\n+                builder.add(dcEntryAttr);\n+            }\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ecb016d7db42ab83584cab3c1554d4d28cc5062": {
      "type": "Ybodychange",
      "commitMessage": "Add ignoreRemoteFailures option to RepoCommand\n\nWith ignoreRemoteFailures set to true, we can ignore remote failures\n(e.g. the branch of a project described in the manifest file does not\nexist), skip that project and continue to the next one, instead of fail\nthe whole operation.\n\nChange-Id: I8b3765713599e34f1411f9bbc7f575ec7c2384e0\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2016/3/12 上午6:20",
      "commitName": "0ecb016d7db42ab83584cab3c1554d4d28cc5062",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015/11/26 上午6:05",
      "commitNameOld": "fe98218e0df85012cb9b901c71c44f232f65cb3a",
      "commitAuthorOld": "Jonathan Nieder",
      "daysBetweenCommits": 107.01,
      "commitsBetweenForRepo": 267,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (objectId \u003d\u003d null) {\n                        if (ignoreRemoteFailures) {\n                            continue;\n                        }\n                        throw new RemoteUnavailableException(nameUri);\n                    }\n                    if (recordRemoteBranch) {\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                    }\n                }\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 420,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,114 +1,119 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n-                cfg.setString(\"submodule\", name, \"path\", name);\n-                cfg.setString(\"submodule\", name, \"url\", nameUri);\n-                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n-                if (ObjectId.isId(proj.getRevision())) {\n+                if (ObjectId.isId(proj.getRevision()) \u0026\u0026 !ignoreRemoteFailures) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n-                    if (recordRemoteBranch)\n+                    if (objectId \u003d\u003d null) {\n+                        if (ignoreRemoteFailures) {\n+                            continue;\n+                        }\n+                        throw new RemoteUnavailableException(nameUri);\n+                    }\n+                    if (recordRemoteBranch) {\n                         cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n+                    }\n                 }\n-                if (objectId \u003d\u003d null)\n-                    throw new RemoteUnavailableException(nameUri);\n+                cfg.setString(\"submodule\", name, \"path\", name);\n+                cfg.setString(\"submodule\", name, \"url\", nameUri);\n+                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2": {
      "type": "Ybodychange",
      "commitMessage": "RepoCommand: Add setRecordRemoteBranch option to record upstream branch\n\nOn a server also running Gerrit that is using RepoCommand to\nconvert from an XML manifest to a git submodule superproject\nperiodically, it would be handy to be able to use Gerrit\u0027s\nsubmodule subscription feature[1] to update the superproject\nautomatically between RepoCommand runs as changes are merged\nin each subprojects.\n\nThis requires setting the \u0027branch\u0027 field for each submodule\nso that Gerrit knows what branch to watch.  Add an option to\ndo that.\n\nSetting the branch field also is useful for plain Git users,\nsince it allows them to use \"git submodule update --remote\" to\nmanually update all submodules between RepoCommand runs.\n\n[1] https://gerrit-review.googlesource.com/Documentation/user-submodules.html\n\nChange-Id: I1a10861bcd0df3b3673fc2d481c8129b2bdac5f9\nSigned-off-by: Stefan Beller \u003csbeller@google.com\u003e\n",
      "commitDate": "2015/10/6 上午7:01",
      "commitName": "cdd7c23446a0030e5b521d91cbb2d3a9c522ccc2",
      "commitAuthor": "Stefan Beller",
      "commitDateOld": "2015/7/11 上午2:39",
      "commitNameOld": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 87.18,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision())) {\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                } else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                    if (recordRemoteBranch)\n                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 394,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,114 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n-                if (ObjectId.isId(proj.getRevision()))\n+                if (ObjectId.isId(proj.getRevision())) {\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n-                else {\n+                } else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n+                    if (recordRemoteBranch)\n+                        cfg.setString(\"submodule\", name, \"branch\", proj.getRevision());\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "217b2a7cc5366491be5317d20f3f3c1b6e3475bf": {
      "type": "Ybodychange",
      "commitMessage": "Add setTargetBranch in RepoCommand.\n\nThis will allow us to write the super project in a branch other than\nmaster.\n\nChange-Id: I578ed9ecbc6423416239e31ad644531dae9fb5c3\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015/7/11 上午2:39",
      "commitName": "217b2a7cc5366491be5317d20f3f3c1b6e3475bf",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015/5/27 上午12:58",
      "commitNameOld": "744c370c1be8044d1ccaaf84cd164324961fea1a",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 45.07,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()))\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(targetBranch);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 369,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n                 addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.getPath();\n                 String nameUri \u003d proj.getName();\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.getRevision()))\n                     objectId \u003d ObjectId.fromString(proj.getRevision());\n                 else {\n                     objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.getCopyFiles()) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n-            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+            ObjectId headId \u003d repo.resolve(targetBranch + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n-            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+            RefUpdate ru \u003d repo.updateRef(targetBranch);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n-                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                    throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetBranch), ru.getRef(), rc);\n                 default:\n-                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n+                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetBranch, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "744c370c1be8044d1ccaaf84cd164324961fea1a": {
      "type": "Ybodychange",
      "commitMessage": "Add getters to RepoProject.\n\nChange-Id: I74ded6c2c3f5985568cd77bd8799b45017fb1d09\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015/5/27 上午12:58",
      "commitName": "744c370c1be8044d1ccaaf84cd164324961fea1a",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015/5/24 下午4:27",
      "commitNameOld": "1773002a3446c93ab03997b65139fc7d014599b9",
      "commitAuthorOld": "Andrey Loskutov",
      "daysBetweenCommits": 2.36,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.getPath();\n                String nameUri \u003d proj.getName();\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.getRevision()))\n                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                else {\n                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.getCopyFiles()) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 350,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n             parser.read(inputStream);\n             for (RepoProject proj : parser.getFilteredProjects()) {\n-                addSubmodule(proj.url, proj.path, proj.getRevision(), proj.copyfiles);\n+                addSubmodule(proj.getUrl(), proj.getPath(), proj.getRevision(), proj.getCopyFiles());\n             }\n         } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             for (RepoProject proj : bareProjects) {\n-                String name \u003d proj.path;\n-                String nameUri \u003d proj.name;\n+                String name \u003d proj.getPath();\n+                String nameUri \u003d proj.getName();\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n-                if (ObjectId.isId(proj.revision))\n-                    objectId \u003d ObjectId.fromString(proj.revision);\n+                if (ObjectId.isId(proj.getRevision()))\n+                    objectId \u003d ObjectId.fromString(proj.getRevision());\n                 else {\n-                    objectId \u003d callback.sha1(nameUri, proj.revision);\n+                    objectId \u003d callback.sha1(nameUri, proj.getRevision());\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n-                for (CopyFile copyfile : proj.copyfiles) {\n-                    byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n+                for (CopyFile copyfile : proj.getCopyFiles()) {\n+                    byte[] src \u003d callback.readFile(nameUri, proj.getRevision(), copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c": {
      "type": "Ybodychange",
      "commitMessage": "Refactor to expose ManifestParser.\n\nThe repo xml manifest parser used in RepoCommand could also be useful for\nothers, so refactor to make it public.\n\nAlso this breaks backward compatibility slightly.\n\nChange-Id: I5001bd2fe77541109fe32dbe2597a065e6ad585e\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2015/5/23 上午2:08",
      "commitName": "d3348e5623a2abf7b2f1356ea077d6eb9bf7760c",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2015/5/21 上午6:01",
      "commitNameOld": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n        try {\n            parser.read(inputStream);\n            for (RepoProject proj : parser.getFilteredProjects()) {\n                addSubmodule(proj.url, proj.path, proj.getRevision(), proj.copyfiles);\n            }\n        } catch (GitAPIException | IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (RepoProject proj : bareProjects) {\n                String name \u003d proj.path;\n                String nameUri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 351,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,109 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n-            bareProjects \u003d new ArrayList\u003cProject\u003e();\n+            bareProjects \u003d new ArrayList\u003cRepoProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n-        XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n+        ManifestParser parser \u003d new ManifestParser(includedReader, path, branch, uri, groups, repo);\n         try {\n-            manifest.read(inputStream);\n-        } catch (IOException e) {\n+            parser.read(inputStream);\n+            for (RepoProject proj : parser.getFilteredProjects()) {\n+                addSubmodule(proj.url, proj.path, proj.getRevision(), proj.copyfiles);\n+            }\n+        } catch (GitAPIException | IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n-            for (Project proj : bareProjects) {\n+            for (RepoProject proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String nameUri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n                     objectId \u003d callback.sha1(nameUri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.copyfiles) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e73d395061d1bfee365acaa2f79c392175d13bf": {
      "type": "Ybodychange",
      "commitMessage": "Use AutoClosable to close resources in bundle org.eclipse.jgit\n\n- use try-with-resource where possible\n- replace use of deprecated release() by close()\n\nChange-Id: I0f139c3535679087b7fa09649166bca514750b81\nSigned-off-by: Matthias Sohn \u003cmatthias.sohn@sap.com\u003e",
      "commitDate": "2015/5/21 上午6:01",
      "commitName": "0e73d395061d1bfee365acaa2f79c392175d13bf",
      "commitAuthor": "Matthias Sohn",
      "commitDateOld": "2015/1/22 上午7:42",
      "commitNameOld": "9ffe6deced8dd79dd283fff650a8ac19ce3d9a08",
      "commitAuthorOld": "Matthias Sohn",
      "daysBetweenCommits": 118.93,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        try (RevWalk rw \u003d new RevWalk(repo)) {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String nameUri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 699,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,109 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n         try {\n             manifest.read(inputStream);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n-        RevWalk rw \u003d new RevWalk(repo);\n-        try {\n+        try (RevWalk rw \u003d new RevWalk(repo)) {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String nameUri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n                     objectId \u003d callback.sha1(nameUri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.copyfiles) {\n                     byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n-        } finally {\n-            rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386": {
      "type": "Ybodychange",
      "commitMessage": "Rename local variables/parameters to remove warnings about hiding\n\nChange-Id: I73f38492b6a2e7fd6e77005efd0a8a8c65763e74\n",
      "commitDate": "2014/9/4 下午5:35",
      "commitName": "2f6372337cfd5944e2179f5ec5e2dbe0cbc96386",
      "commitAuthor": "Robin Rosenberg",
      "commitDateOld": "2014/9/4 下午5:28",
      "commitNameOld": "0bc98f17b2b3504b1b180a605e45654ace49ef1a",
      "commitAuthorOld": "Robin Rosenberg",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String nameUri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(nameUri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(nameUri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 702,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n         XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n         try {\n             manifest.read(inputStream);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         RevWalk rw \u003d new RevWalk(repo);\n         try {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n-                String uri \u003d proj.name;\n+                String nameUri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n-                cfg.setString(\"submodule\", name, \"url\", uri);\n+                cfg.setString(\"submodule\", name, \"url\", nameUri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n-                    objectId \u003d callback.sha1(uri, proj.revision);\n+                    objectId \u003d callback.sha1(nameUri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n-                    throw new RemoteUnavailableException(uri);\n+                    throw new RemoteUnavailableException(nameUri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.copyfiles) {\n-                    byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n+                    byte[] src \u003d callback.readFile(nameUri, proj.revision, copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         } finally {\n             rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "34dd64f6fe36ace1a90b0b503e2e37d877b7c621": {
      "type": "Ybodychange",
      "commitMessage": "Add support to \u003cinclude\u003e tag in repo manifest xml.\n\nChange-Id: I32d468f92e24701ea680435bf3417e3850857303\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/8/14 上午4:04",
      "commitName": "34dd64f6fe36ace1a90b0b503e2e37d877b7c621",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/8/14 上午1:36",
      "commitNameOld": "38a24bc7990bfa76e5dbd905434341a28e8e543f",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n        try {\n            manifest.read(inputStream);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String uri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(uri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 677,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,112 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     try {\n         checkCallable();\n         if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n             throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n         if (inputStream \u003d\u003d null) {\n             if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             try {\n                 inputStream \u003d new FileInputStream(path);\n             } catch (IOException e) {\n                 throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n             }\n         }\n         if (repo.isBare()) {\n             bareProjects \u003d new ArrayList\u003cProject\u003e();\n             if (author \u003d\u003d null)\n                 author \u003d new PersonIdent(repo);\n             if (callback \u003d\u003d null)\n                 callback \u003d new DefaultRemoteReader();\n         } else\n             git \u003d new Git(repo);\n-        XmlManifest manifest \u003d new XmlManifest(this, inputStream, path, uri, groups);\n+        XmlManifest manifest \u003d new XmlManifest(this, includedReader, path, uri, groups);\n         try {\n-            manifest.read();\n+            manifest.read(inputStream);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         }\n     } finally {\n         try {\n             if (inputStream !\u003d null)\n                 inputStream.close();\n         } catch (IOException e) {\n         }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         RevWalk rw \u003d new RevWalk(repo);\n         try {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String uri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", uri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n                     objectId \u003d callback.sha1(uri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(uri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.copyfiles) {\n                     byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         } finally {\n             rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acd7ed52692bb7155333efea6dead712b7156ab9": {
      "type": "Ybodychange",
      "commitMessage": "Added setInputStream to RepoCommand.\n\nSometimes an input stream is more useful than the filename of the xml manifest.\n\nChange-Id: Icb09ac751b3d8d7eb14427ad1aac8cee0c371c5f\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/6/10 上午1:26",
      "commitName": "acd7ed52692bb7155333efea6dead712b7156ab9",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/6/6 上午8:40",
      "commitNameOld": "39001eacc1158050d6f1deaea259b4fe4af136dc",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    try {\n        checkCallable();\n        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n        if (inputStream \u003d\u003d null) {\n            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            try {\n                inputStream \u003d new FileInputStream(path);\n            } catch (IOException e) {\n                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n            }\n        }\n        if (repo.isBare()) {\n            bareProjects \u003d new ArrayList\u003cProject\u003e();\n            if (author \u003d\u003d null)\n                author \u003d new PersonIdent(repo);\n            if (callback \u003d\u003d null)\n                callback \u003d new DefaultRemoteReader();\n        } else\n            git \u003d new Git(repo);\n        XmlManifest manifest \u003d new XmlManifest(this, inputStream, path, uri, groups);\n        try {\n            manifest.read();\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        }\n    } finally {\n        try {\n            if (inputStream !\u003d null)\n                inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String uri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(uri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 519,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,97 +1,112 @@\n @Override\n public RevCommit call() throws GitAPIException {\n-    checkCallable();\n-    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n-        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n-    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n-        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n-    if (repo.isBare()) {\n-        bareProjects \u003d new ArrayList\u003cProject\u003e();\n-        if (author \u003d\u003d null)\n-            author \u003d new PersonIdent(repo);\n-        if (callback \u003d\u003d null)\n-            callback \u003d new DefaultRemoteReader();\n-    } else\n-        git \u003d new Git(repo);\n-    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n-        manifest.read();\n-    } catch (IOException e) {\n-        throw new ManifestErrorException(e);\n+        checkCallable();\n+        if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+            throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+        if (inputStream \u003d\u003d null) {\n+            if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n+            try {\n+                inputStream \u003d new FileInputStream(path);\n+            } catch (IOException e) {\n+                throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n+            }\n+        }\n+        if (repo.isBare()) {\n+            bareProjects \u003d new ArrayList\u003cProject\u003e();\n+            if (author \u003d\u003d null)\n+                author \u003d new PersonIdent(repo);\n+            if (callback \u003d\u003d null)\n+                callback \u003d new DefaultRemoteReader();\n+        } else\n+            git \u003d new Git(repo);\n+        XmlManifest manifest \u003d new XmlManifest(this, inputStream, path, uri, groups);\n+        try {\n+            manifest.read();\n+        } catch (IOException e) {\n+            throw new ManifestErrorException(e);\n+        }\n+    } finally {\n+        try {\n+            if (inputStream !\u003d null)\n+                inputStream.close();\n+        } catch (IOException e) {\n+        }\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         RevWalk rw \u003d new RevWalk(repo);\n         try {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String uri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", uri);\n                 DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n                     objectId \u003d callback.sha1(uri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(uri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n                 for (CopyFile copyfile : proj.copyfiles) {\n                     byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n                     objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                     dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                     dcEntry.setObjectId(objectId);\n                     dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                     builder.add(dcEntry);\n                 }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         } finally {\n             rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0b15b48f741f87277e0d1c7d29637430b880dbde": {
      "type": "Ybodychange",
      "commitMessage": "Handle repo copyfile in bare repositories.\n\nChange-Id: Ie06f0c3d1bc9b2123102efaa5542ec3c232b72cd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/5/10 上午8:25",
      "commitName": "0b15b48f741f87277e0d1c7d29637430b880dbde",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/5/10 上午8:25",
      "commitNameOld": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003cProject\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n    } else\n        git \u003d new Git(repo);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String uri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(uri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n                for (CopyFile copyfile : proj.copyfiles) {\n                    byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n                    dcEntry.setObjectId(objectId);\n                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n                    builder.add(dcEntry);\n                }\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 498,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,89 +1,97 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n     if (repo.isBare()) {\n         bareProjects \u003d new ArrayList\u003cProject\u003e();\n         if (author \u003d\u003d null)\n             author \u003d new PersonIdent(repo);\n         if (callback \u003d\u003d null)\n             callback \u003d new DefaultRemoteReader();\n     } else\n         git \u003d new Git(repo);\n     XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         RevWalk rw \u003d new RevWalk(repo);\n         try {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String uri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", uri);\n-                final DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+                DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n                 if (ObjectId.isId(proj.revision))\n                     objectId \u003d ObjectId.fromString(proj.revision);\n                 else {\n                     objectId \u003d callback.sha1(uri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n                     throw new RemoteUnavailableException(uri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n+                for (CopyFile copyfile : proj.copyfiles) {\n+                    byte[] src \u003d callback.readFile(uri, proj.revision, copyfile.src);\n+                    objectId \u003d inserter.insert(Constants.OBJ_BLOB, src);\n+                    dcEntry \u003d new DirCacheEntry(copyfile.dest);\n+                    dcEntry.setObjectId(objectId);\n+                    dcEntry.setFileMode(FileMode.REGULAR_FILE);\n+                    builder.add(dcEntry);\n+                }\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         } finally {\n             rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d998bc938a21cb3871b442a3bb54b5807b6e4ed2": {
      "type": "Ybodychange",
      "commitMessage": "Handle the revision attribute in repo manifest.\n\nChange-Id: I77fe073aeb13c58029551b7d6e1451a9b62dc766\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/5/10 上午8:25",
      "commitName": "d998bc938a21cb3871b442a3bb54b5807b6e4ed2",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/5/8 上午2:03",
      "commitNameOld": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003cProject\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n    } else\n        git \u003d new Git(repo);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String uri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                final DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                if (ObjectId.isId(proj.revision))\n                    objectId \u003d ObjectId.fromString(proj.revision);\n                else {\n                    objectId \u003d callback.sha1(uri, proj.revision);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(uri);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 469,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,91 +1,89 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n     if (repo.isBare()) {\n         bareProjects \u003d new ArrayList\u003cProject\u003e();\n         if (author \u003d\u003d null)\n             author \u003d new PersonIdent(repo);\n         if (callback \u003d\u003d null)\n             callback \u003d new DefaultRemoteReader();\n     } else\n         git \u003d new Git(repo);\n     XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n     if (repo.isBare()) {\n         DirCache index \u003d DirCache.newInCore();\n         DirCacheBuilder builder \u003d index.builder();\n         ObjectInserter inserter \u003d repo.newObjectInserter();\n         RevWalk rw \u003d new RevWalk(repo);\n         try {\n             Config cfg \u003d new Config();\n             for (Project proj : bareProjects) {\n                 String name \u003d proj.path;\n                 String uri \u003d proj.name;\n                 cfg.setString(\"submodule\", name, \"path\", name);\n                 cfg.setString(\"submodule\", name, \"url\", uri);\n                 final DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                 ObjectId objectId;\n-                try {\n-                    objectId \u003d callback.sha1(uri);\n-                } catch (GitAPIException e) {\n-                    throw new RemoteUnavailableException(uri, e);\n-                } catch (IllegalArgumentException e) {\n-                    throw new ManifestErrorException(e);\n+                if (ObjectId.isId(proj.revision))\n+                    objectId \u003d ObjectId.fromString(proj.revision);\n+                else {\n+                    objectId \u003d callback.sha1(uri, proj.revision);\n                 }\n                 if (objectId \u003d\u003d null)\n-                    throw new RemoteUnavailableException(uri, null);\n+                    throw new RemoteUnavailableException(uri);\n                 dcEntry.setObjectId(objectId);\n                 dcEntry.setFileMode(FileMode.GITLINK);\n                 builder.add(dcEntry);\n             }\n             String content \u003d cfg.toText();\n             final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n             ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n             dcEntry.setObjectId(objectId);\n             dcEntry.setFileMode(FileMode.REGULAR_FILE);\n             builder.add(dcEntry);\n             builder.finish();\n             ObjectId treeId \u003d index.writeTree(inserter);\n             ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n             CommitBuilder commit \u003d new CommitBuilder();\n             commit.setTreeId(treeId);\n             if (headId !\u003d null)\n                 commit.setParentIds(headId);\n             commit.setAuthor(author);\n             commit.setCommitter(author);\n             commit.setMessage(RepoText.get().repoCommitMessage);\n             ObjectId commitId \u003d inserter.insert(commit);\n             inserter.flush();\n             RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n             ru.setNewObjectId(commitId);\n             ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n             Result rc \u003d ru.update(rw);\n             switch(rc) {\n                 case NEW:\n                 case FORCED:\n                 case FAST_FORWARD:\n                     break;\n                 case REJECTED:\n                 case LOCK_FAILURE:\n                     throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                 default:\n                     throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n             }\n             return rw.parseCommit(commitId);\n         } catch (IOException e) {\n             throw new ManifestErrorException(e);\n         } finally {\n             rw.release();\n         }\n     } else {\n         return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "056135a1482a9d56ee5055d6bc2df5bea032b5e5": {
      "type": "Ybodychange",
      "commitMessage": "Handle repo submodules for bare repositories.\n\nChange-Id: Id028a7bc9600baf0f3e2316a1f4b99e53ccc746a\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/5/8 上午2:03",
      "commitName": "056135a1482a9d56ee5055d6bc2df5bea032b5e5",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/4/26 上午1:42",
      "commitNameOld": "dc4c673902a0847b270faf1771595d7c189a1943",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 12.01,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    if (repo.isBare()) {\n        bareProjects \u003d new ArrayList\u003cProject\u003e();\n        if (author \u003d\u003d null)\n            author \u003d new PersonIdent(repo);\n        if (callback \u003d\u003d null)\n            callback \u003d new DefaultRemoteReader();\n    } else\n        git \u003d new Git(repo);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    if (repo.isBare()) {\n        DirCache index \u003d DirCache.newInCore();\n        DirCacheBuilder builder \u003d index.builder();\n        ObjectInserter inserter \u003d repo.newObjectInserter();\n        RevWalk rw \u003d new RevWalk(repo);\n        try {\n            Config cfg \u003d new Config();\n            for (Project proj : bareProjects) {\n                String name \u003d proj.path;\n                String uri \u003d proj.name;\n                cfg.setString(\"submodule\", name, \"path\", name);\n                cfg.setString(\"submodule\", name, \"url\", uri);\n                final DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n                ObjectId objectId;\n                try {\n                    objectId \u003d callback.sha1(uri);\n                } catch (GitAPIException e) {\n                    throw new RemoteUnavailableException(uri, e);\n                } catch (IllegalArgumentException e) {\n                    throw new ManifestErrorException(e);\n                }\n                if (objectId \u003d\u003d null)\n                    throw new RemoteUnavailableException(uri, null);\n                dcEntry.setObjectId(objectId);\n                dcEntry.setFileMode(FileMode.GITLINK);\n                builder.add(dcEntry);\n            }\n            String content \u003d cfg.toText();\n            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n            dcEntry.setObjectId(objectId);\n            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n            builder.add(dcEntry);\n            builder.finish();\n            ObjectId treeId \u003d index.writeTree(inserter);\n            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n            CommitBuilder commit \u003d new CommitBuilder();\n            commit.setTreeId(treeId);\n            if (headId !\u003d null)\n                commit.setParentIds(headId);\n            commit.setAuthor(author);\n            commit.setCommitter(author);\n            commit.setMessage(RepoText.get().repoCommitMessage);\n            ObjectId commitId \u003d inserter.insert(commit);\n            inserter.flush();\n            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n            ru.setNewObjectId(commitId);\n            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n            Result rc \u003d ru.update(rw);\n            switch(rc) {\n                case NEW:\n                case FORCED:\n                case FAST_FORWARD:\n                    break;\n                case REJECTED:\n                case LOCK_FAILURE:\n                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n                default:\n                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n            }\n            return rw.parseCommit(commitId);\n        } catch (IOException e) {\n            throw new ManifestErrorException(e);\n        } finally {\n            rw.release();\n        }\n    } else {\n        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n    }\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 438,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,16 +1,91 @@\n @Override\n public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n-    git \u003d new Git(repo);\n+    if (repo.isBare()) {\n+        bareProjects \u003d new ArrayList\u003cProject\u003e();\n+        if (author \u003d\u003d null)\n+            author \u003d new PersonIdent(repo);\n+        if (callback \u003d\u003d null)\n+            callback \u003d new DefaultRemoteReader();\n+    } else\n+        git \u003d new Git(repo);\n     XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n-    return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n+    if (repo.isBare()) {\n+        DirCache index \u003d DirCache.newInCore();\n+        DirCacheBuilder builder \u003d index.builder();\n+        ObjectInserter inserter \u003d repo.newObjectInserter();\n+        RevWalk rw \u003d new RevWalk(repo);\n+        try {\n+            Config cfg \u003d new Config();\n+            for (Project proj : bareProjects) {\n+                String name \u003d proj.path;\n+                String uri \u003d proj.name;\n+                cfg.setString(\"submodule\", name, \"path\", name);\n+                cfg.setString(\"submodule\", name, \"url\", uri);\n+                final DirCacheEntry dcEntry \u003d new DirCacheEntry(name);\n+                ObjectId objectId;\n+                try {\n+                    objectId \u003d callback.sha1(uri);\n+                } catch (GitAPIException e) {\n+                    throw new RemoteUnavailableException(uri, e);\n+                } catch (IllegalArgumentException e) {\n+                    throw new ManifestErrorException(e);\n+                }\n+                if (objectId \u003d\u003d null)\n+                    throw new RemoteUnavailableException(uri, null);\n+                dcEntry.setObjectId(objectId);\n+                dcEntry.setFileMode(FileMode.GITLINK);\n+                builder.add(dcEntry);\n+            }\n+            String content \u003d cfg.toText();\n+            final DirCacheEntry dcEntry \u003d new DirCacheEntry(Constants.DOT_GIT_MODULES);\n+            ObjectId objectId \u003d inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));\n+            dcEntry.setObjectId(objectId);\n+            dcEntry.setFileMode(FileMode.REGULAR_FILE);\n+            builder.add(dcEntry);\n+            builder.finish();\n+            ObjectId treeId \u003d index.writeTree(inserter);\n+            ObjectId headId \u003d repo.resolve(Constants.HEAD + \"^{commit}\");\n+            CommitBuilder commit \u003d new CommitBuilder();\n+            commit.setTreeId(treeId);\n+            if (headId !\u003d null)\n+                commit.setParentIds(headId);\n+            commit.setAuthor(author);\n+            commit.setCommitter(author);\n+            commit.setMessage(RepoText.get().repoCommitMessage);\n+            ObjectId commitId \u003d inserter.insert(commit);\n+            inserter.flush();\n+            RefUpdate ru \u003d repo.updateRef(Constants.HEAD);\n+            ru.setNewObjectId(commitId);\n+            ru.setExpectedOldObjectId(headId !\u003d null ? headId : ObjectId.zeroId());\n+            Result rc \u003d ru.update(rw);\n+            switch(rc) {\n+                case NEW:\n+                case FORCED:\n+                case FAST_FORWARD:\n+                    break;\n+                case REJECTED:\n+                case LOCK_FAILURE:\n+                    throw new ConcurrentRefUpdateException(JGitText.get().couldNotLockHEAD, ru.getRef(), rc);\n+                default:\n+                    throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, Constants.HEAD, commitId.name(), rc));\n+            }\n+            return rw.parseCommit(commitId);\n+        } catch (IOException e) {\n+            throw new ManifestErrorException(e);\n+        } finally {\n+            rw.release();\n+        }\n+    } else {\n+        return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n+    }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc4c673902a0847b270faf1771595d7c189a1943": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
      "commitDate": "2014/4/26 上午1:42",
      "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
          "commitDate": "2014/4/26 上午1:42",
          "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2014/4/24 下午2:03",
          "commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
          "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
          "daysBetweenCommits": 1.49,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    git \u003d new Git(repo);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
          "functionStartLine": 351,
          "functionName": "call",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,16 @@\n @Override\n-public Void call() throws GitAPIException {\n+public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+    git \u003d new Git(repo);\n     XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n-    return null;\n+    return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Void",
            "newValue": "RevCommit"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Commit changes generated during repo command\n\nChange-Id: Ia4df9808294d2069dcc5973bcb69b4499c7dcacd\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e",
          "commitDate": "2014/4/26 上午1:42",
          "commitName": "dc4c673902a0847b270faf1771595d7c189a1943",
          "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
          "commitDateOld": "2014/4/24 下午2:03",
          "commitNameOld": "51cccc9dae3191567a2972a7ebe692b1629808c1",
          "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
          "daysBetweenCommits": 1.49,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic RevCommit call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    git \u003d new Git(repo);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n}",
          "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
          "functionStartLine": 351,
          "functionName": "call",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,15 +1,16 @@\n @Override\n-public Void call() throws GitAPIException {\n+public RevCommit call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+    git \u003d new Git(repo);\n     XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n-    return null;\n+    return git.commit().setMessage(RepoText.get().repoCommitMessage).call();\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "a44a687fedbf1559277b8e6706819aa9be7bce39": {
      "type": "Ybodychange",
      "commitMessage": "Added groups support to repo subcommand.\n\nChange-Id: Id0e7663b6ac4f6938fdcacaf2158107b6285fc25\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/4/24 下午2:03",
      "commitName": "a44a687fedbf1559277b8e6706819aa9be7bce39",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "commitDateOld": "2014/4/24 下午1:48",
      "commitNameOld": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
      "commitAuthorOld": "Yuxuan \u0027fishy\u0027 Wang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Void call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    return null;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 278,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,15 +1,15 @@\n @Override\n public Void call() throws GitAPIException {\n     checkCallable();\n     if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n     if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n         throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n-    XmlManifest manifest \u003d new XmlManifest(this, path, uri);\n+    XmlManifest manifest \u003d new XmlManifest(this, path, uri, groups);\n     try {\n         manifest.read();\n     } catch (IOException e) {\n         throw new ManifestErrorException(e);\n     }\n     return null;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0ad8fa7b36dafbea07da15897cc2f2b601772e24": {
      "type": "Yintroduced",
      "commitMessage": "Implemented first part of the repo sub-command.\n\nCurrently the repo sub-command only \"works\", but the submodules will have .git\ndirectories themselves, and lacks group support.\n\nChange-Id: I88a6ee07109187c6c9bfd92a044775fcfb5befa6\nSigned-off-by: Yuxuan \u0027fishy\u0027 Wang \u003cfishywang@google.com\u003e\n",
      "commitDate": "2014/4/24 下午1:48",
      "commitName": "0ad8fa7b36dafbea07da15897cc2f2b601772e24",
      "commitAuthor": "Yuxuan \u0027fishy\u0027 Wang",
      "diff": "@@ -0,0 +1,15 @@\n+@Override\n+public Void call() throws GitAPIException {\n+    checkCallable();\n+    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n+        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n+    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n+        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n+    XmlManifest manifest \u003d new XmlManifest(this, path, uri);\n+    try {\n+        manifest.read();\n+    } catch (IOException e) {\n+        throw new ManifestErrorException(e);\n+    }\n+    return null;\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic Void call() throws GitAPIException {\n    checkCallable();\n    if (path \u003d\u003d null || path.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().pathNotConfigured);\n    if (uri \u003d\u003d null || uri.length() \u003d\u003d 0)\n        throw new IllegalArgumentException(JGitText.get().uriNotConfigured);\n    XmlManifest manifest \u003d new XmlManifest(this, path, uri);\n    try {\n        manifest.read();\n    } catch (IOException e) {\n        throw new ManifestErrorException(e);\n    }\n    return null;\n}",
      "path": "org.eclipse.jgit/src/org/eclipse/jgit/gitrepo/RepoCommand.java",
      "functionStartLine": 221,
      "functionName": "call",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}