{
  "origin": "codeshovel",
  "repositoryName": "javaparser",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/javaparser/.git",
  "startCommitName": "97555053af3025556efe1a168fd7943dac28a2a6",
  "sourceFileName": "MethodCallExprContext.java",
  "functionName": "solveMethodAsUsage",
  "functionId": "solveMethodAsUsage___name-String__argumentsTypes-List__ResolvedType____typeSolver-TypeSolver",
  "sourceFilePath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
  "functionAnnotation": "@Override",
  "functionDoc": "",
  "functionStartLine": 76,
  "functionEndLine": 121,
  "numCommitsSeen": 198,
  "timeTaken": 1464,
  "changeHistory": [
    "791449a6ab0696f4c0109908a4a0925e514b10d9",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
    "5d8d0cb7947efcf2282f7d056302dd905f348532",
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
    "acdac6790f4424f8097b3aa6c888e825cac485f9",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
    "03055f925053b3970b9d14cce3a3b9a0d002366d",
    "a1c7c58143a592965f8378767adc69709e4c0043",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
    "d017fb8caf6ccb3343da0062eb2c85262712772c",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1",
    "9c53c2cbc607ea694438ade8630be0c155a33162",
    "03e407957d600a18ef0a4a83224c17d155ef8645",
    "341e081a5f8909a3a467671befcca2941b786d3d",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
    "8d234965b572759181da7787fead07b225e9e5ca",
    "82eb44707b620803d424188a1eb8708fcaf093cb",
    "38d780df85a22c9baffb1f772a45b063cad73aab",
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
    "ead147279ca0b84d2f479a714943b20cd689e7c7",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
    "e21fca16e413a8bf31d613aa97a744d075c374dd",
    "0e81f51c40996b42cb262dc2397126cee8f60965",
    "b36f33050149a62a5b3c8c7451ae93f736715029",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257",
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
    "46aefdd68f2f2597a19b72da36681123cb3090e6",
    "6c297529e31036058837adbaa57cee652d4cc918",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
    "627b56302d259409e9bc50b20d77803484f18b5c",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606"
  ],
  "changeHistoryShort": {
    "791449a6ab0696f4c0109908a4a0925e514b10d9": "Ybodychange",
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": "Yfilerename",
    "5d8d0cb7947efcf2282f7d056302dd905f348532": "Ymultichange(Yparameterchange,Ybodychange)",
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760": "Ybodychange",
    "acdac6790f4424f8097b3aa6c888e825cac485f9": "Ybodychange",
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": "Ybodychange",
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": "Ybodychange",
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": "Ybodychange",
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": "Ybodychange",
    "03055f925053b3970b9d14cce3a3b9a0d002366d": "Ybodychange",
    "a1c7c58143a592965f8378767adc69709e4c0043": "Ybodychange",
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": "Ybodychange",
    "d017fb8caf6ccb3343da0062eb2c85262712772c": "Ybodychange",
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": "Ybodychange",
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": "Ybodychange",
    "9c53c2cbc607ea694438ade8630be0c155a33162": "Yfilerename",
    "03e407957d600a18ef0a4a83224c17d155ef8645": "Ybodychange",
    "341e081a5f8909a3a467671befcca2941b786d3d": "Ybodychange",
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": "Ymultichange(Yparameterchange,Ybodychange)",
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": "Ybodychange",
    "8d234965b572759181da7787fead07b225e9e5ca": "Ybodychange",
    "82eb44707b620803d424188a1eb8708fcaf093cb": "Ymultichange(Yparameterchange,Ybodychange)",
    "38d780df85a22c9baffb1f772a45b063cad73aab": "Ybodychange",
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76": "Ybodychange",
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": "Yfilerename",
    "ead147279ca0b84d2f479a714943b20cd689e7c7": "Ybodychange",
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": "Yfilerename",
    "e21fca16e413a8bf31d613aa97a744d075c374dd": "Ybodychange",
    "0e81f51c40996b42cb262dc2397126cee8f60965": "Ybodychange",
    "b36f33050149a62a5b3c8c7451ae93f736715029": "Yfilerename",
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": "Ybodychange",
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": "Ybodychange",
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": "Ybodychange",
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30": "Ybodychange",
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": "Ybodychange",
    "46aefdd68f2f2597a19b72da36681123cb3090e6": "Ybodychange",
    "6c297529e31036058837adbaa57cee652d4cc918": "Ybodychange",
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": "Ybodychange",
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": "Ybodychange",
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": "Ybodychange",
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731": "Ybodychange",
    "627b56302d259409e9bc50b20d77803484f18b5c": "Ybodychange",
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": "Yintroduced"
  },
  "changeHistoryDetails": {
    "791449a6ab0696f4c0109908a4a0925e514b10d9": {
      "type": "Ybodychange",
      "commitMessage": "fixing failing tests by considering the context of calls within ObjectCreationExpr\n",
      "commitDate": "2018/6/6 下午9:52",
      "commitName": "791449a6ab0696f4c0109908a4a0925e514b10d9",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/3/30 下午9:12",
      "commitNameOld": "7df79507310cc762c732281053961e6a89078f80",
      "commitAuthorOld": "daans",
      "daysBetweenCommits": 68.03,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 76,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,39 +1,39 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n             SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n             ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n-        while (parentContext instanceof MethodCallExprContext) {\n+        while (parentContext instanceof MethodCallExprContext || parentContext instanceof ObjectCreationContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "09232ff6b0ea19e850482f3a87ac6ef1c063c759": {
      "type": "Yfilerename",
      "commitMessage": "rename JSS modules\n",
      "commitDate": "2018/1/10 下午8:52",
      "commitName": "09232ff6b0ea19e850482f3a87ac6ef1c063c759",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2018/1/10 下午4:01",
      "commitNameOld": "30c04db173cc439556df2a238c99cd81ada320ff",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 74,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "5d8d0cb7947efcf2282f7d056302dd905f348532": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "more work on converting to moved classes\n",
      "commitDate": "2017/9/29 上午4:36",
      "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/8/28 下午5:15",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 73,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,39 +1,39 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n-                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n+        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            Type originalArgumentType \u003d argumentsTypes.get(i);\n-            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n+            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cResolvedType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "more work on converting to moved classes\n",
          "commitDate": "2017/9/29 上午4:36",
          "commitName": "5d8d0cb7947efcf2282f7d056302dd905f348532",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2017/8/28 下午5:15",
          "commitNameOld": "abec22a71cd36e52d79a4575c21294ffd48c7016",
          "commitAuthorOld": "mlangkabel",
          "daysBetweenCommits": 31.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 73,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,39 +1,39 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cResolvedType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+            SymbolReference\u003cResolvedTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n-                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                SymbolReference\u003cResolvedMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n-        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n+        ResolvedType typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n+        Map\u003cResolvedTypeParameterDeclaration, ResolvedType\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            Type originalArgumentType \u003d argumentsTypes.get(i);\n-            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+            ResolvedType originalArgumentType \u003d argumentsTypes.get(i);\n+            ResolvedType updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+            ResolvedType updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "dd5c0a00fb9cbd9995d9141907848ec5a3342760": {
      "type": "Ybodychange",
      "commitMessage": "Make the MethodUsage type param map correct in more cases\n",
      "commitDate": "2017/4/18 上午5:28",
      "commitName": "dd5c0a00fb9cbd9995d9141907848ec5a3342760",
      "commitAuthor": "Max Bolingbroke",
      "commitDateOld": "2017/3/23 上午9:31",
      "commitNameOld": "63c7f0fb4247e490bdd05d2779c6983c892fe570",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 25.83,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 79,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,39 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n+                    methodUsage \u003d resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "acdac6790f4424f8097b3aa6c888e825cac485f9": {
      "type": "Ybodychange",
      "commitMessage": "Fixes for type inference\n",
      "commitDate": "2017/3/10 上午9:22",
      "commitName": "acdac6790f4424f8097b3aa6c888e825cac485f9",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/9 上午11:31",
      "commitNameOld": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthorOld": "xdrop",
      "daysBetweenCommits": 0.91,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n-                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n+                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60": {
      "type": "Ybodychange",
      "commitMessage": "Fix issues with inherited methods in interfaces not being resolved\n",
      "commitDate": "2017/3/9 上午11:31",
      "commitName": "17ac5ada0476c72aa79a2e0c39311e90bfa0fe60",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/3/9 上午5:40",
      "commitNameOld": "e5fe2b597be66d230f8824277c1d4167fa2bb609",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         Expression scope \u003d wrappedNode.getScope().get();\n         if (scope instanceof NameExpr) {\n             String className \u003d ((NameExpr) scope).getName().getId();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n-                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver, false);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "065875981b4d1ffa4bf3535d7c89319a4a3345f1": {
      "type": "Ybodychange",
      "commitMessage": "Update for JavaParser 3.0.0\n",
      "commitDate": "2017/1/12 上午8:45",
      "commitName": "065875981b4d1ffa4bf3535d7c89319a4a3345f1",
      "commitAuthor": "xdrop",
      "commitDateOld": "2017/1/6 下午5:11",
      "commitNameOld": "860a4c0c034e1b8232e3d1ec17e7f11879850470",
      "commitAuthorOld": "",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        Expression scope \u003d wrappedNode.getScope().get();\n        if (scope instanceof NameExpr) {\n            String className \u003d ((NameExpr) scope).getName().getId();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 75,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope() !\u003d null) {\n-        if (wrappedNode.getScope() instanceof NameExpr) {\n-            String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n+    if (wrappedNode.getScope().isPresent()) {\n+        Expression scope \u003d wrappedNode.getScope().get();\n+        if (scope instanceof NameExpr) {\n+            String className \u003d ((NameExpr) scope).getName().getId();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(scope);\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6e1380f412d334f1c887d15edf0b4610c3cf0da2": {
      "type": "Ybodychange",
      "commitMessage": "adapt to alpha.10\n",
      "commitDate": "2016/11/22 上午2:58",
      "commitName": "6e1380f412d334f1c887d15edf0b4610c3cf0da2",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/10 上午1:15",
      "commitNameOld": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 12.07,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         if (wrappedNode.getScope() instanceof NameExpr) {\n-            String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n+            String className \u003d ((NameExpr) wrappedNode.getScope()).getName().getId();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5": {
      "type": "Ybodychange",
      "commitMessage": "changes necessary to support jpalpha8\n",
      "commitDate": "2016/11/10 上午1:15",
      "commitName": "ca3e3a946698cf3a4f93e6fb7b4d2b16ee2e3ed5",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/6 下午9:49",
      "commitNameOld": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.14,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        if (wrappedNode.getScope() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope().isPresent()) {\n-        if (wrappedNode.getScope().get() instanceof NameExpr) {\n-            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n+    if (wrappedNode.getScope() !\u003d null) {\n+        if (wrappedNode.getScope() instanceof NameExpr) {\n+            String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n-        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "03055f925053b3970b9d14cce3a3b9a0d002366d": {
      "type": "Ybodychange",
      "commitMessage": "add AbstractMethodLikeDeclarationContext\n",
      "commitDate": "2016/11/6 下午9:49",
      "commitName": "03055f925053b3970b9d14cce3a3b9a0d002366d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/6 下午4:57",
      "commitNameOld": "27f0f20ee38a85d0d7a476f9a49d15325d4d660e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 66,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "a1c7c58143a592965f8378767adc69709e4c0043": {
      "type": "Ybodychange",
      "commitMessage": "more refactoring for ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:22",
      "commitName": "a1c7c58143a592965f8378767adc69709e4c0043",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/5 下午11:08",
      "commitNameOld": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 256,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         if (wrappedNode.getScope().get() instanceof NameExpr) {\n             String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6df1aa26f75ff0d716a1290007e2b63cc05001ae": {
      "type": "Ybodychange",
      "commitMessage": "creating ReferenceTypeDeclaration\n",
      "commitDate": "2016/11/5 下午11:08",
      "commitName": "6df1aa26f75ff0d716a1290007e2b63cc05001ae",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/11/3 上午4:08",
      "commitNameOld": "effd4c172ad6e4d60d68a749121a0960040edd63",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 2.79,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 256,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         if (wrappedNode.getScope().get() instanceof NameExpr) {\n             String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+            SymbolReference\u003cReferenceTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type originalArgumentType \u003d argumentsTypes.get(i);\n             Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n             Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n             argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d017fb8caf6ccb3343da0062eb2c85262712772c": {
      "type": "Ybodychange",
      "commitMessage": "avoid issue with recursive generic type replacement\n",
      "commitDate": "2016/10/28 上午1:31",
      "commitName": "d017fb8caf6ccb3343da0062eb2c85262712772c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/27 下午1:53",
      "commitNameOld": "901bca148f3256e176bd7c22b159917b6926b5b7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.48,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type originalArgumentType \u003d argumentsTypes.get(i);\n            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n            argumentsTypes.set(i, updatedArgumentType);\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 259,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         if (wrappedNode.getScope().get() instanceof NameExpr) {\n             String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n         Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+            Type originalArgumentType \u003d argumentsTypes.get(i);\n+            Type updatedArgumentType \u003d usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);\n+            argumentsTypes.set(i, updatedArgumentType);\n         }\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n+            Type updatedArgumentType \u003d applyInferredTypes(argumentsTypes.get(i), inferredTypes);\n+            argumentsTypes.set(i, updatedArgumentType);\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2082034e8c3eb434e3df25dd420c98cae5a6d518": {
      "type": "Ybodychange",
      "commitMessage": "type inference\n",
      "commitDate": "2016/10/25 上午1:19",
      "commitName": "2082034e8c3eb434e3df25dd420c98cae5a6d518",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/24 上午2:00",
      "commitNameOld": "cf0045ad73d15502e16c6de02334d39383dfee78",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n        }\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 264,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,34 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n         if (wrappedNode.getScope().get() instanceof NameExpr) {\n             String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n             SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n             if (ref.isSolved()) {\n                 SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                 if (m.isSolved()) {\n                     MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                     methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                     return Optional.of(methodUsage);\n                 } else {\n                     throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n             }\n         }\n         Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+        Map\u003cTypeParameterDeclaration, Type\u003e inferredTypes \u003d new HashMap\u003c\u003e();\n         for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i), inferredTypes));\n+        }\n+        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+            argumentsTypes.set(i, applyInferredTypes(argumentsTypes.get(i), inferredTypes));\n         }\n         return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "13d789de30e6c3d29efb17a2acdff443f8c48db1": {
      "type": "Ybodychange",
      "commitMessage": "handling static calls\n",
      "commitDate": "2016/10/23 下午4:58",
      "commitName": "13d789de30e6c3d29efb17a2acdff443f8c48db1",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/23 上午12:40",
      "commitNameOld": "b26a4c591ec4cf8e25847b987610c65a22f60589",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        if (wrappedNode.getScope().get() instanceof NameExpr) {\n            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n            if (ref.isSolved()) {\n                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                if (m.isSolved()) {\n                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                    return Optional.of(methodUsage);\n                } else {\n                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                }\n            }\n        }\n        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n        }\n        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 189,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,30 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope().isPresent()) {\n-        try {\n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n-            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n-                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n-            }\n-            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n-        } catch (UnsolvedSymbolException e) {\n-            if (wrappedNode.getScope().get() instanceof NameExpr) {\n-                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n-                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n-                if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n-                    if (m.isSolved()) {\n-                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n-                        return Optional.of(methodUsage);\n-                    } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n-                    }\n+        if (wrappedNode.getScope().get() instanceof NameExpr) {\n+            String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n+            SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+            if (ref.isSolved()) {\n+                SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n+                if (m.isSolved()) {\n+                    MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n+                    methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n+                    return Optional.of(methodUsage);\n                 } else {\n-                    throw e;\n+                    throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                 }\n-            } else {\n-                throw e;\n             }\n         }\n+        Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n+        for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+            argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n+        }\n+        return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9c53c2cbc607ea694438ade8630be0c155a33162": {
      "type": "Yfilerename",
      "commitMessage": "renamed packages to com.github.javapaerser\n",
      "commitDate": "2016/10/20 下午2:39",
      "commitName": "9c53c2cbc607ea694438ade8630be0c155a33162",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 下午2:32",
      "commitNameOld": "b1da215b407e8cfc2c77182f0ab3e67e0ab16ef3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 189,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "03e407957d600a18ef0a4a83224c17d155ef8645": {
      "type": "Ybodychange",
      "commitMessage": "fixing a few more tests\n",
      "commitDate": "2016/10/20 上午1:34",
      "commitName": "03e407957d600a18ef0a4a83224c17d155ef8645",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/20 上午1:33",
      "commitNameOld": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope().isPresent()) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 191,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n-    if (wrappedNode.getScope() !\u003d null) {\n+    if (wrappedNode.getScope().isPresent()) {\n         try {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope().get() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "341e081a5f8909a3a467671befcca2941b786d3d": {
      "type": "Ybodychange",
      "commitMessage": "issue91: solve compilation issues\n",
      "commitDate": "2016/10/20 上午1:33",
      "commitName": "341e081a5f8909a3a467671befcca2941b786d3d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/19 下午11:04",
      "commitNameOld": "683012de2a3a28358e848f8b145d462eb8b322ba",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope().get() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 191,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n-            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope().get());\n             for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                 argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n-            if (wrappedNode.getScope() instanceof NameExpr) {\n-                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n+            if (wrappedNode.getScope().get() instanceof NameExpr) {\n+                String className \u003d ((NameExpr) wrappedNode.getScope().get()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
      "commitDate": "2016/10/18 上午1:25",
      "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:48",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 175,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,37 +1,37 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n-                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n             }\n-            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n-        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, argumentsTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "issue90: using the right terminology for parameters and arguments\n",
          "commitDate": "2016/10/18 上午1:25",
          "commitName": "88db8b2a8b93bcc692cb8fd5085ba68b8bcf1968",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/17 上午12:48",
          "commitNameOld": "f271890077d290431fd7cdc45e3bf172fb2f834c",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 1.03,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 175,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,37 +1,37 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e argumentsTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n-                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+            for (int i \u003d 0; i \u003c argumentsTypes.size(); i++) {\n+                argumentsTypes.set(i, usingParameterTypesFromScope(typeOfScope, argumentsTypes.get(i)));\n             }\n-            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n+            return solveMethodAsUsage(typeOfScope, name, argumentsTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n-                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, argumentsTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + argumentsTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n-        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+        return parentContext.solveMethodAsUsage(name, argumentsTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "656bb37a1dba87d61d24e69f2346f35dbc73d81d": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeDeclaration.solveMethod\n",
      "commitDate": "2016/10/17 上午12:13",
      "commitName": "656bb37a1dba87d61d24e69f2346f35dbc73d81d",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/15 上午4:57",
      "commitNameOld": "051dbd94c17c4f142d3fe9e8fbd03c29d09ace54",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 183,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                 parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8d234965b572759181da7787fead07b225e9e5ca": {
      "type": "Ybodychange",
      "commitMessage": "remove TypeSolver from MethodUsage\n",
      "commitDate": "2016/10/14 下午2:36",
      "commitName": "8d234965b572759181da7787fead07b225e9e5ca",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/14 下午2:19",
      "commitNameOld": "6b50c90daa764492e074198460c807d83d52325e",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 182,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                 parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n-                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration());\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "82eb44707b620803d424188a1eb8708fcaf093cb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "rename TypeUsage into Type\n",
      "commitDate": "2016/10/14 上午4:11",
      "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
      "commitAuthor": "Federico Tomassetti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 上午5:43",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 181,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,37 +1,37 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                 parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[name-String, parameterTypes-List\u003cTypeUsage\u003e, typeSolver-TypeSolver]",
            "newValue": "[name-String, parameterTypes-List\u003cType\u003e, typeSolver-TypeSolver]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "rename TypeUsage into Type\n",
          "commitDate": "2016/10/14 上午4:11",
          "commitName": "82eb44707b620803d424188a1eb8708fcaf093cb",
          "commitAuthor": "Federico Tomassetti",
          "commitDateOld": "2016/10/13 上午5:43",
          "commitNameOld": "401a56f412ca186a00a2282d9088e8cb7b67e0e5",
          "commitAuthorOld": "Federico Tomassetti",
          "daysBetweenCommits": 0.94,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
          "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
          "functionStartLine": 181,
          "functionName": "solveMethodAsUsage",
          "functionAnnotation": "@Override",
          "functionDoc": "",
          "diff": "@@ -1,37 +1,37 @@\n @Override\n-public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cType\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n-            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            Type typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                 parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n             }\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        }
      ]
    },
    "38d780df85a22c9baffb1f772a45b063cad73aab": {
      "type": "Ybodychange",
      "commitMessage": "issue80: replace type parameters in parameters using values from scope\n",
      "commitDate": "2016/10/13 上午4:53",
      "commitName": "38d780df85a22c9baffb1f772a45b063cad73aab",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2016/10/12 上午1:37",
      "commitNameOld": "acf74024c2d341bf4009af7173c9b1b972f19c32",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n            }\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 180,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,34 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n+                parameterTypes.set(i, usingParameterTypesFromScope(typeOfScope, parameterTypes.get(i)));\n+            }\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         Context parentContext \u003d getParent();\n         while (parentContext instanceof MethodCallExprContext) {\n             parentContext \u003d parentContext.getParent();\n         }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76": {
      "type": "Ybodychange",
      "commitMessage": "fixed StackOverflowError when solving call on method return type as described in issue #43 and implemented test for this case.\n",
      "commitDate": "2016/9/27 上午1:15",
      "commitName": "d36b028172c0a183a0f32f66d2c5dff6f4b1dd76",
      "commitAuthor": "malte_langkabel",
      "commitDateOld": "2016/9/23 下午6:10",
      "commitNameOld": "2c3f615e6b24358b86d6453e24dac35849ffde26",
      "commitAuthorOld": "malte_langkabel",
      "daysBetweenCommits": 3.29,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        Context parentContext \u003d getParent();\n        while (parentContext instanceof MethodCallExprContext) {\n            parentContext \u003d parentContext.getParent();\n        }\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 154,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,37 +1,34 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n                         MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                         methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                         return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n-        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n-            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n-            if (parent.getScope() \u003d\u003d wrappedNode) {\n-                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n-            }\n-        }\n         Context parentContext \u003d getParent();\n+        while (parentContext instanceof MethodCallExprContext) {\n+            parentContext \u003d parentContext.getParent();\n+        }\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e655d386a595ea1927ebeded58939d7b8a7ce0c": {
      "type": "Yfilerename",
      "commitMessage": "test JavaParserClassDeclaration\n",
      "commitDate": "2015/11/22 下午6:45",
      "commitName": "8e655d386a595ea1927ebeded58939d7b8a7ce0c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/22 下午6:03",
      "commitNameOld": "68d87977d826a8c48711297732b7ae10f3dc1f1f",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java",
      "functionStartLine": 149,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java"
      }
    },
    "ead147279ca0b84d2f479a714943b20cd689e7c7": {
      "type": "Ybodychange",
      "commitMessage": "issue7: consider type parameters and varargs combinations\n",
      "commitDate": "2015/11/21 上午12:04",
      "commitName": "ead147279ca0b84d2f479a714943b20cd689e7c7",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午9:55",
      "commitNameOld": "5aca9bfacfba18bfd16d17b16c8e5ef5c7609af4",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 7.09,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n                        return Optional.of(methodUsage);\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 139,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,37 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n-                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                        MethodUsage methodUsage \u003d new MethodUsage(m.getCorrespondingDeclaration(), typeSolver);\n+                        methodUsage \u003d resolveMethodTypeParameters(methodUsage, parameterTypes);\n+                        return Optional.of(methodUsage);\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f4b07b1a2deac6d1b562424ac2380b92cec77a90": {
      "type": "Yfilerename",
      "commitMessage": "modules: organization in modules\n",
      "commitDate": "2015/11/13 下午5:12",
      "commitName": "f4b07b1a2deac6d1b562424ac2380b92cec77a90",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/13 下午4:53",
      "commitNameOld": "d96a8ff67d857a2988488f1fc31202f0e2ed8061",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 79,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "java-symbol-solver-core/src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "e21fca16e413a8bf31d613aa97a744d075c374dd": {
      "type": "Ybodychange",
      "commitMessage": "add AbstractTypeDeclaration\n",
      "commitDate": "2015/11/3 上午4:11",
      "commitName": "e21fca16e413a8bf31d613aa97a744d075c374dd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/11/1 下午10:57",
      "commitNameOld": "965ab8585c3e8be1dff784e749e37dad31151ec8",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.22,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 80,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0e81f51c40996b42cb262dc2397126cee8f60965": {
      "type": "Ybodychange",
      "commitMessage": "embedding TypeSolver\n",
      "commitDate": "2015/10/31 上午6:37",
      "commitName": "0e81f51c40996b42cb262dc2397126cee8f60965",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午9:30",
      "commitNameOld": "362cdf49fd4c7ea6d60f3172fd2804f8aa765f4c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.38,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 77,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,35 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+            return solveMethodAsUsage(typeOfScope, name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b36f33050149a62a5b3c8c7451ae93f736715029": {
      "type": "Yfilerename",
      "commitMessage": "reorganize packages\n",
      "commitDate": "2015/10/30 下午5:53",
      "commitName": "b36f33050149a62a5b3c8c7451ae93f736715029",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/10/30 下午5:29",
      "commitNameOld": "90999800bdc73eacb5ef25dafcd36c8518af3072",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {
        "oldPath": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
        "newPath": "src/main/java/me/tomassetti/symbolsolver/resolution/javaparser/contexts/MethodCallExprContext.java"
      }
    },
    "640eb2479a4e05bb8ee0d95f74172be9dfa283f6": {
      "type": "Ybodychange",
      "commitMessage": "remove noise\n",
      "commitDate": "2015/8/25 上午5:05",
      "commitName": "640eb2479a4e05bb8ee0d95f74172be9dfa283f6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午4:42",
      "commitNameOld": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,35 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n-    if (name.equals(\"cloneNodes\")) {\n-        System.out.println(\"FOO\");\n-    }\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f821be8dfe72fcd3f4e14f75420617b87ddb8689": {
      "type": "Ybodychange",
      "commitMessage": "considering method type parameters\n",
      "commitDate": "2015/8/25 上午4:42",
      "commitName": "f821be8dfe72fcd3f4e14f75420617b87ddb8689",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午3:37",
      "commitNameOld": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (name.equals(\"cloneNodes\")) {\n        System.out.println(\"FOO\");\n    }\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    if (name.equals(\"cloneNodes\")) {\n+        System.out.println(\"FOO\");\n+    }\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n-                    if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n-                        System.out.println(\"FOO\");\n-                    }\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1ae290f6f5e0c7ba62eab797aba22308957b9257": {
      "type": "Ybodychange",
      "commitMessage": "consider method values of Enum\n",
      "commitDate": "2015/8/25 上午3:37",
      "commitName": "1ae290f6f5e0c7ba62eab797aba22308957b9257",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午2:56",
      "commitNameOld": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n                        System.out.println(\"FOO\");\n                    }\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,38 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n                         System.out.println(\"FOO\");\n                     }\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n-                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \u0027\" + name + \"\u0027 with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30": {
      "type": "Ybodychange",
      "commitMessage": "improving how the parent context is determined\n",
      "commitDate": "2015/8/25 上午2:56",
      "commitName": "c08a0391fd27b2ecc75a264cce9eb4606d0f7b30",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/25 上午2:45",
      "commitNameOld": "d0348de241a6cf6be9c51500870ee1fb26172101",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n                        System.out.println(\"FOO\");\n                    }\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,35 +1,38 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n+                    if (name.equals(\"getModifiers\") \u0026\u0026 !ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver).isSolved()) {\n+                        System.out.println(\"FOO\");\n+                    }\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     } else {\n                         throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                     }\n                 } else {\n                     throw e;\n                 }\n             } else {\n                 throw e;\n             }\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6a15cd55028fc9b7c73158d05f5ee335cab1f481": {
      "type": "Ybodychange",
      "commitMessage": "add test on switch on enum value\n",
      "commitDate": "2015/8/25 上午12:29",
      "commitName": "6a15cd55028fc9b7c73158d05f5ee335cab1f481",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午6:34",
      "commitNameOld": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 1.25,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    } else {\n                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                    }\n                } else {\n                    throw e;\n                }\n            } else {\n                throw e;\n            }\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,30 +1,35 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                    } else {\n+                        throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), \"Method \" + name + \" with parameterTypes \" + parameterTypes);\n                     }\n+                } else {\n+                    throw e;\n                 }\n+            } else {\n+                throw e;\n             }\n-            throw e;\n         }\n     } else {\n         if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n             MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n             if (parent.getScope() \u003d\u003d wrappedNode) {\n                 return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n             }\n         }\n         Context parentContext \u003d getParent();\n         return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "46aefdd68f2f2597a19b72da36681123cb3090e6": {
      "type": "Ybodychange",
      "commitMessage": "improve resolution of calls to static methods\n",
      "commitDate": "2015/8/23 下午6:34",
      "commitName": "46aefdd68f2f2597a19b72da36681123cb3090e6",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午5:38",
      "commitNameOld": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n            if (parent.getScope() \u003d\u003d wrappedNode) {\n                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n            }\n        }\n        Context parentContext \u003d getParent();\n        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,23 +1,30 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     }\n                 }\n             }\n             throw e;\n         }\n     } else {\n-        return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+        if (wrappedNode.getParentNode() instanceof MethodCallExpr) {\n+            MethodCallExpr parent \u003d (MethodCallExpr) wrappedNode.getParentNode();\n+            if (parent.getScope() \u003d\u003d wrappedNode) {\n+                return getParent().getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n+            }\n+        }\n+        Context parentContext \u003d getParent();\n+        return parentContext.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6c297529e31036058837adbaa57cee652d4cc918": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午5:38",
      "commitName": "6c297529e31036058837adbaa57cee652d4cc918",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午4:24",
      "commitNameOld": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,24 +1,23 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         try {\n             TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n             return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n         } catch (UnsolvedSymbolException e) {\n             if (wrappedNode.getScope() instanceof NameExpr) {\n                 String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                 SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                 if (ref.isSolved()) {\n                     SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                     if (m.isSolved()) {\n                         return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                     }\n                 }\n             }\n             throw e;\n         }\n     } else {\n-        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n-        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+        return getParent().solveMethodAsUsage(name, parameterTypes, typeSolver);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "7b2a0b366461674aa6320b11a38a17909d8a74a3": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午4:24",
      "commitName": "7b2a0b366461674aa6320b11a38a17909d8a74a3",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/23 下午3:50",
      "commitNameOld": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        try {\n            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n        } catch (UnsolvedSymbolException e) {\n            if (wrappedNode.getScope() instanceof NameExpr) {\n                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n                if (ref.isSolved()) {\n                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n                    if (m.isSolved()) {\n                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n                    }\n                }\n            }\n            throw e;\n        }\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 37,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,10 +1,24 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+        try {\n+            TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n+            return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n+        } catch (UnsolvedSymbolException e) {\n+            if (wrappedNode.getScope() instanceof NameExpr) {\n+                String className \u003d ((NameExpr) wrappedNode.getScope()).getName();\n+                SymbolReference\u003cTypeDeclaration\u003e ref \u003d solveType(className, typeSolver);\n+                if (ref.isSolved()) {\n+                    SymbolReference\u003cMethodDeclaration\u003e m \u003d ref.getCorrespondingDeclaration().solveMethod(name, parameterTypes, typeSolver);\n+                    if (m.isSolved()) {\n+                        return Optional.of(new MethodUsage(m.getCorrespondingDeclaration(), typeSolver));\n+                    }\n+                }\n+            }\n+            throw e;\n+        }\n     } else {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n         return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/23 下午3:50",
      "commitName": "be64d2e61b56eafd01abc7236a7a0dcd6ce6dafd",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/19 下午5:58",
      "commitNameOld": "c1e95efcb4b0a373530aa107edb2164bf6c21ac7",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 35,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "",
      "extendedDetails": {}
    },
    "850c0caa4c64df32d5fc44a5512d6d41f4534a08": {
      "type": "Ybodychange",
      "commitMessage": "wip\n",
      "commitDate": "2015/8/18 上午12:43",
      "commitName": "850c0caa4c64df32d5fc44a5512d6d41f4534a08",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/18 上午12:43",
      "commitNameOld": "d393205e2ee874242b73e4fe819d1bc874587d8a",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 35,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,10 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n     } else {\n-        throw new UnsupportedOperationException();\n+        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);\n+        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731": {
      "type": "Ybodychange",
      "commitMessage": "playing with passing the invokation context\n",
      "commitDate": "2015/8/14 下午11:16",
      "commitName": "df3e1a46a12fcc1ecafc00e59e7b7481c28ce731",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/5 下午10:25",
      "commitNameOld": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 9.04,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n         TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n-        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver, this);\n     } else {\n         throw new UnsupportedOperationException();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "627b56302d259409e9bc50b20d77803484f18b5c": {
      "type": "Ybodychange",
      "commitMessage": "introduce cache in JavaParserFacade\n",
      "commitDate": "2015/8/5 下午10:25",
      "commitName": "627b56302d259409e9bc50b20d77803484f18b5c",
      "commitAuthor": "Federico Tomassetti",
      "commitDateOld": "2015/8/5 下午9:30",
      "commitNameOld": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthorOld": "Federico Tomassetti",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": "",
      "diff": "@@ -1,9 +1,9 @@\n @Override\n public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n     if (wrappedNode.getScope() !\u003d null) {\n-        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+        TypeUsage typeOfScope \u003d JavaParserFacade.get(typeSolver).getType(wrappedNode.getScope());\n         return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n     } else {\n         throw new UnsupportedOperationException();\n     }\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fd2e083224d3ee0e9ccca4431d63a84601e0d606": {
      "type": "Yintroduced",
      "commitMessage": "fix resolveReferenceToMethodWithLambda\n",
      "commitDate": "2015/8/5 下午9:30",
      "commitName": "fd2e083224d3ee0e9ccca4431d63a84601e0d606",
      "commitAuthor": "Federico Tomassetti",
      "diff": "@@ -0,0 +1,9 @@\n+@Override\n+public Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n+    if (wrappedNode.getScope() !\u003d null) {\n+        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n+        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n+    } else {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n\\ No newline at end of file\n",
      "actualSource": "@Override\npublic Optional\u003cMethodUsage\u003e solveMethodAsUsage(String name, List\u003cTypeUsage\u003e parameterTypes, TypeSolver typeSolver) {\n    if (wrappedNode.getScope() !\u003d null) {\n        TypeUsage typeOfScope \u003d new JavaParserFacade(typeSolver).getType(wrappedNode.getScope());\n        return typeOfScope.solveMethodAsUsage(name, parameterTypes, typeSolver);\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}",
      "path": "src/main/java/me/tomassetti/symbolsolver/model/javaparser/contexts/MethodCallExprContext.java",
      "functionStartLine": 26,
      "functionName": "solveMethodAsUsage",
      "functionAnnotation": "@Override",
      "functionDoc": ""
    }
  }
}