{
  "origin": "codeshovel",
  "repositoryName": "spring-framework",
  "repositoryPath": "/Users/franky/Documents/Homework/毕业设计/testcase/spring-framework/.git",
  "startCommitName": "b325c74216fd9564a36602158fa1269e2e832874",
  "sourceFileName": "TypeConverterDelegate.java",
  "functionName": "convertIfNecessary",
  "functionId": "convertIfNecessary___propertyName-String(annotations-@Nullable)__oldValue-Object(annotations-@Nullable)__newValue-Object(annotations-@Nullable)__requiredType-Class__T__(annotations-@Nullable)__typeDescriptor-TypeDescriptor(annotations-@Nullable)",
  "sourceFilePath": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
  "functionAnnotation": "@SuppressWarnings(\"unchecked\"),@Nullable",
  "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
  "functionStartLine": 152,
  "functionEndLine": 313,
  "numCommitsSeen": 88,
  "timeTaken": 4912,
  "changeHistory": [
    "f813712f5b413b354560cd7cc006352e9defa9a3",
    "1f28825f9da63a13aaf8940aadedcf81358dc506",
    "87598f48e41d483745aba56cbf4e998c6f6d680c",
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
    "c4c941c43fc23f58503c7b687fd1469d4a27c777",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
    "02da2e85ee0e58202b90d11c126e6050abe184b4",
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
    "0dc6082b01606c3c996b728541467ba5104b747f",
    "59002f245623d758765b72d598cd78c326c6f5fa",
    "c9aace4da215330c1aa552fa1dcdd79748249774",
    "9540d2c81b93b9062faf79d4df998525f3dedb7c",
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
    "6bce09831060430b00e6ed93785c7d40ac8529a8",
    "8e754e9065b5703f93909f480933488a2b180429",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
    "86bef9030fa4e026107db74cd9eef288beb1beca",
    "84be348cb0ac99896674170dc9f99021b43ba9ee",
    "f288060ad8f0d007f1541213130d006729b9ec40",
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
    "8c6890605a7080e2744be3f3994757cc72e394b0",
    "2127b160512911e5f65a4e304f0b57826710a91d",
    "c306afed63e439ee133872a49380d76064bd2638",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820",
    "6f146737f475828b6d765784017773378c2c4922",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
    "dc99df297274d8c1291cdaed5d9dd508910584d3",
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
    "5f9b4443194d3aa3948d76956897c0a1d918d546",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94",
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
    "45c542e51e9b01526a97a1644aebfe1e94a2342f",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
    "a86a698e5b3394c9b6721a784c8fe251611ff16b",
    "9a48f3f3a896cad821e5847a93d91c997905e325",
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
    "fee838a65e87f5da4b65b04ea5101681d6308104",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
    "0297116542a3ce33d19a6a81b8240097081376c5",
    "bf7a947559d8f9918cc738780bf04caf8ea46962",
    "29657105da133995b0b2277b82c75d1df2931b64",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3"
  ],
  "changeHistoryShort": {
    "f813712f5b413b354560cd7cc006352e9defa9a3": "Ymultichange(Ybodychange,Yparametermetachange,Yannotationchange)",
    "1f28825f9da63a13aaf8940aadedcf81358dc506": "Yparametermetachange",
    "87598f48e41d483745aba56cbf4e998c6f6d680c": "Yparametermetachange",
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea": "Ybodychange",
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37": "Ybodychange",
    "c4c941c43fc23f58503c7b687fd1469d4a27c777": "Ybodychange",
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": "Ybodychange",
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572": "Ybodychange",
    "02da2e85ee0e58202b90d11c126e6050abe184b4": "Ybodychange",
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3": "Ybodychange",
    "0dc6082b01606c3c996b728541467ba5104b747f": "Ybodychange",
    "59002f245623d758765b72d598cd78c326c6f5fa": "Ybodychange",
    "c9aace4da215330c1aa552fa1dcdd79748249774": "Ybodychange",
    "9540d2c81b93b9062faf79d4df998525f3dedb7c": "Ydocchange",
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec": "Ybodychange",
    "6bce09831060430b00e6ed93785c7d40ac8529a8": "Ybodychange",
    "8e754e9065b5703f93909f480933488a2b180429": "Ybodychange",
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": "Yfilerename",
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79": "Ybodychange",
    "86bef9030fa4e026107db74cd9eef288beb1beca": "Ybodychange",
    "84be348cb0ac99896674170dc9f99021b43ba9ee": "Ybodychange",
    "f288060ad8f0d007f1541213130d006729b9ec40": "Ybodychange",
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75": "Ybodychange",
    "8c6890605a7080e2744be3f3994757cc72e394b0": "Ybodychange",
    "2127b160512911e5f65a4e304f0b57826710a91d": "Ybodychange",
    "c306afed63e439ee133872a49380d76064bd2638": "Ybodychange",
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": "Ybodychange",
    "6f146737f475828b6d765784017773378c2c4922": "Ybodychange",
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": "Ybodychange",
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": "Ymodifierchange",
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f": "Ybodychange",
    "dc99df297274d8c1291cdaed5d9dd508910584d3": "Ybodychange",
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde": "Ybodychange",
    "5f9b4443194d3aa3948d76956897c0a1d918d546": "Ybodychange",
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f": "Ybodychange",
    "45c542e51e9b01526a97a1644aebfe1e94a2342f": "Ybodychange",
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": "Ybodychange",
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7": "Ybodychange",
    "a86a698e5b3394c9b6721a784c8fe251611ff16b": "Ybodychange",
    "9a48f3f3a896cad821e5847a93d91c997905e325": "Ybodychange",
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f": "Ybodychange",
    "fee838a65e87f5da4b65b04ea5101681d6308104": "Ybodychange",
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": "Ybodychange",
    "0297116542a3ce33d19a6a81b8240097081376c5": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yannotationchange)",
    "bf7a947559d8f9918cc738780bf04caf8ea46962": "Ybodychange",
    "29657105da133995b0b2277b82c75d1df2931b64": "Ybodychange",
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": "Ybodychange",
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f813712f5b413b354560cd7cc006352e9defa9a3": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange,Yannotationchange)",
      "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/7 下午8:19",
      "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/7 下午8:19",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/1 上午3:42",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\n@Nullable\npublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 151,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\"),@Nullable",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,116 +1,117 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+@Nullable\n+public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n-            } else if (conversionService !\u003d null) {\n+            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/7 下午8:19",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/1 上午3:42",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\n@Nullable\npublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 151,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\"),@Nullable",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,116 +1,117 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+@Nullable\n+public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n-            } else if (conversionService !\u003d null) {\n+            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
            "newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object(annotations-@Nullable), requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor(annotations-@Nullable)]"
          }
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "Consistent use of @Nullable across the codebase (even for internals)\n\nBeyond just formally declaring the current behavior, this revision actually enforces non-null behavior in selected signatures now, not tolerating null values anymore when not explicitly documented. It also changes some utility methods with historic null-in/null-out tolerance towards enforced non-null return values, making them a proper citizen in non-null assignments.\n\nSome issues are left as to-do: in particular a thorough revision of spring-test, and a few tests with unclear failures (ignored as \"TODO: NULLABLE\") to be sorted out in a follow-up commit.\n\nIssue: SPR-15540\n",
          "commitDate": "2017/6/7 下午8:19",
          "commitName": "f813712f5b413b354560cd7cc006352e9defa9a3",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2017/6/1 上午3:42",
          "commitNameOld": "1f28825f9da63a13aaf8940aadedcf81358dc506",
          "commitAuthorOld": "Sebastien Deleuze",
          "daysBetweenCommits": 6.69,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\n@Nullable\npublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
          "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 151,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\"),@Nullable",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,116 +1,117 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+@Nullable\n+public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class\u003cT\u003e requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n-            } else if (conversionService !\u003d null) {\n+            } else if (conversionService !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "@SuppressWarnings(\"unchecked\")",
            "newValue": "@SuppressWarnings(\"unchecked\"),@Nullable"
          }
        }
      ]
    },
    "1f28825f9da63a13aaf8940aadedcf81358dc506": {
      "type": "Yparametermetachange",
      "commitMessage": "Add more @Nullable parameters based on null usage\n\nIssue: SPR-15540\n",
      "commitDate": "2017/6/1 上午3:42",
      "commitName": "1f28825f9da63a13aaf8940aadedcf81358dc506",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2017/5/27 下午2:57",
      "commitNameOld": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthorOld": "Sebastien Deleuze",
      "daysBetweenCommits": 4.53,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 148,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,116 +1,116 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+public \u003cT\u003e T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]",
        "newValue": "[propertyName-String(annotations-@Nullable), oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
      }
    },
    "87598f48e41d483745aba56cbf4e998c6f6d680c": {
      "type": "Yparametermetachange",
      "commitMessage": "Introduce null-safety of Spring Framework API\n\nThis commit introduces 2 new @Nullable and @NonNullApi\nannotations that leverage JSR 305 (dormant but available via\nFindbugs jsr305 dependency and already used by libraries\nlike OkHttp) meta-annotations to specify explicitly\nnull-safety of Spring Framework parameters and return values.\n\nIn order to avoid adding too much annotations, the\ndefault is set at package level with @NonNullApi and\n@Nullable annotations are added when needed at parameter or\nreturn value level. These annotations are intended to be used\non Spring Framework itself but also by other Spring projects.\n\n@Nullable annotations have been introduced based on Javadoc\nand search of patterns like \"return null;\". It is expected that\nnullability of Spring Framework API will be polished with\ncomplementary commits.\n\nIn practice, this will make the whole Spring Framework API\nnull-safe for Kotlin projects (when KT-10942 will be fixed)\nsince Kotlin will be able to leverage these annotations to\nknow if a parameter or a return value is nullable or not. But\nthis is also useful for Java developers as well since IntelliJ\nIDEA, for example, also understands these annotations to\ngenerate warnings when unsafe nullable usages are detected.\n\nIssue: SPR-15540\n",
      "commitDate": "2017/5/27 下午2:57",
      "commitName": "87598f48e41d483745aba56cbf4e998c6f6d680c",
      "commitAuthor": "Sebastien Deleuze",
      "commitDateOld": "2016/10/29 上午5:39",
      "commitNameOld": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 210.39,
      "commitsBetweenForRepo": 1205,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 148,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,116 +1,116 @@\n @SuppressWarnings(\"unchecked\")\n-public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+public \u003cT\u003e T convertIfNecessary(String propertyName, @Nullable Object oldValue, Object newValue, @Nullable Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, typeDescriptor-TypeDescriptor]",
        "newValue": "[propertyName-String, oldValue-Object(annotations-@Nullable), newValue-Object, requiredType-Class\u003cT\u003e(annotations-@Nullable), typeDescriptor-TypeDescriptor]"
      }
    },
    "dc080cb1be4c35398d1d995c3bb8025ccfde6dea": {
      "type": "Ybodychange",
      "commitMessage": "Revised NoSuchBeanDefinitionException message and ResolvableType handling\n\nIncludes consistent quoting of qualified type names in related classes.\n\nIssue: SPR-14831\n",
      "commitDate": "2016/10/29 上午5:39",
      "commitName": "dc080cb1be4c35398d1d995c3bb8025ccfde6dea",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/7/20 上午1:21",
      "commitNameOld": "aaac199e8bc1e037883f9fa8063828a82142d608",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 101.18,
      "commitsBetweenForRepo": 522,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 147,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,116 +1,116 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (requiredType \u003d\u003d Optional.class) {\n                 convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n-            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n-            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+            msg.append(\"Cannot convert value of type \u0027\").append(ClassUtils.getDescriptiveType(newValue));\n+            msg.append(\"\u0027 to required type \u0027\").append(ClassUtils.getQualifiedName(requiredType)).append(\"\u0027\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n-                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n+                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type \u0027\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"\u0027\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37": {
      "type": "Ybodychange",
      "commitMessage": "Avoid defensive checks against Java 8 API (java.util.Optional etc)\n\nThis commit also fixes broken javadoc links and code references.\n\nIssue: SPR-13188\n",
      "commitDate": "2016/7/5 上午8:09",
      "commitName": "51252ebbcaa9e65aee83311aec25ca3c7c6d7d37",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2016/6/30 下午8:02",
      "commitNameOld": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (requiredType \u003d\u003d Optional.class) {\n                convertedValue \u003d Optional.empty();\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 146,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,116 +1,116 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementTypeDesc !\u003d null) {\n                 Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                 if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n-            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-                convertedValue \u003d javaUtilOptionalEmpty;\n+            if (requiredType \u003d\u003d Optional.class) {\n+                convertedValue \u003d Optional.empty();\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c4c941c43fc23f58503c7b687fd1469d4a27c777": {
      "type": "Ybodychange",
      "commitMessage": "Convert comma-separated string into list of classes analogous to existing support for class array\n\nIssue: SPR-14415\n",
      "commitDate": "2016/6/30 下午8:02",
      "commitName": "c4c941c43fc23f58503c7b687fd1469d4a27c777",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/8/31 下午11:20",
      "commitNameOld": "d4a23b81e9e49a6e9cc871d8bb1accc70c6444df",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 303.86,
      "commitsBetweenForRepo": 1195,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementTypeDesc !\u003d null) {\n                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue \u003d javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,113 +1,116 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n-            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n-                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+        if (typeDescriptor !\u003d null \u0026\u0026 requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n+            TypeDescriptor elementTypeDesc \u003d typeDescriptor.getElementTypeDescriptor();\n+            if (elementTypeDesc !\u003d null) {\n+                Class\u003c?\u003e elementType \u003d elementTypeDesc.getType();\n+                if (Class.class \u003d\u003d elementType || Enum.class.isAssignableFrom(elementType)) {\n+                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+                }\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                 convertedValue \u003d javaUtilOptionalEmpty;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c": {
      "type": "Ybodychange",
      "commitMessage": "Class identity comparisons wherever possible\n\nIssue: SPR-12926\n",
      "commitDate": "2015/5/20 下午8:34",
      "commitName": "b4095c3e1d61fc7279e6b2ca105ec60c3cd7128c",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/5/19 上午5:53",
      "commitNameOld": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.61,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class \u003d\u003d requiredType) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue \u003d javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,113 +1,113 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n                 return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n                 conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n     Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n-            if (Object.class.equals(requiredType)) {\n+            if (Object.class \u003d\u003d requiredType) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n-            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+            if (String.class \u003d\u003d requiredType \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                 convertedValue \u003d javaUtilOptionalEmpty;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (conversionAttemptEx !\u003d null) {\n                 throw conversionAttemptEx;\n             } else if (conversionService !\u003d null) {\n                 TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                 if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                     return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                 }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (conversionAttemptEx !\u003d null) {\n-        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n+        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 Object.class !\u003d requiredType) {\n             throw conversionAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6418b54f81a9e56242fb78fda4bf95e7b3d4c572": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder tries ConversionService if PropertyEditor could not produce required type\n\nIssue: SPR-13042\n",
      "commitDate": "2015/5/19 上午5:53",
      "commitName": "6418b54f81a9e56242fb78fda4bf95e7b3d4c572",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2015/5/13 上午4:33",
      "commitNameOld": "02da2e85ee0e58202b90d11c126e6050abe184b4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException conversionAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            try {\n                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n            } catch (ConversionFailedException ex) {\n                conversionAttemptEx \u003d ex;\n            }\n        }\n    }\n    Object convertedValue \u003d newValue;\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue \u003d javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (conversionAttemptEx !\u003d null) {\n                throw conversionAttemptEx;\n            } else if (conversionService !\u003d null) {\n                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n                }\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (conversionAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw conversionAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,109 +1,113 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n-    Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n-    ConversionFailedException firstAttemptEx \u003d null;\n+    ConversionFailedException conversionAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n+    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 newValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n-        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n-        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             try {\n-                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+                return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n             } catch (ConversionFailedException ex) {\n-                firstAttemptEx \u003d ex;\n+                conversionAttemptEx \u003d ex;\n             }\n         }\n     }\n+    Object convertedValue \u003d newValue;\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class.equals(requiredType)) {\n                 return (T) convertedValue;\n             } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+                if (conversionAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                 convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                 standardConversion \u003d true;\n             }\n         } else {\n             if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                 convertedValue \u003d javaUtilOptionalEmpty;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-            if (firstAttemptEx !\u003d null) {\n-                throw firstAttemptEx;\n+            if (conversionAttemptEx !\u003d null) {\n+                throw conversionAttemptEx;\n+            } else if (conversionService !\u003d null) {\n+                TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n+                if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);\n+                }\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n-    if (firstAttemptEx !\u003d null) {\n+    if (conversionAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n-            throw firstAttemptEx;\n+            throw conversionAttemptEx;\n         }\n-        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", conversionAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02da2e85ee0e58202b90d11c126e6050abe184b4": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder allows for adding custom Formatters as alternative to PropertyEditors (including per-field formatters)\n\nIncludes a generic FormatterPropertyEditorAdapter plus Number conversion support in TypeConverterDelegate.\n\nIssue: SPR-7773\nIssue: SPR-6069\n",
      "commitDate": "2015/5/13 上午4:33",
      "commitName": "02da2e85ee0e58202b90d11c126e6050abe184b4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/7/18 下午11:21",
      "commitNameOld": "9d6c38bd54fe8931ee73fbb7a076625deb934e28",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 298.22,
      "commitsBetweenForRepo": 1341,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            } else if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue \u003d javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 159,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,107 +1,109 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class.equals(requiredType)) {\n                 return (T) convertedValue;\n-            }\n-            if (requiredType.isArray()) {\n+            } else if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n+            } else if (convertedValue instanceof Number \u0026\u0026 Number.class.isAssignableFrom(requiredType)) {\n+                convertedValue \u003d NumberUtils.convertNumberToTargetClass((Number) convertedValue, (Class\u003cNumber\u003e) requiredType);\n+                standardConversion \u003d true;\n             }\n         } else {\n             if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                 convertedValue \u003d javaUtilOptionalEmpty;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3": {
      "type": "Ybodychange",
      "commitMessage": "Defensively check javaUtilOptionalEmpty\n\nIssue: SPR-11888\n",
      "commitDate": "2014/6/20 上午3:14",
      "commitName": "bc1f19ce18e9ad35d8127048737d6e6e9c276eb3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2014/6/17 上午2:16",
      "commitNameOld": "0dc6082b01606c3c996b728541467ba5104b747f",
      "commitAuthorOld": "Rossen Stoyanchev",
      "daysBetweenCommits": 3.04,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        } else {\n            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n                convertedValue \u003d javaUtilOptionalEmpty;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 158,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,105 +1,107 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class.equals(requiredType)) {\n                 return (T) convertedValue;\n             }\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             }\n-        } else if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n-            convertedValue \u003d javaUtilOptionalEmpty;\n+        } else {\n+            if (javaUtilOptionalEmpty !\u003d null \u0026\u0026 requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+                convertedValue \u003d javaUtilOptionalEmpty;\n+            }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0dc6082b01606c3c996b728541467ba5104b747f": {
      "type": "Ybodychange",
      "commitMessage": "Support java.util.Optional for @MVC named value args\n\nAfter this change, java.util.Optional is supported with @RequestParam,\n@RequestHeader, and @MatrixVariable arguments in Java 8. When Optional\nis used the required flag is effectively ignored.\n\nIssue: SPR-11829\n",
      "commitDate": "2014/6/17 上午2:16",
      "commitName": "0dc6082b01606c3c996b728541467ba5104b747f",
      "commitAuthor": "Rossen Stoyanchev",
      "commitDateOld": "2014/4/28 上午6:47",
      "commitNameOld": "6cb45f714e8d4b6b38501ed6356ced59362d8df2",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 49.81,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        } else if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n            convertedValue \u003d javaUtilOptionalEmpty;\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 157,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,103 +1,105 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class.equals(requiredType)) {\n                 return (T) convertedValue;\n             }\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                         return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             }\n+        } else if (requiredType.equals(javaUtilOptionalEmpty.getClass())) {\n+            convertedValue \u003d javaUtilOptionalEmpty;\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "59002f245623d758765b72d598cd78c326c6f5fa": {
      "type": "Ybodychange",
      "commitMessage": "Fix remaining compiler warnings\n\nFix remaining Java compiler warnings, mainly around missing\ngenerics or deprecated code.\n\nAlso add the `-Werror` compiler option to ensure that any future\nwarnings will fail the build.\n\nIssue: SPR-11064\n",
      "commitDate": "2013/11/26 上午4:52",
      "commitName": "59002f245623d758765b72d598cd78c326c6f5fa",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/10/19 上午8:19",
      "commitNameOld": "c9aace4da215330c1aa552fa1dcdd79748249774",
      "commitAuthorOld": "Phillip Webb",
      "daysBetweenCommits": 37.86,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,103 +1,103 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (Object.class.equals(requiredType)) {\n                 return (T) convertedValue;\n             }\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+                convertedValue \u003d convertToTypedCollection((Collection\u003c?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+                convertedValue \u003d convertToTypedMap((Map\u003c?, ?\u003e) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n-                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n-                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+                        Constructor\u003cT\u003e strCtor \u003d requiredType.getConstructor(String.class);\n+                        return BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c9aace4da215330c1aa552fa1dcdd79748249774": {
      "type": "Ybodychange",
      "commitMessage": "Skip convert to Object from TypeConverterDelegate\n\nUpdate TypeConverterDelegate to bypass conversion when the target type\nis Object.class. Prior to this commit converting a single element array\nto an Object would result in the element being returned, rather than\nthe array itself.\n\nIssue: SPR-10996\n",
      "commitDate": "2013/10/19 上午8:19",
      "commitName": "c9aace4da215330c1aa552fa1dcdd79748249774",
      "commitAuthor": "Phillip Webb",
      "commitDateOld": "2013/5/3 下午5:49",
      "commitNameOld": "61c3f3d9fdf617097f121d26053f0d24ae621f08",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 168.6,
      "commitsBetweenForRepo": 608,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (Object.class.equals(requiredType)) {\n                return (T) convertedValue;\n            }\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,100 +1,103 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n+            if (Object.class.equals(requiredType)) {\n+                return (T) convertedValue;\n+            }\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9540d2c81b93b9062faf79d4df998525f3dedb7c": {
      "type": "Ydocchange",
      "commitMessage": "Replace \u003ccode\u003e with {@code} throughout Javadoc\n\nIssue: SPR-10128\n",
      "commitDate": "2012/12/29 上午5:36",
      "commitName": "9540d2c81b93b9062faf79d4df998525f3dedb7c",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/10/13 上午5:34",
      "commitNameOld": "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 77.0,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "",
      "extendedDetails": {
        "oldValue": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
        "newValue": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be {@code null})\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or {@code null} if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n"
      }
    },
    "ff7dcec5f7d2b54324476bd617af74de9cbd56ec": {
      "type": "Ybodychange",
      "commitMessage": "BeanWrapper does not fall back to String constructor if ConversionService attempt failed before\n\nIssue: SPR-9865\n",
      "commitDate": "2012/10/13 上午5:34",
      "commitName": "ff7dcec5f7d2b54324476bd617af74de9cbd56ec",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/9/5 上午6:59",
      "commitNameOld": "6bce09831060430b00e6ed93785c7d40ac8529a8",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 37.94,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,100 +1,100 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                 standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n                 standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+                if (firstAttemptEx \u003d\u003d null \u0026\u0026 !requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                 standardConversion \u003d true;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n         if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6bce09831060430b00e6ed93785c7d40ac8529a8": {
      "type": "Ybodychange",
      "commitMessage": "refined TypeConverterDelegate\u0027s ConversionService exception handling\n\nIssue: SPR-9498\n",
      "commitDate": "2012/9/5 上午6:59",
      "commitName": "6bce09831060430b00e6ed93785c7d40ac8529a8",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2012/9/5 上午4:36",
      "commitNameOld": "e904589bd1f910b095acdd1fb760a76ab84e8e54",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    boolean standardConversion \u003d false;\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n                standardConversion \u003d true;\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n                standardConversion \u003d true;\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n                standardConversion \u003d true;\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 144,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,95 +1,100 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n-            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n+            editor \u003d findDefaultEditor(requiredType);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n+    boolean standardConversion \u003d false;\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n+                standardConversion \u003d true;\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n+                standardConversion \u003d true;\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n+                standardConversion \u003d true;\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n+                standardConversion \u003d true;\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n-        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+        if (editor \u003d\u003d null \u0026\u0026 !standardConversion \u0026\u0026 requiredType !\u003d null \u0026\u0026 !Object.class.equals(requiredType)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8e754e9065b5703f93909f480933488a2b180429": {
      "type": "Ybodychange",
      "commitMessage": "SPR-9498: don\u0027t make assumptions about equality if ConversionService has failed\n\nThe failure of the conversion service is not fatal, but the check that\nwas in there (line 248) was inadequate to detect the cases that could\nalready be handled by the default property editors.  This code path\nwas also not tested anywhere in spring-beans tests until now.\n",
      "commitDate": "2012/6/14 下午6:40",
      "commitName": "8e754e9065b5703f93909f480933488a2b180429",
      "commitAuthor": "Dave Syer",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 134.88,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,95 +1,95 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n-        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n+        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue \u0026\u0026 requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "02a4473c62d8240837bec297f0a1f3cb67ef8a7b": {
      "type": "Yfilerename",
      "commitMessage": "Rename modules {org.springframework.*\u003d\u003espring-*}\n\nThis renaming more intuitively expresses the relationship between\nsubprojects and the JAR artifacts they produce.\n\nTracking history across these renames is possible, but it requires\nuse of the --follow flag to `git log`, for example\n\n    $ git log spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history up until the renaming event, where\n\n    $ git log --follow spring-aop/src/main/java/org/springframework/aop/Advisor.java\n\nwill show history for all changes to the file, before and after the\nrenaming.\n\nSee http://chrisbeams.com/git-diff-across-renamed-directories\n",
      "commitDate": "2012/1/31 下午9:37",
      "commitName": "02a4473c62d8240837bec297f0a1f3cb67ef8a7b",
      "commitAuthor": "Chris Beams",
      "commitDateOld": "2012/1/31 下午9:37",
      "commitNameOld": "b6cb514d383dcef52ba6c609a863f19e1a4c1faf",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "",
      "extendedDetails": {
        "oldPath": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
        "newPath": "spring-beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java"
      }
    },
    "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79": {
      "type": "Ybodychange",
      "commitMessage": "correctly handle ParseException from Formatter for String-\u003eString case (SPR-8944)\n",
      "commitDate": "2011/12/22 下午11:30",
      "commitName": "d331c5d1c99a2cb6d6932c98b96433e6f9c62c79",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/12/22 下午10:54",
      "commitNameOld": "86bef9030fa4e026107db74cd9eef288beb1beca",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,95 +1,95 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n-        if (editor \u003d\u003d null) {\n+        if (editor \u003d\u003d null \u0026\u0026 convertedValue \u003d\u003d newValue) {\n             throw firstAttemptEx;\n         }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "86bef9030fa4e026107db74cd9eef288beb1beca": {
      "type": "Ybodychange",
      "commitMessage": "correctly handle ParseException from Formatter for String-\u003eString case (SPR-8944)\n",
      "commitDate": "2011/12/22 下午10:54",
      "commitName": "86bef9030fa4e026107db74cd9eef288beb1beca",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/12/3 下午11:57",
      "commitNameOld": "84be348cb0ac99896674170dc9f99021b43ba9ee",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 18.96,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        if (editor \u003d\u003d null) {\n            throw firstAttemptEx;\n        }\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,92 +1,95 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException ex) {\n                 firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             if (firstAttemptEx !\u003d null) {\n                 throw firstAttemptEx;\n             }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     if (firstAttemptEx !\u003d null) {\n+        if (editor \u003d\u003d null) {\n+            throw firstAttemptEx;\n+        }\n         logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "84be348cb0ac99896674170dc9f99021b43ba9ee": {
      "type": "Ybodychange",
      "commitMessage": "log or rethrow original ConversionFailedException as appropriate\n",
      "commitDate": "2011/12/3 下午11:57",
      "commitName": "84be348cb0ac99896674170dc9f99021b43ba9ee",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/7/4 下午5:43",
      "commitNameOld": "57998293c811067cf87e6933f7abb4d4edb677c1",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 152.26,
      "commitsBetweenForRepo": 515,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionFailedException firstAttemptEx \u003d null;\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException ex) {\n                firstAttemptEx \u003d ex;\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            if (firstAttemptEx !\u003d null) {\n                throw firstAttemptEx;\n            }\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    if (firstAttemptEx !\u003d null) {\n        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 126,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,84 +1,92 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n+    ConversionFailedException firstAttemptEx \u003d null;\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n-            } catch (ConversionFailedException e) {\n+            } catch (ConversionFailedException ex) {\n+                firstAttemptEx \u003d ex;\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+            if (firstAttemptEx !\u003d null) {\n+                throw firstAttemptEx;\n+            }\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n+    if (firstAttemptEx !\u003d null) {\n+        logger.debug(\"Original ConversionService attempt failed - ignored since \" + \"PropertyEditor based conversion eventually succeeded\", firstAttemptEx);\n+    }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f288060ad8f0d007f1541213130d006729b9ec40": {
      "type": "Ybodychange",
      "commitMessage": "restored support for String-to-ContextResource conversion (SPR-8383)\n",
      "commitDate": "2011/6/15 下午11:40",
      "commitName": "f288060ad8f0d007f1541213130d006729b9ec40",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2011/6/7 上午10:51",
      "commitNameOld": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 8.53,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,84 +1,84 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException e) {\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n-                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n+                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value of type [\").append(ClassUtils.getDescriptiveType(convertedValue)).append(\"]\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5e3a5202fbd17cd30607ca7bb5360c9db8197e75": {
      "type": "Ybodychange",
      "commitMessage": "restored TypeDescriptor getElementType, getMapKeyType, and getMapValueType compatibility; StringToCollection and Array Converters are now conditional and check targetElementType if present; TypeDesciptor#isAssignable no longer bothers with element type and map key/value types in checking assignability for consistency elsewhere; improved javadoc\n",
      "commitDate": "2011/6/7 上午10:51",
      "commitName": "5e3a5202fbd17cd30607ca7bb5360c9db8197e75",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/6 上午1:52",
      "commitNameOld": "8c6890605a7080e2744be3f3994757cc72e394b0",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 1.37,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,84 +1,84 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException e) {\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n+            TypeDescriptor elementType \u003d typeDescriptor.getElementTypeDescriptor();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "8c6890605a7080e2744be3f3994757cc72e394b0": {
      "type": "Ybodychange",
      "commitMessage": "null type descriptor handling\n",
      "commitDate": "2011/6/6 上午1:52",
      "commitName": "8c6890605a7080e2744be3f3994757cc72e394b0",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/5 下午2:04",
      "commitNameOld": "2127b160512911e5f65a4e304f0b57826710a91d",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,84 +1,84 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n+    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 typeDescriptor !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             try {\n                 return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n             } catch (ConversionFailedException e) {\n             }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2127b160512911e5f65a4e304f0b57826710a91d": {
      "type": "Ybodychange",
      "commitMessage": "catch ConversionFailedException and fallback to default container conversion logic rather than propogate exception\n",
      "commitDate": "2011/6/5 下午2:04",
      "commitName": "2127b160512911e5f65a4e304f0b57826710a91d",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/5 下午1:46",
      "commitNameOld": "c306afed63e439ee133872a49380d76064bd2638",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            try {\n                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n            } catch (ConversionFailedException e) {\n            }\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 125,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,84 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+            try {\n+                return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+            } catch (ConversionFailedException e) {\n+            }\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c306afed63e439ee133872a49380d76064bd2638": {
      "type": "Ybodychange",
      "commitMessage": "polishing\n",
      "commitDate": "2011/6/5 下午1:46",
      "commitName": "c306afed63e439ee133872a49380d76064bd2638",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/5 下午12:43",
      "commitNameOld": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 124,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n+        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(newValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n             TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "c84cccf06dad4e3f11cd529ab16a5655bf723820": {
      "type": "Ybodychange",
      "commitMessage": "revised TypeDescriptor NULL and element/mapKey/mapValue type semantics\n",
      "commitDate": "2011/6/5 下午12:43",
      "commitName": "c84cccf06dad4e3f11cd529ab16a5655bf723820",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/6/3 上午7:37",
      "commitNameOld": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 2.21,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 123,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n-            Class elemType \u003d typeDescriptor.getElementType();\n-            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n+            TypeDescriptor elementType \u003d typeDescriptor.getElementType();\n+            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType.getType())) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "6f146737f475828b6d765784017773378c2c4922": {
      "type": "Ybodychange",
      "commitMessage": "simplified TypeDescriptor usage and updated use of the API across BeanWrapper and SpEL; collapsed PropertyTypeDescriptor into TypeDescriptor for simplicity and ease of use; improved docs\n",
      "commitDate": "2011/6/3 上午7:37",
      "commitName": "6f146737f475828b6d765784017773378c2c4922",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2011/1/5 下午1:49",
      "commitNameOld": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 148.74,
      "commitsBetweenForRepo": 438,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n            Class elemType \u003d typeDescriptor.getElementType();\n            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 123,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n-        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n-            Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String) {\n+            Class elemType \u003d typeDescriptor.getElementType();\n             if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6": {
      "type": "Ybodychange",
      "commitMessage": "TypeDescriptor cleanup and general polishing; fixed a number of bugs related to TypeDescriptor usage in client code across beans and spel packages\n",
      "commitDate": "2011/1/5 下午1:49",
      "commitName": "39e0c29d19fa5d1f8d2a7db57b16cc5a820db5a6",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2010/6/24 上午4:05",
      "commitNameOld": "942c656970df903705417b0b9631b2dd66e3bff0",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 195.41,
      "commitsBetweenForRepo": 382,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n-        TypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n+        TypeDescriptor targetTypeDesc \u003d typeDescriptor;\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n             Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n             if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e": {
      "type": "Ymodifierchange",
      "commitMessage": "revised BeanWrapper\u0027s exception wrapping to consistently handle ConversionExceptions (SPR-7177)\n",
      "commitDate": "2010/5/18 上午5:59",
      "commitName": "2ad2022058d4a2e3d29ea793ede2cb8c09f9102e",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/4/2 下午4:00",
      "commitNameOld": "580dc8e72ae823ab4cf988de94fd8ae922bd2fc4",
      "commitAuthorOld": "Chris Beams",
      "daysBetweenCommits": 45.58,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\npublic \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 127,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,81 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n-private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n+public \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n         TypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n             Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n             if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[public]"
      }
    },
    "cbed1c1b4b5fd74c9cd201890f619a7079804d3f": {
      "type": "Ybodychange",
      "commitMessage": "fixed collection element conversion using ConversionService (SPR-6950)\n",
      "commitDate": "2010/3/25 下午11:02",
      "commitName": "cbed1c1b4b5fd74c9cd201890f619a7079804d3f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2010/3/25 下午7:53",
      "commitNameOld": "d50881d82b8f2ed8e0947cdffe0e4f74fd3a53dd",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        TypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 187,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,80 +1,81 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n-        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n+        TypeDescriptor targetTypeDesc \u003d typeDescriptor.forElementType(requiredType);\n+        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n-            Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n-            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n+            Class elemType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+            if (elemType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elemType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "dc99df297274d8c1291cdaed5d9dd508910584d3": {
      "type": "Ybodychange",
      "commitMessage": "use TypeDescriptor.forObject instead of constructor; enforce use of TypeDescriptor.valueOf through making the constructor private\n",
      "commitDate": "2009/12/16 上午4:18",
      "commitName": "dc99df297274d8c1291cdaed5d9dd508910584d3",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/12/15 下午8:36",
      "commitNameOld": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,80 +1,80 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-        TypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n+        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.forObject(convertedValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n             Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde": {
      "type": "Ybodychange",
      "commitMessage": "introspect element type in case of incoming Collection/Map in order to not accidentally say canConvert\u003dtrue (SPR-6564)\n",
      "commitDate": "2009/12/15 下午8:36",
      "commitName": "2153b2fbd5aa4bff9b233fddb6c1c50cc879dcde",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/12/13 下午9:21",
      "commitNameOld": "5f9b4443194d3aa3948d76956897c0a1d918d546",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,80 +1,80 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n+        TypeDescriptor sourceTypeDesc \u003d new TypeDescriptor(convertedValue);\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n             Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n             if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n                 convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n             }\n         }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                     convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                 }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "5f9b4443194d3aa3948d76956897c0a1d918d546": {
      "type": "Ybodychange",
      "commitMessage": "bean properties of type enum array/collection can be populated with comma-separated String (SPR-6547)\n",
      "commitDate": "2009/12/13 下午9:21",
      "commitName": "5f9b4443194d3aa3948d76956897c0a1d918d546",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/11/27 上午9:43",
      "commitNameOld": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 16.48,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n            Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n            }\n        }\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n                }\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 186,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,71 +1,80 @@\n @SuppressWarnings(\"unchecked\")\n private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n         if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+        if (requiredType !\u003d null \u0026\u0026 Collection.class.isAssignableFrom(requiredType) \u0026\u0026 convertedValue instanceof String \u0026\u0026 typeDescriptor.getMethodParameter() !\u003d null) {\n+            Class elementType \u003d GenericCollectionTypeResolver.getCollectionParameterType(typeDescriptor.getMethodParameter());\n+            if (elementType !\u003d null \u0026\u0026 Enum.class.isAssignableFrom(elementType)) {\n+                convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+            }\n+        }\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n+                if (convertedValue instanceof String \u0026\u0026 Enum.class.isAssignableFrom(requiredType.getComponentType())) {\n+                    convertedValue \u003d StringUtils.commaDelimitedListToStringArray((String) convertedValue);\n+                }\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "ac490114aee005a66eeb0fba6c3c853552fc6a94": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange,Ydocchange)",
      "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
      "commitDate": "2009/11/27 上午9:43",
      "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009/11/27 上午9:43",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/10/15 上午4:45",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,77 +1,71 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-        TypeDescriptor targetTypeDesc;\n-        if (methodParam !\u003d null) {\n-            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-        } else {\n-            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-        }\n-        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n-            editor \u003d findDefaultEditor(requiredType, descriptor);\n+            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
            "newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, typeDescriptor-TypeDescriptor]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009/11/27 上午9:43",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/10/15 上午4:45",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,77 +1,71 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-        TypeDescriptor targetTypeDesc;\n-        if (methodParam !\u003d null) {\n-            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-        } else {\n-            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-        }\n-        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n-            editor \u003d findDefaultEditor(requiredType, descriptor);\n+            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009/11/27 上午9:43",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/10/15 上午4:45",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,77 +1,71 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-        TypeDescriptor targetTypeDesc;\n-        if (methodParam !\u003d null) {\n-            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-        } else {\n-            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-        }\n-        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n-            editor \u003d findDefaultEditor(requiredType, descriptor);\n+            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Ydocchange",
          "commitMessage": "propagate full TypeDescriptor for field-level conversion as well\n",
          "commitDate": "2009/11/27 上午9:43",
          "commitName": "ac490114aee005a66eeb0fba6c3c853552fc6a94",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/10/15 上午4:45",
          "commitNameOld": "dc076ee6fe285af7d5deb138f2eb289487d5621f",
          "commitAuthorOld": "Keith Donald",
          "daysBetweenCommits": 43.21,
          "commitsBetweenForRepo": 404,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprivate \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 186,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,77 +1,71 @@\n @SuppressWarnings(\"unchecked\")\n-protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+private \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, TypeDescriptor typeDescriptor) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n-        TypeDescriptor targetTypeDesc;\n-        if (methodParam !\u003d null) {\n-            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n-        } else {\n-            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n-        }\n-        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n-            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n+        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, typeDescriptor);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n-            editor \u003d findDefaultEditor(requiredType, descriptor);\n+            editor \u003d findDefaultEditor(requiredType, typeDescriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, typeDescriptor);\n             } else if (convertedValue instanceof Map) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, typeDescriptor);\n             }\n             if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                 convertedValue \u003d Array.get(convertedValue, 0);\n             }\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
            "newValue": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param typeDescriptor the descriptor for the target property or field\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n"
          }
        }
      ]
    },
    "84447cdf9493a5f6ead3450627d8938af1b7ac5f": {
      "type": "Ybodychange",
      "commitMessage": "DataBinder activates autoGrowNestedPaths by default; fixed enum binding with WebRequestDataBinder\n",
      "commitDate": "2009/10/14 上午4:55",
      "commitName": "84447cdf9493a5f6ead3450627d8938af1b7ac5f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/9/19 上午4:32",
      "commitNameOld": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 25.02,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        TypeDescriptor targetTypeDesc;\n        if (methodParam !\u003d null) {\n            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            }\n            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n                convertedValue \u003d Array.get(convertedValue, 0);\n            }\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 157,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,73 +1,77 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n         TypeDescriptor targetTypeDesc;\n         if (methodParam !\u003d null) {\n             targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n         } else {\n             targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n         }\n         if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n             return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n-            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-                return (T) convertedValue.toString();\n-            } else if (requiredType.isArray()) {\n+            if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n+            }\n+            if (convertedValue.getClass().isArray() \u0026\u0026 Array.getLength(convertedValue) \u003d\u003d 1) {\n+                convertedValue \u003d Array.get(convertedValue, 0);\n+            }\n+            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+                return (T) convertedValue.toString();\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45c542e51e9b01526a97a1644aebfe1e94a2342f": {
      "type": "Ybodychange",
      "commitMessage": "updated for change in conversion service api; source type desc now required\n",
      "commitDate": "2009/9/19 上午4:32",
      "commitName": "45c542e51e9b01526a97a1644aebfe1e94a2342f",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/9/19 上午3:57",
      "commitNameOld": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "commitAuthorOld": "Keith Donald",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n        TypeDescriptor targetTypeDesc;\n        if (methodParam !\u003d null) {\n            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,72 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n-        TypeDescriptor typeDesc;\n+        TypeDescriptor sourceTypeDesc \u003d TypeDescriptor.valueOf(convertedValue.getClass());\n+        TypeDescriptor targetTypeDesc;\n         if (methodParam !\u003d null) {\n-            typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n+            targetTypeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n         } else {\n-            typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n+            targetTypeDesc \u003d TypeDescriptor.valueOf(requiredType);\n         }\n-        if (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n-            return (T) conversionService.convert(convertedValue, typeDesc);\n+        if (conversionService.canConvert(sourceTypeDesc, targetTypeDesc)) {\n+            return (T) conversionService.convert(convertedValue, sourceTypeDesc, targetTypeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "d3b43ebccb923c6d5825b10d4f4f305b54ee549d": {
      "type": "Ybodychange",
      "commitMessage": "refined generic converter concept\n",
      "commitDate": "2009/9/19 上午3:57",
      "commitName": "d3b43ebccb923c6d5825b10d4f4f305b54ee549d",
      "commitAuthor": "Keith Donald",
      "commitDateOld": "2009/9/12 上午2:31",
      "commitNameOld": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
      "commitAuthorOld": "Rob Harrop",
      "daysBetweenCommits": 7.06,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor typeDesc;\n        if (methodParam !\u003d null) {\n            typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,72 +1,72 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor typeDesc;\n         if (methodParam !\u003d null) {\n             typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n         } else {\n             typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n         }\n-        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+        if (conversionService.matches(convertedValue.getClass(), typeDesc)) {\n             return (T) conversionService.convert(convertedValue, typeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "1480202aa37d7edaf7f070a2bf45cd3a1016eea7": {
      "type": "Ybodychange",
      "commitMessage": "[SPR-5644] Support for Enum\u003c?\u003e and Enum\u003cT\u003e values as FQN.FIELD_NAME in type conversion\n",
      "commitDate": "2009/9/12 上午2:31",
      "commitName": "1480202aa37d7edaf7f070a2bf45cd3a1016eea7",
      "commitAuthor": "Rob Harrop",
      "commitDateOld": "2009/9/8 上午7:58",
      "commitNameOld": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor typeDesc;\n        if (methodParam !\u003d null) {\n            typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,79 +1,72 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n         TypeDescriptor typeDesc;\n         if (methodParam !\u003d null) {\n             typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n         } else {\n             typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n         }\n         if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n             return (T) conversionService.convert(convertedValue, typeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n-                try {\n-                    Field enumField \u003d requiredType.getField(trimmedValue);\n-                    convertedValue \u003d enumField.get(null);\n-                } catch (Throwable ex) {\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n-                    }\n-                }\n+                convertedValue \u003d attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "a86a698e5b3394c9b6721a784c8fe251611ff16b": {
      "type": "Ybodychange",
      "commitMessage": "initial JSR-303 Bean Validation support; revised ConversionService and FormatterRegistry\n",
      "commitDate": "2009/9/8 上午7:58",
      "commitName": "a86a698e5b3394c9b6721a784c8fe251611ff16b",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/25 下午9:49",
      "commitNameOld": "04cd95ff50f78f4b8ff738f6ca183abe06b366ee",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 13.42,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n        TypeDescriptor typeDesc;\n        if (methodParam !\u003d null) {\n            typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n        } else {\n            typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n        }\n        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n            return (T) conversionService.convert(convertedValue, typeDesc);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(trimmedValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,75 +1,79 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n-    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null) {\n+        TypeDescriptor typeDesc;\n         if (methodParam !\u003d null) {\n-            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+            typeDesc \u003d (descriptor !\u003d null ? new BeanTypeDescriptor(methodParam, descriptor) : new TypeDescriptor(methodParam));\n         } else {\n-            return conversionService.convert(convertedValue, requiredType);\n+            typeDesc \u003d TypeDescriptor.valueOf(requiredType);\n+        }\n+        if (conversionService.canConvert(convertedValue.getClass(), typeDesc)) {\n+            return (T) conversionService.convert(convertedValue, typeDesc);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof Map) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                     try {\n                         Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                         return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                     } catch (NoSuchMethodException ex) {\n                         if (logger.isTraceEnabled()) {\n                             logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     } catch (Exception ex) {\n                         if (logger.isDebugEnabled()) {\n                             logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                         }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(trimmedValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "9a48f3f3a896cad821e5847a93d91c997905e325": {
      "type": "Ybodychange",
      "commitMessage": "try to create unknown collection implementation types via default constructor\n",
      "commitDate": "2009/8/25 下午9:29",
      "commitName": "9a48f3f3a896cad821e5847a93d91c997905e325",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/24 下午9:48",
      "commitNameOld": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam !\u003d null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof Map) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n                    try {\n                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                    } catch (NoSuchMethodException ex) {\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    } catch (Exception ex) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                        }\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(trimmedValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,73 +1,75 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n         if (methodParam !\u003d null) {\n             return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n         } else {\n             return conversionService.convert(convertedValue, requiredType);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n-            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n-                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n-            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n-                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+            } else if (convertedValue instanceof Collection) {\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, requiredType, methodParam);\n+            } else if (convertedValue instanceof Map) {\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, requiredType, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-                try {\n-                    Constructor strCtor \u003d requiredType.getConstructor(String.class);\n-                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n-                } catch (NoSuchMethodException ex) {\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n-                    }\n-                } catch (Exception ex) {\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+                if (!requiredType.isInterface() \u0026\u0026 !requiredType.isEnum()) {\n+                    try {\n+                        Constructor strCtor \u003d requiredType.getConstructor(String.class);\n+                        return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+                    } catch (NoSuchMethodException ex) {\n+                        if (logger.isTraceEnabled()) {\n+                            logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+                        }\n+                    } catch (Exception ex) {\n+                        if (logger.isDebugEnabled()) {\n+                            logger.debug(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+                        }\n                     }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(trimmedValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f": {
      "type": "Ybodychange",
      "commitMessage": "fixed accidental test failures\n",
      "commitDate": "2009/8/24 下午9:48",
      "commitName": "04b619ebfbc1e08a9e9bdc54263b3ece21f4aa7f",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/24 下午9:30",
      "commitNameOld": "fee838a65e87f5da4b65b04ea5101681d6308104",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam !\u003d null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                try {\n                    Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                } catch (NoSuchMethodException ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                } catch (Exception ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(trimmedValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,69 +1,73 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n         if (methodParam !\u003d null) {\n             return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n         } else {\n             return conversionService.convert(convertedValue, requiredType);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 try {\n                     Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                     return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                 } catch (NoSuchMethodException ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                     }\n+                } catch (Exception ex) {\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"Construction via String failed for type [\" + requiredType.getName() + \"]\", ex);\n+                    }\n                 }\n                 String trimmedValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(trimmedValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "fee838a65e87f5da4b65b04ea5101681d6308104": {
      "type": "Ybodychange",
      "commitMessage": "support for default \"conversionService\" bean in an ApplicationContext; revised formatting package, now integrated with DataBinder and AnnotationMethodHandlerAdapter; revised AccessControlContext access from BeanFactory\n",
      "commitDate": "2009/8/24 下午9:30",
      "commitName": "fee838a65e87f5da4b65b04ea5101681d6308104",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/8/9 上午8:46",
      "commitNameOld": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 15.53,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam !\u003d null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                try {\n                    Constructor strCtor \u003d requiredType.getConstructor(String.class);\n                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n                } catch (NoSuchMethodException ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n                    }\n                }\n                String trimmedValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(trimmedValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 156,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,61 +1,69 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n     if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n         if (methodParam !\u003d null) {\n             return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n         } else {\n             return conversionService.convert(convertedValue, requiredType);\n         }\n     }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n-                String strValue \u003d ((String) convertedValue).trim();\n-                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+                try {\n+                    Constructor strCtor \u003d requiredType.getConstructor(String.class);\n+                    return (T) BeanUtils.instantiateClass(strCtor, convertedValue);\n+                } catch (NoSuchMethodException ex) {\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"No String constructor found on type [\" + requiredType.getName() + \"]\", ex);\n+                    }\n+                }\n+                String trimmedValue \u003d ((String) convertedValue).trim();\n+                if (requiredType.isEnum() \u0026\u0026 \"\".equals(trimmedValue)) {\n                     return null;\n                 }\n                 try {\n-                    Field enumField \u003d requiredType.getField(strValue);\n+                    Field enumField \u003d requiredType.getField(trimmedValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4": {
      "type": "Ybodychange",
      "commitMessage": "revised core conversion package for BeanWrapper/BeanFactory integration\n",
      "commitDate": "2009/8/9 上午8:46",
      "commitName": "45a0cadf8e7fc5cc082c11ef03f77dc017af64c4",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2009/5/12 上午6:44",
      "commitNameOld": "0297116542a3ce33d19a6a81b8240097081376c5",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 89.08,
      "commitsBetweenForRepo": 569,
      "commitsBetweenForFile": 1,
      "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n        if (methodParam !\u003d null) {\n            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n        } else {\n            return conversionService.convert(convertedValue, requiredType);\n        }\n    }\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 155,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,53 +1,61 @@\n @SuppressWarnings(\"unchecked\")\n protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n+    ConversionService conversionService \u003d this.propertyEditorRegistry.getConversionService();\n+    if (editor \u003d\u003d null \u0026\u0026 conversionService !\u003d null \u0026\u0026 convertedValue !\u003d null \u0026\u0026 conversionService.canConvert(convertedValue.getClass(), requiredType)) {\n+        if (methodParam !\u003d null) {\n+            return (T) conversionService.convert(convertedValue, new TypeDescriptor(methodParam));\n+        } else {\n+            return conversionService.convert(convertedValue, requiredType);\n+        }\n+    }\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n     return (T) convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "0297116542a3ce33d19a6a81b8240097081376c5": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange,Yannotationchange)",
      "commitMessage": "generified TypeConverter interface\n",
      "commitDate": "2009/5/12 上午6:44",
      "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
      "commitAuthor": "Juergen Hoeller",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009/5/12 上午6:44",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/5/11 下午10:52",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,52 +1,53 @@\n-protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+@SuppressWarnings(\"unchecked\")\n+protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-                return convertedValue.toString();\n+                return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n-                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n-    return convertedValue;\n+    return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class, descriptor-PropertyDescriptor, methodParam-MethodParameter]",
            "newValue": "[propertyName-String, oldValue-Object, newValue-Object, requiredType-Class\u003cT\u003e, descriptor-PropertyDescriptor, methodParam-MethodParameter]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009/5/12 上午6:44",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/5/11 下午10:52",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,52 +1,53 @@\n-protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+@SuppressWarnings(\"unchecked\")\n+protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-                return convertedValue.toString();\n+                return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n-                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n-    return convertedValue;\n+    return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "Object",
            "newValue": "T"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009/5/12 上午6:44",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/5/11 下午10:52",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,52 +1,53 @@\n-protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+@SuppressWarnings(\"unchecked\")\n+protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-                return convertedValue.toString();\n+                return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n-                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n-    return convertedValue;\n+    return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {}
        },
        {
          "type": "Yannotationchange",
          "commitMessage": "generified TypeConverter interface\n",
          "commitDate": "2009/5/12 上午6:44",
          "commitName": "0297116542a3ce33d19a6a81b8240097081376c5",
          "commitAuthor": "Juergen Hoeller",
          "commitDateOld": "2009/5/11 下午10:52",
          "commitNameOld": "bf7a947559d8f9918cc738780bf04caf8ea46962",
          "commitAuthorOld": "Arjen Poutsma",
          "daysBetweenCommits": 0.33,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "actualSource": "@SuppressWarnings(\"unchecked\")\nprotected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return (T) convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return (T) convertedValue;\n}",
          "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
          "functionStartLine": 153,
          "functionName": "convertIfNecessary",
          "functionAnnotation": "@SuppressWarnings(\"unchecked\")",
          "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
          "diff": "@@ -1,52 +1,53 @@\n-protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+@SuppressWarnings(\"unchecked\")\n+protected \u003cT\u003e T convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class\u003cT\u003e requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n-                return convertedValue.toString();\n+                return (T) convertedValue.toString();\n             } else if (requiredType.isArray()) {\n-                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+                return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                 throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n                 throw new IllegalStateException(msg.toString());\n             }\n         }\n     }\n-    return convertedValue;\n+    return (T) convertedValue;\n }\n\\ No newline at end of file\n",
          "extendedDetails": {
            "oldValue": "",
            "newValue": "@SuppressWarnings(\"unchecked\")"
          }
        }
      ]
    },
    "bf7a947559d8f9918cc738780bf04caf8ea46962": {
      "type": "Ybodychange",
      "commitMessage": "SPR-5732 - When no type conversion strategy is found on a @Controller handler method bind target, a 500 error code should be returned not a 400.\n\n",
      "commitDate": "2009/5/11 下午10:52",
      "commitName": "bf7a947559d8f9918cc738780bf04caf8ea46962",
      "commitAuthor": "Arjen Poutsma",
      "commitDateOld": "2008/11/25 上午9:29",
      "commitNameOld": "29657105da133995b0b2277b82c75d1df2931b64",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 167.56,
      "commitsBetweenForRepo": 808,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n                throw new IllegalArgumentException(msg.toString());\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n                throw new IllegalStateException(msg.toString());\n            }\n        }\n    }\n    return convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,51 +1,52 @@\n protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n+                throw new IllegalArgumentException(msg.toString());\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n+                throw new IllegalStateException(msg.toString());\n             }\n-            throw new IllegalArgumentException(msg.toString());\n         }\n     }\n     return convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "29657105da133995b0b2277b82c75d1df2931b64": {
      "type": "Ybodychange",
      "commitMessage": "Java 5 code style\n",
      "commitDate": "2008/11/25 上午9:29",
      "commitName": "29657105da133995b0b2277b82c75d1df2931b64",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/11/20 上午10:10",
      "commitNameOld": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthorOld": "Juergen Hoeller",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,51 +1,51 @@\n protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n                 if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n             StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n-                msg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n+                msg.append(\" for property \u0027\").append(propertyName).append(\"\u0027\");\n             }\n             if (editor !\u003d null) {\n-                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+                msg.append(\": PropertyEditor [\").append(editor.getClass().getName()).append(\"] returned inappropriate value\");\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n             }\n             throw new IllegalArgumentException(msg.toString());\n         }\n     }\n     return convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "347f34c68a7a5bab46cf869e762fb3cee9a1fedc": {
      "type": "Ybodychange",
      "commitMessage": "EL container integration; support for contextual objects; removal of deprecated Spring 2.0 functionality; Java 5 code style\n",
      "commitDate": "2008/11/20 上午10:10",
      "commitName": "347f34c68a7a5bab46cf869e762fb3cee9a1fedc",
      "commitAuthor": "Juergen Hoeller",
      "commitDateOld": "2008/10/23 上午12:13",
      "commitNameOld": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthorOld": "Arjen Poutsma",
      "daysBetweenCommits": 28.41,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "actualSource": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuilder msg \u003d new StringBuilder();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 152,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n",
      "diff": "@@ -1,51 +1,51 @@\n protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n     Object convertedValue \u003d newValue;\n     PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n     if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n         if (editor \u003d\u003d null) {\n             editor \u003d findDefaultEditor(requiredType, descriptor);\n         }\n         convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n     }\n     if (requiredType !\u003d null) {\n         if (convertedValue !\u003d null) {\n             if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                 return convertedValue.toString();\n             } else if (requiredType.isArray()) {\n                 return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n             } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                 convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                 convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n             } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                 String strValue \u003d ((String) convertedValue).trim();\n-                if (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+                if (requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                     return null;\n                 }\n                 try {\n                     Field enumField \u003d requiredType.getField(strValue);\n                     convertedValue \u003d enumField.get(null);\n                 } catch (Throwable ex) {\n                     if (logger.isTraceEnabled()) {\n                         logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                     }\n                 }\n             }\n         }\n         if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n-            StringBuffer msg \u003d new StringBuffer();\n+            StringBuilder msg \u003d new StringBuilder();\n             msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n             msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n             if (propertyName !\u003d null) {\n                 msg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n             }\n             if (editor !\u003d null) {\n                 msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n             } else {\n                 msg.append(\": no matching editors or conversion strategy found\");\n             }\n             throw new IllegalArgumentException(msg.toString());\n         }\n     }\n     return convertedValue;\n }\n\\ No newline at end of file\n",
      "extendedDetails": {}
    },
    "f11d3436ed21d3908b9e0b569f2d783df161c0a3": {
      "type": "Yintroduced",
      "commitMessage": "Moved over initial version of beans bundle\n",
      "commitDate": "2008/10/23 上午12:13",
      "commitName": "f11d3436ed21d3908b9e0b569f2d783df161c0a3",
      "commitAuthor": "Arjen Poutsma",
      "diff": "@@ -0,0 +1,51 @@\n+protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n+    Object convertedValue \u003d newValue;\n+    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n+    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n+        if (editor \u003d\u003d null) {\n+            editor \u003d findDefaultEditor(requiredType, descriptor);\n+        }\n+        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n+    }\n+    if (requiredType !\u003d null) {\n+        if (convertedValue !\u003d null) {\n+            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n+                return convertedValue.toString();\n+            } else if (requiredType.isArray()) {\n+                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n+            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n+                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n+            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n+                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n+            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n+                String strValue \u003d ((String) convertedValue).trim();\n+                if (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n+                    return null;\n+                }\n+                try {\n+                    Field enumField \u003d requiredType.getField(strValue);\n+                    convertedValue \u003d enumField.get(null);\n+                } catch (Throwable ex) {\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n+                    }\n+                }\n+            }\n+        }\n+        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n+            StringBuffer msg \u003d new StringBuffer();\n+            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n+            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n+            if (propertyName !\u003d null) {\n+                msg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n+            }\n+            if (editor !\u003d null) {\n+                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n+            } else {\n+                msg.append(\": no matching editors or conversion strategy found\");\n+            }\n+            throw new IllegalArgumentException(msg.toString());\n+        }\n+    }\n+    return convertedValue;\n+}\n\\ No newline at end of file\n",
      "actualSource": "protected Object convertIfNecessary(String propertyName, Object oldValue, Object newValue, Class requiredType, PropertyDescriptor descriptor, MethodParameter methodParam) throws IllegalArgumentException {\n    Object convertedValue \u003d newValue;\n    PropertyEditor editor \u003d this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);\n    if (editor !\u003d null || (requiredType !\u003d null \u0026\u0026 !ClassUtils.isAssignableValue(requiredType, convertedValue))) {\n        if (editor \u003d\u003d null) {\n            editor \u003d findDefaultEditor(requiredType, descriptor);\n        }\n        convertedValue \u003d doConvertValue(oldValue, convertedValue, requiredType, editor);\n    }\n    if (requiredType !\u003d null) {\n        if (convertedValue !\u003d null) {\n            if (String.class.equals(requiredType) \u0026\u0026 ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {\n                return convertedValue.toString();\n            } else if (requiredType.isArray()) {\n                return convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());\n            } else if (convertedValue instanceof Collection \u0026\u0026 CollectionFactory.isApproximableCollectionType(requiredType)) {\n                convertedValue \u003d convertToTypedCollection((Collection) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof Map \u0026\u0026 CollectionFactory.isApproximableMapType(requiredType)) {\n                convertedValue \u003d convertToTypedMap((Map) convertedValue, propertyName, methodParam);\n            } else if (convertedValue instanceof String \u0026\u0026 !requiredType.isInstance(convertedValue)) {\n                String strValue \u003d ((String) convertedValue).trim();\n                if (JdkVersion.isAtLeastJava15() \u0026\u0026 requiredType.isEnum() \u0026\u0026 \"\".equals(strValue)) {\n                    return null;\n                }\n                try {\n                    Field enumField \u003d requiredType.getField(strValue);\n                    convertedValue \u003d enumField.get(null);\n                } catch (Throwable ex) {\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Field [\" + convertedValue + \"] isn\u0027t an enum value\", ex);\n                    }\n                }\n            }\n        }\n        if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {\n            StringBuffer msg \u003d new StringBuffer();\n            msg.append(\"Cannot convert value of type [\").append(ClassUtils.getDescriptiveType(newValue));\n            msg.append(\"] to required type [\").append(ClassUtils.getQualifiedName(requiredType)).append(\"]\");\n            if (propertyName !\u003d null) {\n                msg.append(\" for property \u0027\" + propertyName + \"\u0027\");\n            }\n            if (editor !\u003d null) {\n                msg.append(\": PropertyEditor [\" + editor.getClass().getName() + \"] returned inappropriate value\");\n            } else {\n                msg.append(\": no matching editors or conversion strategy found\");\n            }\n            throw new IllegalArgumentException(msg.toString());\n        }\n    }\n    return convertedValue;\n}",
      "path": "org.springframework.beans/src/main/java/org/springframework/beans/TypeConverterDelegate.java",
      "functionStartLine": 158,
      "functionName": "convertIfNecessary",
      "functionAnnotation": "",
      "functionDoc": "Convert the value to the required type (if necessary from a String),\nfor the specified property.\n\n@param propertyName name of the property\n@param oldValue the previous value, if available (may be \u003ccode\u003enull\u003c/code\u003e)\n@param newValue the proposed new value\n@param requiredType the type we must convert to\n(or \u003ccode\u003enull\u003c/code\u003e if not known, for example in case of a collection element)\n@param descriptor the JavaBeans descriptor for the property\n@param methodParam the method parameter that is the target of the conversion\n(may be \u003ccode\u003enull\u003c/code\u003e)\n@return the new value, possibly the result of type conversion\n@throws IllegalArgumentException if type conversion failed\n"
    }
  }
}